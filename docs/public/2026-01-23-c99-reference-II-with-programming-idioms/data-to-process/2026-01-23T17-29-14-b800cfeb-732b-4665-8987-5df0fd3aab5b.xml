<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>
  <category id="c99.idioms" name="C99 idioms and patterns">
    <summary><![CDATA[
<p>
Curated C99 programming idioms and reusable patterns. Each entry captures a portable, implementation-ready pattern
with a concise description and a focused code example.
</p>
<p>
Search for <code>idiom: &lt;name&gt;</code> to find a specific pattern, or use the idiom name directly to jump to its card.
</p>
]]></summary>

    <keywords>
      <kw>idiom</kw>
      <kw>idioms</kw>
      <kw>pattern</kw>
      <kw>patterns</kw>
      <kw>&quot;Advance before use&quot; scanning with assignment in the condition</kw>
      <kw>&quot;Append pointer&quot; pattern for building strings efficiently</kw>
      <kw>&quot;Close on success, free on failure&quot; with ownership transfer</kw>
      <kw>&quot;do while&quot; loop</kw>
      <kw>&quot;Flexible array member&quot; for variable-sized structs (C99 feature)</kw>
      <kw>&quot;Inline constant struct&quot; as a default value without macros</kw>
      <kw>&quot;Length-limited string scan&quot; without copying</kw>
      <kw>&quot;Loop that guarantees at least one iteration&quot; with `do { } while (0)` (not just for macros)</kw>
      <kw>&quot;One definition of a flag set&quot; via an enum and bit masks</kw>
      <kw>&quot;Optional output&quot; pointers with a simple guard</kw>
      <kw>&quot;Return value capture&quot; so you do not lose error information</kw>
      <kw>&quot;Sentinel at end&quot; arrays for tables of variable length</kw>
      <kw>&quot;Two-pointer&quot; walk for in-place filtering/compaction</kw>
      <kw>&quot;User data&quot; callbacks (poor man&apos;s closures)</kw>
      <kw>`enum` as compile-time integer constants</kw>
      <kw>`fgets` loop with newline trimming in one place</kw>
      <kw>`memchr` as a fast &quot;find delimiter in bytes&quot;</kw>
      <kw>`offsetof` from `&lt;stddef.h&gt;` for layout-aware code</kw>
      <kw>`realloc` with a temporary to avoid losing the original pointer on failure</kw>
      <kw>`snprintf` for bounded formatting and detecting truncation</kw>
      <kw>`sscanf` is tempting, but `strto*` with end pointers composes better</kw>
      <kw>`volatile` only for hardware/async boundaries, not for &quot;thread safety&quot;</kw>
      <kw>Abort program execution with error condition</kw>
      <kw>Add LSB-first digit arrays with carry</kw>
      <kw>Align up/down with power-of-two alignment (common, but easy to botch)</kw>
      <kw>Allocate 1M bytes</kw>
      <kw>Allocate using the pointed-to type, not repeating the type name</kw>
      <kw>Array difference using binary search lookup</kw>
      <kw>Assert condition</kw>
      <kw>Assign to string the japanese word ネコ</kw>
      <kw>Assignment in condition to express &quot;read then test&quot;</kw>
      <kw>Binary digits to byte array</kw>
      <kw>Binary search in sorted array</kw>
      <kw>Binomial coefficient &quot;n choose k&quot;</kw>
      <kw>Bitset membership with unsigned shifts (avoid UB on signed)</kw>
      <kw>Boolean normalization with `!!`</kw>
      <kw>Branchless &quot;is power of two&quot; (and exclude 0)</kw>
      <kw>Break outer loop</kw>
      <kw>Byte extraction with masks and shifts (portable endianness-agnostic logic)</kw>
      <kw>Bytes to hex string</kw>
      <kw>Calculate exponentiation of real numbers</kw>
      <kw>Call an external C function</kw>
      <kw>Character stack with flexible array member</kw>
      <kw>Check for overflow before multiply/add (portable pattern)</kw>
      <kw>Check if any value in a list is larger than a limit</kw>
      <kw>Check if file exists</kw>
      <kw>Check if integer addition will overflow</kw>
      <kw>Check if integer is even</kw>
      <kw>Check if list contains a value</kw>
      <kw>Check if point is inside rectangle</kw>
      <kw>Check if string contains a word</kw>
      <kw>Check if string contains only digits</kw>
      <kw>Check if string is blank</kw>
      <kw>Check palindrome in byte array</kw>
      <kw>Check string prefix</kw>
      <kw>Clamp a value to a range</kw>
      <kw>Comment out a single line</kw>
      <kw>Compile-time array length (ARRAY_LEN/ARRAY_SIZE)</kw>
      <kw>Compile-time assertion (typedef trick)</kw>
      <kw>Complex number</kw>
      <kw>Compound literals for &quot;temporary objects with an address&quot;</kw>
      <kw>Compute GCD</kw>
      <kw>Compute LCM</kw>
      <kw>Compute sum of integers</kw>
      <kw>Conditional assignment</kw>
      <kw>Container-of pattern (common, but not standard-library provided)</kw>
      <kw>Continue outer loop</kw>
      <kw>Convert integer to floating point number</kw>
      <kw>Convert integer to string</kw>
      <kw>Convert real number to string with 2 decimal places</kw>
      <kw>Convert string to camelCase</kw>
      <kw>Convert string to integer</kw>
      <kw>Convert string to integer, explicit base</kw>
      <kw>Copy string into buffer with capacity and null-terminate</kw>
      <kw>Count backwards</kw>
      <kw>Count decimal digits in integer</kw>
      <kw>Count set bits (popcount)</kw>
      <kw>Count substring occurrences</kw>
      <kw>Count trailing zero bits</kw>
      <kw>Counted push with post-increment (your pattern) plus the &quot;guard&quot; form</kw>
      <kw>Create a 2-dimensional array</kw>
      <kw>Create a 2D Point data structure</kw>
      <kw>Create a 3-dimensional array</kw>
      <kw>Create a Binary Tree data structure</kw>
      <kw>Create a function</kw>
      <kw>Create a map (associative array)</kw>
      <kw>Create a procedure</kw>
      <kw>Create a Tree data structure</kw>
      <kw>Create temp file</kw>
      <kw>ctype functions: cast to unsigned char, and do not pass pointers</kw>
      <kw>Current executable name</kw>
      <kw>Custom allocation hooks via macros (malloc/free/realloc)</kw>
      <kw>Date struct with year/month/day fields</kw>
      <kw>Days in month with leap-year adjustment</kw>
      <kw>Days since 1971-01-01 for date</kw>
      <kw>Debug logging macro (compiled out in release)</kw>
      <kw>Declare an enumeration</kw>
      <kw>Declare constant string</kw>
      <kw>Deduplicate sorted array in place</kw>
      <kw>Delete file</kw>
      <kw>Depth-first traversal in a graph</kw>
      <kw>Designated initializers to document intent and avoid field-order coupling</kw>
      <kw>Detect zero digit in base-10 representation</kw>
      <kw>Dynamic int array with capacity growth</kw>
      <kw>Echo program implementation</kw>
      <kw>Execute procedures depending on options</kw>
      <kw>Exit program cleanly (EXIT_SUCCESS)</kw>
      <kw>Extract a substring</kw>
      <kw>Extract file content to a string</kw>
      <kw>Find substring position</kw>
      <kw>Fixed-capacity positive decimal digit buffer (LSB-first)</kw>
      <kw>Flexible &quot;build up an initializer&quot; with trailing commas</kw>
      <kw>Format a number with grouped thousands</kw>
      <kw>Format decimal number</kw>
      <kw>Formula with arrays</kw>
      <kw>Free and null a pointer</kw>
      <kw>Get an environment variable</kw>
      <kw>Get current date</kw>
      <kw>Get file size</kw>
      <kw>Get folder containing current program</kw>
      <kw>Get program working directory</kw>
      <kw>Handle invalid argument</kw>
      <kw>Hex dump loop that is careful about signedness</kw>
      <kw>Hex string to byte array</kw>
      <kw>Hexadecimal digits of an integer</kw>
      <kw>Increment decimal digit array in place</kw>
      <kw>Integer exponentiation by squaring</kw>
      <kw>Interleave halves of array</kw>
      <kw>Iterate over list indexes and values</kw>
      <kw>Iterate over list values</kw>
      <kw>Join a list of strings</kw>
      <kw>Join integer from LSB-first digit array</kw>
      <kw>Last element of list</kw>
      <kw>Launch other program</kw>
      <kw>Leap year check (Gregorian 4/100/400 rule)</kw>
      <kw>List files in directory</kw>
      <kw>Local static for expensive one-time setup inside a function</kw>
      <kw>Make an infinite loop</kw>
      <kw>Measure elapsed CPU time</kw>
      <kw>Memset a struct via its address, not by casting</kw>
      <kw>Multi-line string literal</kw>
      <kw>Multiple return values</kw>
      <kw>Multiply all the elements of a list</kw>
      <kw>Number of bytes of a type</kw>
      <kw>Packed bitset with test/set/clear</kw>
      <kw>Parenthesis classification and matching</kw>
      <kw>Parse integer digits to LSB-first array</kw>
      <kw>Parse ISO date string YYYY-MM-DD with validation</kw>
      <kw>Parse uint32 from ASCII decimal string (validated)</kw>
      <kw>Parse with `strtol` and keep the end pointer in the loop header</kw>
      <kw>Pass a runnable procedure as parameter</kw>
      <kw>Pause execution for 5 seconds</kw>
      <kw>Pick a random element from a list</kw>
      <kw>Pick uniformly a random floating point number in [a..b)</kw>
      <kw>Pick uniformly a random integer in [a..b]</kw>
      <kw>Pointer iteration over array with end pointer</kw>
      <kw>Preserve `errno` across cleanup that might clobber it</kw>
      <kw>Print `size_t` and pointers correctly</kw>
      <kw>Print Hello 10 times</kw>
      <kw>Print Hello World</kw>
      <kw>Print integer array with brackets</kw>
      <kw>Print list elements by group of 2</kw>
      <kw>Public declaration macro for C/C++ linkage (extern/static)</kw>
      <kw>Quine program</kw>
      <kw>Read command line argument</kw>
      <kw>Read file line by line</kw>
      <kw>Read integer from stdin</kw>
      <kw>Recursive factorial (simple)</kw>
      <kw>Rename file</kw>
      <kw>Repeated string</kw>
      <kw>Resize dynamic array safely</kw>
      <kw>Result code enum for success/failure</kw>
      <kw>Return fraction and exponent of a real number</kw>
      <kw>Return static string literal</kw>
      <kw>Return status/error code with output parameters</kw>
      <kw>Reverse a string</kw>
      <kw>Reverse array/list in place</kw>
      <kw>Reverse loop without unsigned underflow traps</kw>
      <kw>Roman numeral conversion (char map + subtractive parse)</kw>
      <kw>Round floating point number to integer</kw>
      <kw>Safe memory allocation</kw>
      <kw>Safe string copy with truncation</kw>
      <kw>Seed random generator</kw>
      <kw>Set, clear, and test a bit</kw>
      <kw>Shuffle a list</kw>
      <kw>Simple stack using array</kw>
      <kw>Single-exit cleanup with `goto`</kw>
      <kw>Single-header library with implementation macro and feature toggles</kw>
      <kw>Size-in, size-out for buffers (and report required size)</kw>
      <kw>Sort by a comparator (qsort/bsearch)</kw>
      <kw>Source code inclusion</kw>
      <kw>Sparse array initialization with designated indices</kw>
      <kw>Split a space-separated string</kw>
      <kw>Strict aliasing safe type-punning: use `memcpy`, not pointer casts</kw>
      <kw>String interpolation</kw>
      <kw>Stringize and concatenate for generating names and messages</kw>
      <kw>Successive conditions</kw>
      <kw>Sum digits in array</kw>
      <kw>Swap values via temporary</kw>
      <kw>Switch-driven state machine with intentional fallthrough</kw>
      <kw>Test if string is empty</kw>
      <kw>The canonical &quot;walk a C string&quot; pointer loop</kw>
      <kw>The comma operator for tight loops (use sparingly)</kw>
      <kw>The do-while(0) macro wrapper so statements behave like statements</kw>
      <kw>Tokenize without `strtok` by using `strcspn` and manual slicing</kw>
      <kw>Trim prefix</kw>
      <kw>Trim whitespace in place (two pointers)</kw>
      <kw>Truncate floating point number to integer</kw>
      <kw>Turn a character into a string</kw>
      <kw>Use `__FILE__` and `__LINE__` for trace points</kw>
      <kw>Use `const` to document and enforce read-only inputs</kw>
      <kw>Use `restrict` (C99) when you can prove non-aliasing</kw>
      <kw>Use `sizeof (type){0}` to get a type size without naming an object</kw>
      <kw>Use clock as random generator seed</kw>
      <kw>Use scansets in `sscanf` when you really do want it (bounded)</kw>
      <kw>Write to standard error stream</kw>
      <kw>X-macro tables: one list, many derived artifacts</kw>
      <kw>Xor integers</kw>
      <kw>Zero-initialize heap allocation with calloc</kw>
      <kw>Zero-initialize scalars and aggregates with `{0}` (and know what it really does)</kw>
    </keywords>

    <header id="hdr.idioms" name="Idioms">
      <summary><![CDATA[
<p>
Idioms are small, reusable C patterns for correctness, clarity, and portability. The entries below are aggregated
from multiple sources and merged into a single consistent format.
</p>
]]></summary>

    <function id="fn.idiom.id-0001" name="idiom: &quot;Advance before use&quot; scanning with assignment in the condition" kind="idiom">
      <signature>int c;</signature>
      <summary><![CDATA[<p>This compresses scanning code, and ensures the increment is not accidentally duplicated.</p>]]></summary>
      <examples>
        <example id="ex.id-0001.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int c;
while ((c = *p++) != 0) {
    /* use c */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0002" name="idiom: &quot;Append pointer&quot; pattern for building strings efficiently" kind="idiom">
      <signature>char out[256];</signature>
      <summary><![CDATA[<p>This keeps the write position explicit and avoids repeated <code>strlen</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0002.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
char out[256];
char *w = out;
char *e = out + sizeof out;

w += snprintf(w, (size_t)(e - w), "x=%d ", x);
w += snprintf(w, (size_t)(e - w), "y=%d", y);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0003" name="idiom: &quot;Close on success, free on failure&quot; with ownership transfer" kind="idiom">
      <signature>char *buf = malloc(n);</signature>
      <summary><![CDATA[<p>Setting the local to 0 after transfer prevents double-free in a shared cleanup block.</p>]]></summary>
      <examples>
        <example id="ex.id-0003.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
char *buf = malloc(n);
if (!buf) return -1;

*out = buf;   /* transfer ownership */
buf = 0;      /* prevent accidental free */
return 0;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0004" name="idiom: &quot;do while&quot; loop" kind="idiom">
      <signature>void repeat_action(int* value) {</signature>
      <summary><![CDATA[<p>Execute a block of code at least once and repeat while a condition remains true.</p>]]></summary>
      <notes>
        <note id="note.id-0004.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/78/do-while-loop">https://programming-idioms.org/idiom/78/do-while-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0004.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void repeat_action(int* value) {
    do {
        (*value)++;
    } while (*value < 10);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0005" name="idiom: &quot;Flexible array member&quot; for variable-sized structs (C99 feature)" kind="idiom">
      <signature>typedef struct c99lc_stack_char_fla {</signature>
      <summary><![CDATA[<p>Fixed-capacity character stack using flexible array member.<br>Provides a simple LIFO container for character data with allocation at creation time.</p><p>Compact bitset using uint8_t array with flexible array member.<br>Stores bits packed into bytes, providing efficient storage for boolean flags.<br>Bit indices are zero-based; bit i resides in items[i/8] at position (i%8).</p><p>This keeps header and payload contiguous and cache-friendly.</p>]]></summary>
      <examples>
        <example id="ex.id-0005.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
typedef struct c99lc_stack_char_fla {
    size_t capacity; /* maximum number of characters the stack can hold */
    size_t count; /* current number of characters in the stack */
    char items[]; /* flexible array member for character storage */
} c99lc_stack_char_fla;
]]></code>
        </example>
        <example id="ex.id-0005.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
typedef struct c99lc_bitset {
    size_t bytes_capacity; /* number of bytes allocated in items[] */
    size_t bits_capacity; /* maximum number of bits that can be stored */
    uint8_t items[]; /* flexible array member for bit storage */
} c99lc_bitset;
]]></code>
        </example>
        <example id="ex.id-0005.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
struct Msg {
    uint32_t len;
    unsigned char data[];   /* flexible array */
};

struct Msg *m = malloc(sizeof *m + payload_len);
m->len = payload_len;
memcpy(m->data, payload, payload_len);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0006" name="idiom: &quot;Inline constant struct&quot; as a default value without macros" kind="idiom">
      <signature>static const struct Limits default_limits = { .min = 0, .max = 100 };</signature>
      <summary><![CDATA[<p>You get a single source of truth and avoid repeating the initializer.</p>]]></summary>
      <examples>
        <example id="ex.id-0006.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
static const struct Limits default_limits = { .min = 0, .max = 100 };

struct Limits lim = default_limits;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0007" name="idiom: &quot;Length-limited string scan&quot; without copying" kind="idiom">
      <signature>size_t i = 0;</signature>
      <summary><![CDATA[<p>This is the safe pattern for possibly unterminated data.</p>]]></summary>
      <examples>
        <example id="ex.id-0007.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t i = 0;
for (; i < n && buf[i] != '\0'; ++i) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0008" name="idiom: &quot;Loop that guarantees at least one iteration&quot; with `do { } while (0)` (not just for macros)" kind="idiom">
      <signature>do {</signature>
      <summary><![CDATA[<p>It reads like structured early-exit without introducing <code>goto</code> yet.</p>]]></summary>
      <examples>
        <example id="ex.id-0008.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
do {
    if (!init()) break;
    if (!step()) break;
    finish();
} while (0);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0009" name="idiom: &quot;One definition of a flag set&quot; via an enum and bit masks" kind="idiom">
      <signature>enum {</signature>
      <summary><![CDATA[<p>This is a clean, debugger-friendly alternative to raw <code>#define</code> flags.</p>]]></summary>
      <examples>
        <example id="ex.id-0009.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
enum {
    F_READ  = 1u << 0,
    F_WRITE = 1u << 1,
    F_EXEC  = 1u << 2,
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0010" name="idiom: &quot;Optional output&quot; pointers with a simple guard" kind="idiom">
      <signature>if (out_value) *out_value = v;</signature>
      <summary><![CDATA[<p>This gives callers flexibility without multiplying function variants.</p>]]></summary>
      <examples>
        <example id="ex.id-0010.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (out_value) *out_value = v;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0011" name="idiom: &quot;Return value capture&quot; so you do not lose error information" kind="idiom">
      <signature>int rc = do_work();</signature>
      <summary><![CDATA[<p>Simple, but the important part is: never overwrite <code>rc</code> before you have consumed it.</p>]]></summary>
      <examples>
        <example id="ex.id-0011.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int rc = do_work();
if (rc) return rc;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0012" name="idiom: &quot;Sentinel at end&quot; arrays for tables of variable length" kind="idiom">
      <signature>struct KV { const char *k; int v; };</signature>
      <summary><![CDATA[<p>This avoids separately storing a count and is very readable for static tables.</p>]]></summary>
      <examples>
        <example id="ex.id-0012.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
struct KV { const char *k; int v; };

static const struct KV kvs[] = {
    { "alpha", 1 },
    { "beta", 2 },
    { 0, 0 },          /* sentinel */
};

for (const struct KV *p = kvs; p->k; ++p) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0013" name="idiom: &quot;Two-pointer&quot; walk for in-place filtering/compaction" kind="idiom">
      <signature>size_t w = 0;</signature>
      <summary><![CDATA[<p>This is the simplest correct in-place filter pattern.</p>]]></summary>
      <examples>
        <example id="ex.id-0013.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t w = 0;
for (size_t r = 0; r < n; ++r) {
    if (keep(xs[r])) xs[w++] = xs[r];
}
n = w;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0014" name="idiom: &quot;User data&quot; callbacks (poor man&apos;s closures)" kind="idiom">
      <signature>typedef int (*visit_fn)(void *user, const struct Node *n);</signature>
      <summary><![CDATA[<p>This is the idiomatic C way to carry context into callbacks.</p>]]></summary>
      <examples>
        <example id="ex.id-0014.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef int (*visit_fn)(void *user, const struct Node *n);

int walk(const struct Node *root, visit_fn fn, void *user);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0015" name="idiom: `enum` as compile-time integer constants" kind="idiom">
      <signature>enum { BUF_SZ = 4096, MAX_RETRIES = 5 };</signature>
      <summary><![CDATA[<p>Unlike macros, <code>enum</code> constants participate in the language and show up better in debuggers.</p>]]></summary>
      <examples>
        <example id="ex.id-0015.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
enum { BUF_SZ = 4096, MAX_RETRIES = 5 };
unsigned char buf[BUF_SZ];
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0016" name="idiom: `fgets` loop with newline trimming in one place" kind="idiom">
      <signature>while (fgets(line, sizeof line, fp)) {</signature>
      <summary><![CDATA[<p>This avoids repeated ad hoc newline logic.</p>]]></summary>
      <examples>
        <example id="ex.id-0016.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
while (fgets(line, sizeof line, fp)) {
    line[strcspn(line, "\n")] = '\0';
    /* use line */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0017" name="idiom: `memchr` as a fast &quot;find delimiter in bytes&quot;" kind="idiom">
      <signature>const unsigned char *q = memchr(p, &apos;\n&apos;, (size_t)(end - p));</signature>
      <summary><![CDATA[<p>Useful for scanning non-null-terminated buffers, unlike <code>strchr</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0017.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const unsigned char *q = memchr(p, '\n', (size_t)(end - p));
if (q) { /* found */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0018" name="idiom: `offsetof` from `&lt;stddef.h&gt;` for layout-aware code" kind="idiom">
      <signature>size_t off = offsetof(struct S, member);</signature>
      <summary><![CDATA[<p>This is standard and safer than home-grown offset macros.</p>]]></summary>
      <examples>
        <example id="ex.id-0018.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t off = offsetof(struct S, member);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0019" name="idiom: `realloc` with a temporary to avoid losing the original pointer on failure" kind="idiom">
      <signature>void *tmp = realloc(p, n);</signature>
      <summary><![CDATA[<p>This is one of the highest-value C habits you can adopt.</p>]]></summary>
      <examples>
        <example id="ex.id-0019.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void *tmp = realloc(p, n);
if (!tmp) { /* p still valid */ return -1; }
p = tmp;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0020" name="idiom: `snprintf` for bounded formatting and detecting truncation" kind="idiom">
      <signature>int m = snprintf(dst, dst_sz, &quot;%s/%s&quot;, a, b);</signature>
      <summary><![CDATA[<p>The return value is the size that would have been written, which makes it easy to size buffers.</p>]]></summary>
      <examples>
        <example id="ex.id-0020.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int m = snprintf(dst, dst_sz, "%s/%s", a, b);
if (m < 0 || (size_t)m >= dst_sz) { /* truncated or error */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0021" name="idiom: `sscanf` is tempting, but `strto*` with end pointers composes better" kind="idiom">
      <signature>char *end;</signature>
      <summary><![CDATA[<p>This avoids format-string corner cases and gives you precise control.</p>]]></summary>
      <examples>
        <example id="ex.id-0021.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
char *end;
long v = strtol(p, &end, 10);
if (end == p) { /* not a number */ }
p = end;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0022" name="idiom: `volatile` only for hardware/async boundaries, not for &quot;thread safety&quot;" kind="idiom">
      <signature>volatile uint32_t *reg = (volatile uint32_t *)0x40000000u;</signature>
      <summary><![CDATA[<p>This is a pattern you see in embedded C; the key is knowing that <code>volatile</code> is not a concurrency primitive.</p>]]></summary>
      <examples>
        <example id="ex.id-0022.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
volatile uint32_t *reg = (volatile uint32_t *)0x40000000u;
*reg = 1;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0023" name="idiom: Abort program execution with error condition" kind="idiom">
      <signature>void abort_with_error(int code) {</signature>
      <summary><![CDATA[<p>Terminate the program immediately with a non-zero exit status.</p>]]></summary>
      <notes>
        <note id="note.id-0023.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/198/abort-program-execution-with-error-condition">https://programming-idioms.org/idiom/198/abort-program-execution-with-error-condition</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0023.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void abort_with_error(int code) {
    exit(code);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0024" name="idiom: Add LSB-first digit arrays with carry" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_add_lsb_first(const unsigned char* a,</signature>
      <summary><![CDATA[<p>Adds two non-negative integers represented as base-10 digit arrays stored LSB-first.<br>Inputs:<br>a[0..a_size) and b[0..b_size) hold digits with a[0] the least significant digit.<br>Output:<br>Writes the sum into out[0..*out_size) also LSB-first.<br>On success returns C99LC_RESULT_SUCCESS and sets *out_size to the number of digits<br>written (never exceeding out_cap).<br>Failure cases:<br>- Any required pointer is NULL (a/b/out/out_size) while its size is &gt; 0.<br>- out_cap is insufficient for max(a_size, b_size) + 1 potential carry digit.<br>In these cases returns C99LC_RESULT_FAILED and leaves *out_size unmodified.<br>Notes:<br>- Digits must each be in the range [0,9]; behavior is undefined otherwise.<br>- Accepts zero-length operands (treated as value 0).<br>- This helper is allocation-free and intended for small / medium sized numbers<br>typical in coding challenge contexts.</p>]]></summary>
      <examples>
        <example id="ex.id-0024.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_add_lsb_first(const unsigned char* a,
    size_t a_size,
    const unsigned char* b,
    size_t b_size,
    unsigned char* out,
    size_t out_cap,
    size_t* out_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0025" name="idiom: Align up/down with power-of-two alignment (common, but easy to botch)" kind="idiom">
      <signature>size_t align_up(size_t x, size_t a) { return (x + (a - 1)) &amp; ~(a - 1); }</signature>
      <summary><![CDATA[<p>Only valid when <code>a</code> is a power of two.</p>]]></summary>
      <examples>
        <example id="ex.id-0025.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t align_up(size_t x, size_t a) { return (x + (a - 1)) & ~(a - 1); }
size_t align_dn(size_t x, size_t a) { return x & ~(a - 1); }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0026" name="idiom: Allocate 1M bytes" kind="idiom">
      <signature>void* allocate_one_megabyte(void) {</signature>
      <summary><![CDATA[<p>Allocate a buffer of one million bytes from the heap.</p>]]></summary>
      <notes>
        <note id="note.id-0026.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/88/allocate-1m-bytes">https://programming-idioms.org/idiom/88/allocate-1m-bytes</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0026.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void* allocate_one_megabyte(void) {
    return malloc(1000000);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0027" name="idiom: Allocate using the pointed-to type, not repeating the type name" kind="idiom">
      <signature>T *p = malloc(sizeof *p);</signature>
      <summary><![CDATA[<p>This survives type changes and reduces mismatch errors.</p>]]></summary>
      <examples>
        <example id="ex.id-0027.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
T *p = malloc(sizeof *p);
p = realloc(p, new_count * sizeof *p);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0028" name="idiom: Array difference using binary search lookup" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL size_t c99lc_array_int_diff(</signature>
      <summary><![CDATA[<p>Finds elements in source that are not present in sorted_lookup array.<br>Inputs:<br>- source[0..source_size): Array to search in.<br>- sorted_lookup[0..lookup_size): Sorted array of values to exclude.<br>- out[0..source_size): Destination buffer for difference elements.<br>Output:<br>- Writes elements from source not found in sorted_lookup into out.<br>- Returns the count of elements written to out.<br>Behavior:<br>- Returns 0 if source is NULL, source_size is 0, or sorted_lookup is NULL.<br>- sorted_lookup must be sorted in ascending order for correct results.<br>- Uses binary search for efficient lookup (O(log m) per element).<br>Example: source=[1,2,3,4], sorted_lookup=[2,4] -&gt; out=[1,3], returns 2.<br>Complexity: O(n log m) where n=source_size, m=lookup_size.</p>]]></summary>
      <examples>
        <example id="ex.id-0028.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL size_t c99lc_array_int_diff(
    const int* source, size_t source_size, const int* sorted_lookup, size_t lookup_size, int* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0029" name="idiom: Assert condition" kind="idiom">
      <signature>void check_consistency(int is_consistent) {</signature>
      <summary><![CDATA[<p>Verify that a condition holds true during program execution in debug builds.</p>]]></summary>
      <notes>
        <note id="note.id-0029.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/123/assert-condition">https://programming-idioms.org/idiom/123/assert-condition</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0029.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <assert.h>

void check_consistency(int is_consistent) {
    assert(is_consistent);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0030" name="idiom: Assign to string the japanese word ネコ" kind="idiom">
      <signature>const char* s = &quot;ネコ&quot;;</signature>
      <summary><![CDATA[<p>Initialize a UTF-8 string literal containing non-ASCII characters.</p>]]></summary>
      <notes>
        <note id="note.id-0030.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/24/assign-to-string-the-japanese-word">https://programming-idioms.org/idiom/24/assign-to-string-the-japanese-word</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0030.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* s = "ネコ";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0031" name="idiom: Assignment in condition to express &quot;read then test&quot;" kind="idiom">
      <signature>while ((n = fread(buf, 1, sizeof buf, fp)) != 0) { /* ... */ }</signature>
      <summary><![CDATA[<p>This is one of the clearest uses of assignment-in-condition: it matches the control flow of I/O.</p>]]></summary>
      <examples>
        <example id="ex.id-0031.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
while ((n = fread(buf, 1, sizeof buf, fp)) != 0) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0032" name="idiom: Binary digits to byte array" kind="idiom">
      <signature>unsigned char* binary_to_bytes(const char* bits, size_t* out_count) {</signature>
      <summary><![CDATA[<p>Convert a string of binary digits into a byte array.</p>]]></summary>
      <notes>
        <note id="note.id-0032.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/275/binary-digits-to-byte-array">https://programming-idioms.org/idiom/275/binary-digits-to-byte-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0032.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

unsigned char* binary_to_bytes(const char* bits, size_t* out_count) {
    size_t len = strlen(bits);
    size_t count = len / 8;
    unsigned char* bytes = (unsigned char*)calloc(count, 1);
    if (!bytes) {
        return NULL;
    }

    for (size_t i = 0; i < len; ++i) {
        if (bits[i] == '1') {
            bytes[i / 8] |= 1U << (7 - (i % 8));
        }
    }

    *out_count = count;
    return bytes;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0033" name="idiom: Binary search in sorted array" kind="idiom">
      <signature>bool binary_search(const int* array, size_t count, int value) {</signature>
      <summary><![CDATA[<p>Search a sorted integer array using binary search.</p>]]></summary>
      <notes>
        <note id="note.id-0033.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/62/find-substring-position">https://programming-idioms.org/idiom/62/find-substring-position</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0033.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool binary_search(const int* array, size_t count, int value) {
    size_t left = 0;
    size_t right = count;

    while (left < right) {
        size_t mid = left + (right - left) / 2;
        if (array[mid] == value) {
            return true;
        }
        if (array[mid] < value) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0034" name="idiom: Binomial coefficient &quot;n choose k&quot;" kind="idiom">
      <signature>unsigned long long binomial(unsigned int n, unsigned int k) {</signature>
      <summary><![CDATA[<p>Compute the binomial coefficient using an iterative integer method.</p>]]></summary>
      <notes>
        <note id="note.id-0034.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/67/binomial-coefficient-n-choose-k">https://programming-idioms.org/idiom/67/binomial-coefficient-n-choose-k</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0034.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned long long binomial(unsigned int n, unsigned int k) {
    if (k > n) {
        return 0;
    }
    if (k > n - k) {
        k = n - k;
    }

    unsigned long long result = 1;
    for (unsigned int i = 1; i <= k; ++i) {
        result = result * (n - k + i) / i;
    }
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0035" name="idiom: Bitset membership with unsigned shifts (avoid UB on signed)" kind="idiom">
      <signature>unsigned mask = 1u &lt;&lt; bit;</signature>
      <summary><![CDATA[<p>Use unsigned types for bit operations; left shift on signed can be undefined.</p>]]></summary>
      <examples>
        <example id="ex.id-0035.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned mask = 1u << bit;
if (flags & mask) { /* set */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0036" name="idiom: Boolean normalization with `!!`" kind="idiom">
      <signature>int ok = !!ptr;</signature>
      <summary><![CDATA[<p>Forces a clean 0/1 value, useful when you need strict boolean-like integers.</p>]]></summary>
      <examples>
        <example id="ex.id-0036.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int ok = !!ptr;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0037" name="idiom: Branchless &quot;is power of two&quot; (and exclude 0)" kind="idiom">
      <signature>int is_pow2(size_t x) { return x &amp;&amp; ((x &amp; (x - 1)) == 0); }</signature>
      <summary><![CDATA[<p>Tiny and used often in allocators and alignment code.</p>]]></summary>
      <examples>
        <example id="ex.id-0037.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int is_pow2(size_t x) { return x && ((x & (x - 1)) == 0); }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0038" name="idiom: Break outer loop" kind="idiom">
      <signature>bool find_negative(</signature>
      <summary><![CDATA[<p>Search a 2D integer matrix and stop immediately when a negative value is found.</p>]]></summary>
      <notes>
        <note id="note.id-0038.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/43/break-outer-loop">https://programming-idioms.org/idiom/43/break-outer-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0038.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdio.h>
#include <stdbool.h>

bool find_negative(
    const int* matrix,
    size_t rows,
    size_t cols,
    int* out_value
) {
    for (size_t r = 0; r < rows; ++r) {
        for (size_t c = 0; c < cols; ++c) {
            int value = matrix[r * cols + c];
            if (value < 0) {
                *out_value = value;
                return true;
            }
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0039" name="idiom: Byte extraction with masks and shifts (portable endianness-agnostic logic)" kind="idiom">
      <signature>unsigned byte0 = (x &gt;&gt; 0) &amp; 0xFFu;</signature>
      <summary><![CDATA[<p>This avoids aliasing and alignment pitfalls of pointer casts.</p>]]></summary>
      <examples>
        <example id="ex.id-0039.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned byte0 = (x >> 0) & 0xFFu;
unsigned byte1 = (x >> 8) & 0xFFu;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0040" name="idiom: Bytes to hex string" kind="idiom">
      <signature>char* bytes_to_hex(const unsigned char* bytes, size_t count) {</signature>
      <summary><![CDATA[<p>Convert a byte array into a hexadecimal string representation.</p>]]></summary>
      <notes>
        <note id="note.id-0040.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/175/bytes-to-hex-string">https://programming-idioms.org/idiom/175/bytes-to-hex-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0040.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

char* bytes_to_hex(const unsigned char* bytes, size_t count) {
    char* hex = (char*)malloc(count * 2 + 1);
    if (!hex) {
        return NULL;
    }

    for (size_t i = 0; i < count; ++i) {
        sprintf(hex + i * 2, "%02x", bytes[i]);
    }
    return hex;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0041" name="idiom: Calculate exponentiation of real numbers" kind="idiom">
      <signature>void print_powers(double a, double b, int n) {</signature>
      <summary><![CDATA[<p>Compute real-number exponentiation using the math library.</p>]]></summary>
      <notes>
        <note id="note.id-0041.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/305/calculate-exponentiation-of-real-numbers">https://programming-idioms.org/idiom/305/calculate-exponentiation-of-real-numbers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0041.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stdio.h>

void print_powers(double a, double b, int n) {
    printf("%f %f\n", pow(a, b), pow(a, n));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0042" name="idiom: Call an external C function" kind="idiom">
      <signature>void foo(double* values, int count);</signature>
      <summary><![CDATA[<p>Declare and call an external C function using a statically allocated array.</p>]]></summary>
      <notes>
        <note id="note.id-0042.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/190/call-an-external-c-function">https://programming-idioms.org/idiom/190/call-an-external-c-function</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0042.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void foo(double* values, int count);

void call_external(void) {
    double data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    foo(data, (int)(sizeof(data) / sizeof(data[0])));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0043" name="idiom: Character stack with flexible array member" kind="idiom">
      <signature>typedef struct c99lc_stack_char_fla {</signature>
      <summary><![CDATA[<p>Fixed-capacity character stack using flexible array member.<br>Provides a simple LIFO container for character data with allocation at creation time.</p><p>Creates a character stack with specified capacity.<br>Returns NULL on allocation failure or if capacity is 0.</p><p>Destroys a character stack and frees its memory.<br>Safe to call with NULL pointer.</p><p>Returns the current number of characters in the stack.<br>Returns 0 if stack is NULL.</p><p>Pushes a character onto the stack.<br>Returns true on success, false if stack is NULL or at capacity.</p><p>Pops a character from the stack and stores it in *out.<br>Returns true on success, false if stack is NULL, empty, or out is NULL.</p>]]></summary>
      <examples>
        <example id="ex.id-0043.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
typedef struct c99lc_stack_char_fla {
    size_t capacity; /* maximum number of characters the stack can hold */
    size_t count; /* current number of characters in the stack */
    char items[]; /* flexible array member for character storage */
} c99lc_stack_char_fla;
]]></code>
        </example>
        <example id="ex.id-0043.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_stack_char_fla* c99lc_stack_char_fla_create(size_t capacity);
]]></code>
        </example>
        <example id="ex.id-0043.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_stack_char_fla_destroy(c99lc_stack_char_fla* stack);
]]></code>
        </example>
        <example id="ex.id-0043.4" lang="c99">
          <title>Example 4</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL size_t c99lc_stack_char_fla_count(const c99lc_stack_char_fla* stack);
]]></code>
        </example>
        <example id="ex.id-0043.5" lang="c99">
          <title>Example 5</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_stack_char_fla_push(c99lc_stack_char_fla* stack, char c);
]]></code>
        </example>
        <example id="ex.id-0043.6" lang="c99">
          <title>Example 6</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_stack_char_fla_pop(c99lc_stack_char_fla* stack, char* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0044" name="idiom: Check for overflow before multiply/add (portable pattern)" kind="idiom">
      <signature>if (b != 0 &amp;&amp; a &gt; SIZE_MAX / b) return -1;   /* a*b would overflow */</signature>
      <summary><![CDATA[<p>This is the reliable, standard way (no compiler builtins).</p>]]></summary>
      <examples>
        <example id="ex.id-0044.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (b != 0 && a > SIZE_MAX / b) return -1;   /* a*b would overflow */

if (a > SIZE_MAX - b) return -1;            /* a+b would overflow */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0045" name="idiom: Check if any value in a list is larger than a limit" kind="idiom">
      <signature>bool any_greater_than(const int* array, size_t count, int limit) {</signature>
      <summary><![CDATA[<p>Scan an array and execute a callback if any element exceeds a given threshold.</p>]]></summary>
      <notes>
        <note id="note.id-0045.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/191/check-if-any-value-in-a-list-is-larger-than-a-limit">https://programming-idioms.org/idiom/191/check-if-any-value-in-a-list-is-larger-than-a-limit</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0045.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool any_greater_than(const int* array, size_t count, int limit) {
    for (size_t i = 0; i < count; ++i) {
        if (array[i] > limit) {
            return true;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0046" name="idiom: Check if file exists" kind="idiom">
      <signature>bool file_exists(const char* path) {</signature>
      <summary><![CDATA[<p>Check whether a file exists by attempting to open it.</p>]]></summary>
      <notes>
        <note id="note.id-0046.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/144/check-if-file-exists">https://programming-idioms.org/idiom/144/check-if-file-exists</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0046.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdbool.h>

bool file_exists(const char* path) {
    FILE* file = fopen(path, "r");
    if (!file) {
        return false;
    }
    fclose(file);
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0047" name="idiom: Check if integer addition will overflow" kind="idiom">
      <signature>bool addition_overflows(int a, int b) {</signature>
      <summary><![CDATA[<p>Detect whether adding two signed integers would overflow.</p>]]></summary>
      <notes>
        <note id="note.id-0047.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/85/check-if-integer-addition-will-overflow">https://programming-idioms.org/idiom/85/check-if-integer-addition-will-overflow</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0047.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <limits.h>

bool addition_overflows(int a, int b) {
    if (a > 0 && b > INT_MAX - a) {
        return true;
    }
    if (a < 0 && b < INT_MIN - a) {
        return true;
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0048" name="idiom: Check if integer is even" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_integers_is_even(int num);</signature>
      <summary><![CDATA[<p>Returns 1 if num is even, otherwise 0.<br>Handles negative and positive values consistently.</p>]]></summary>
      <examples>
        <example id="ex.id-0048.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_integers_is_even(int num);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0049" name="idiom: Check if list contains a value" kind="idiom">
      <signature>bool contains_int(const int* array, size_t count, int value) {</signature>
      <summary><![CDATA[<p>Perform a linear search to determine whether an integer value exists in an array.</p>]]></summary>
      <notes>
        <note id="note.id-0049.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/12/check-if-list-contains-a-value">https://programming-idioms.org/idiom/12/check-if-list-contains-a-value</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0049.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <stddef.h>

bool contains_int(const int* array, size_t count, int value) {
    for (size_t i = 0; i < count; ++i) {
        if (array[i] == value) {
            return true;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0050" name="idiom: Check if point is inside rectangle" kind="idiom">
      <signature>bool point_in_rect(</signature>
      <summary><![CDATA[<p>Determine whether a point lies inside or on the boundary of an axis-aligned rectangle.</p>]]></summary>
      <notes>
        <note id="note.id-0050.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle">https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0050.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

bool point_in_rect(
    double x1,
    double y1,
    double x2,
    double y2,
    double px,
    double py
) {
    return px >= x1 && px <= x2 && py >= y1 && py <= y2;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0051" name="idiom: Check if string contains a word" kind="idiom">
      <signature>bool contains_substring(const char* s, const char* word) {</signature>
      <summary><![CDATA[<p>Check whether a string contains another string as a substring.</p>]]></summary>
      <notes>
        <note id="note.id-0051.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/39/check-if-string-contains-a-word">https://programming-idioms.org/idiom/39/check-if-string-contains-a-word</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0051.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool contains_substring(const char* s, const char* word) {
    return strstr(s, word) != NULL;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0052" name="idiom: Check if string contains only digits" kind="idiom">
      <signature>bool is_numeric(const char* s) {</signature>
      <summary><![CDATA[<p>Determine whether a string consists exclusively of decimal digit characters.</p>]]></summary>
      <notes>
        <note id="note.id-0052.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/137/check-if-string-contains-only-digits">https://programming-idioms.org/idiom/137/check-if-string-contains-only-digits</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0052.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <ctype.h>

bool is_numeric(const char* s) {
    if (!*s) {
        return false;
    }

    while (*s) {
        if (!isdigit((unsigned char)*s)) {
            return false;
        }
        ++s;
    }
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0053" name="idiom: Check if string is blank" kind="idiom">
      <signature>bool is_blank(const char* s) {</signature>
      <summary><![CDATA[<p>Check whether a string is empty or contains only whitespace characters.</p>]]></summary>
      <notes>
        <note id="note.id-0053.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/110/check-if-string-is-blank">https://programming-idioms.org/idiom/110/check-if-string-is-blank</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0053.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <ctype.h>

bool is_blank(const char* s) {
    while (*s) {
        if (!isspace((unsigned char)*s)) {
            return false;
        }
        ++s;
    }
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0054" name="idiom: Check palindrome in byte array" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_array_u8_is_palindrome(const unsigned char* a,</signature>
      <summary><![CDATA[<p>Returns 1 if a[0..n) forms a palindrome when read from index 0 to n-1.<br>Behavior:<br>- Returns 1 for n == 0 or n == 1 (empty and single-element sequences are palindromes).<br>- Returns 0 if a is NULL and n &gt; 0.<br>Intended for digit arrays or general byte sequences.</p>]]></summary>
      <examples>
        <example id="ex.id-0054.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_array_u8_is_palindrome(const unsigned char* a,
    size_t n);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0055" name="idiom: Check string prefix" kind="idiom">
      <signature>bool starts_with(const char* s, const char* prefix) {</signature>
      <summary><![CDATA[<p>Check whether a string begins with a specified prefix.</p>]]></summary>
      <notes>
        <note id="note.id-0055.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/96/check-string-prefix">https://programming-idioms.org/idiom/96/check-string-prefix</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0055.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool starts_with(const char* s, const char* prefix) {
    size_t len = strlen(prefix);
    return strncmp(s, prefix, len) == 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0056" name="idiom: Clamp a value to a range" kind="idiom">
      <signature>int clamp_int(int value, int min, int max) {</signature>
      <summary><![CDATA[<p>Restrict an integer value to a minimum and maximum bound.</p>]]></summary>
      <notes>
        <note id="note.id-0056.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle">https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0056.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int clamp_int(int value, int min, int max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0057" name="idiom: Comment out a single line" kind="idiom">
      <signature>Comment out a single line</signature>
      <summary><![CDATA[<p>Add a comment line that is ignored by the compiler.</p>]]></summary>
      <notes>
        <note id="note.id-0057.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/299/comment-out-a-single-line">https://programming-idioms.org/idiom/299/comment-out-a-single-line</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0057.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
// This is a comment.
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0058" name="idiom: Compile-time array length (ARRAY_LEN/ARRAY_SIZE)" kind="idiom">
      <signature>Compile-time array length (ARRAY_LEN/ARRAY_SIZE)</signature>
      <summary><![CDATA[<p>Determine the number of elements in a statically allocated array.</p><p>Use it only when you truly have an array, not a pointer.</p>]]></summary>
      <notes>
        <note id="note.id-0058.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/117/get-list-size">https://programming-idioms.org/idiom/117/get-list-size</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0058.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
]]></code>
        </example>
        <example id="ex.id-0058.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#define ARRAY_LEN(a) (sizeof(a) / sizeof((a)[0]))
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0059" name="idiom: Compile-time assertion (typedef trick)" kind="idiom">
      <signature>STATIC_ASSERT(sizeof(int) &gt;= 4, int_must_be_32_bits);</signature>
      <summary><![CDATA[<p>Enforce invariants at compile time using C99 constructs.</p><p>C11 has <code>_Static_assert</code>, but this works in C99 and fails at compile time.</p>]]></summary>
      <notes>
        <note id="note.id-0059.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type">https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0059.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#define STATIC_ASSERT(cond, msg) typedef char static_assert_##msg[(cond) ? 1 : -1]

STATIC_ASSERT(sizeof(int) >= 4, int_must_be_32_bits);
]]></code>
        </example>
        <example id="ex.id-0059.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#define STATIC_ASSERT(expr) typedef char static_assertion[(expr) ? 1 : -1]
STATIC_ASSERT(sizeof(int) == 4);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0060" name="idiom: Complex number" kind="idiom">
      <signature>double complex compute_complex(void) {</signature>
      <summary><![CDATA[<p>Declare and manipulate a complex number using the C99 complex number support.</p>]]></summary>
      <notes>
        <note id="note.id-0060.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/77/complex-number">https://programming-idioms.org/idiom/77/complex-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0060.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <complex.h>

double complex compute_complex(void) {
    double complex z = -2.0 + 3.0 * I;
    return z * I;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0061" name="idiom: Compound literals for &quot;temporary objects with an address&quot;" kind="idiom">
      <signature>use_point(&amp;(struct Point){ .x = 1, .y = 2 });</signature>
      <summary><![CDATA[<p>Compound literals are standard C99. They are extremely handy for passing small structs/buffers without naming a variable.</p>]]></summary>
      <examples>
        <example id="ex.id-0061.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
use_point(&(struct Point){ .x = 1, .y = 2 });

memcpy(dst, (unsigned char[]){0xDE,0xAD,0xBE,0xEF}, 4);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0062" name="idiom: Compute GCD" kind="idiom">
      <signature>unsigned int gcd(unsigned int a, unsigned int b) {</signature>
      <summary><![CDATA[<p>Compute the greatest common divisor of two non-negative integers using the Euclidean algorithm.</p>]]></summary>
      <notes>
        <note id="note.id-0062.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/74/compute-gcd">https://programming-idioms.org/idiom/74/compute-gcd</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0062.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int gcd(unsigned int a, unsigned int b) {
    while (b != 0) {
        unsigned int r = a % b;
        a = b;
        b = r;
    }
    return a;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0063" name="idiom: Compute LCM" kind="idiom">
      <signature>unsigned int lcm(unsigned int a, unsigned int b) {</signature>
      <summary><![CDATA[<p>Compute the least common multiple of two non-negative integers using GCD.</p>]]></summary>
      <notes>
        <note id="note.id-0063.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/75/compute-lcm">https://programming-idioms.org/idiom/75/compute-lcm</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0063.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int lcm(unsigned int a, unsigned int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    return (a / gcd(a, b)) * b;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0064" name="idiom: Compute sum of integers" kind="idiom">
      <signature>int sum_ints(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Compute the sum of all elements in an integer array.</p>]]></summary>
      <notes>
        <note id="note.id-0064.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/54/compute-sum-of-integers">https://programming-idioms.org/idiom/54/compute-sum-of-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0064.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

int sum_ints(const int* array, size_t count) {
    int sum = 0;
    for (size_t i = 0; i < count; ++i) {
        sum += array[i];
    }
    return sum;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0065" name="idiom: Conditional assignment" kind="idiom">
      <signature>const char* choose_value(int condition) {</signature>
      <summary><![CDATA[<p>Assign one of two string values depending on a boolean condition.</p>]]></summary>
      <notes>
        <note id="note.id-0065.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/252/conditional-assignment">https://programming-idioms.org/idiom/252/conditional-assignment</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0065.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* choose_value(int condition) {
    return condition ? "a" : "b";
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0066" name="idiom: Container-of pattern (common, but not standard-library provided)" kind="idiom">
      <signature>Container-of pattern (common, but not standard-library provided)</signature>
      <summary><![CDATA[<p>Useful for intrusive data structures. It relies on well-known idioms, but it is also sharp: use only when you fully control types and lifetimes.</p>]]></summary>
      <examples>
        <example id="ex.id-0066.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define OFFSETOF(type, member) ((size_t)&(((type *)0)->member))
#define CONTAINER_OF(ptr, type, member) ((type *)((char *)(ptr) - OFFSETOF(type, member)))
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0067" name="idiom: Continue outer loop" kind="idiom">
      <signature>void print_unique(const int* a, size_t a_count, const int* b, size_t b_count) {</signature>
      <summary><![CDATA[<p>Iterate over one array and skip elements that appear in another array using a controlled loop structure.</p>]]></summary>
      <notes>
        <note id="note.id-0067.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/42/continue-outer-loop">https://programming-idioms.org/idiom/42/continue-outer-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0067.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdio.h>
#include <stdbool.h>

void print_unique(const int* a, size_t a_count, const int* b, size_t b_count) {
    for (size_t i = 0; i < a_count; ++i) {
        bool found = false;
        for (size_t j = 0; j < b_count; ++j) {
            if (a[i] == b[j]) {
                found = true;
                break;
            }
        }
        if (!found) {
            printf("%d\n", a[i]);
        }
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0068" name="idiom: Convert integer to floating point number" kind="idiom">
      <signature>double to_double(int value) {</signature>
      <summary><![CDATA[<p>Convert an integer value to a floating point value explicitly.</p>]]></summary>
      <notes>
        <note id="note.id-0068.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/79/convert-integer-to-floating-point-number">https://programming-idioms.org/idiom/79/convert-integer-to-floating-point-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0068.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
double to_double(int value) {
    return (double)value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0069" name="idiom: Convert integer to string" kind="idiom">
      <signature>void int_to_string(int value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert an integer value to its decimal string representation.</p>]]></summary>
      <notes>
        <note id="note.id-0069.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/55/convert-integer-to-string">https://programming-idioms.org/idiom/55/convert-integer-to-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0069.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void int_to_string(int value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%d", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0070" name="idiom: Convert real number to string with 2 decimal places" kind="idiom">
      <signature>void format_two_decimals(double value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Format a floating point value into a string with exactly two digits after the decimal point.</p>]]></summary>
      <notes>
        <note id="note.id-0070.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places">https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0070.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void format_two_decimals(double value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%.2f", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0071" name="idiom: Convert string to camelCase" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL size_t c99lc_string_to_camel_case(</signature>
      <summary><![CDATA[<p>Converts source string to camelCase by capitalizing letters after spaces and lowercasing others.<br>Writes result into buffer[0..buffer_capacity), returns number of characters written.<br>Only alphabetic characters are copied; spaces and other characters are skipped.<br>First character is always lowercase if it's alphabetic.<br>Parameters:<br>- source: null-terminated input string<br>- buffer: destination buffer for camelCase result<br>- buffer_capacity: maximum characters to write (excluding null terminator)<br>Returns: number of characters written, or 0 if source/buffer is NULL or buffer_capacity is 0.<br>Complexity: O(n) where n is strlen(source).</p>]]></summary>
      <examples>
        <example id="ex.id-0071.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL size_t c99lc_string_to_camel_case(
    const char* source, char* buffer, size_t buffer_capacity);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0072" name="idiom: Convert string to integer" kind="idiom">
      <signature>int string_to_int(const char* s) {</signature>
      <summary><![CDATA[<p>Convert a decimal string to an integer with basic error handling.</p>]]></summary>
      <notes>
        <note id="note.id-0072.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/22/convert-string-to-integer">https://programming-idioms.org/idiom/22/convert-string-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0072.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int string_to_int(const char* s) {
    return (int)strtol(s, NULL, 10);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0073" name="idiom: Convert string to integer, explicit base" kind="idiom">
      <signature>int string_to_int_base(const char* s, int base) {</signature>
      <summary><![CDATA[<p>Convert a string to an integer using an explicit numeric base.</p>]]></summary>
      <notes>
        <note id="note.id-0073.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/337/convert-string-to-integer-explicit-base">https://programming-idioms.org/idiom/337/convert-string-to-integer-explicit-base</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0073.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int string_to_int_base(const char* s, int base) {
    return (int)strtol(s, NULL, base);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0074" name="idiom: Copy string into buffer with capacity and null-terminate" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL int c99lc_helloworld_into(char* out, size_t out_cap);</signature>
      <summary><![CDATA[<p>Copies "Hello, World!" into out and null-terminates.<br>Returns bytes written excluding the terminator, or 0 if out is NULL or out_cap is 0.</p>]]></summary>
      <examples>
        <example id="ex.id-0074.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_helloworld_into(char* out, size_t out_cap);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0075" name="idiom: Count backwards" kind="idiom">
      <signature>void count_down(void) {</signature>
      <summary><![CDATA[<p>Print integers in descending order from a fixed starting value to zero.</p>]]></summary>
      <notes>
        <note id="note.id-0075.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/256/count-backwards">https://programming-idioms.org/idiom/256/count-backwards</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0075.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void count_down(void) {
    for (int i = 5; i >= 0; --i) {
        printf("%d\n", i);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0076" name="idiom: Count decimal digits in integer" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL size_t c99lc_integers_count_digits(int x);</signature>
      <summary><![CDATA[<p>Counts the number of decimal digits in x.<br>Example: 0 -&gt; 1, 90991 -&gt; 5; ignores the sign for negative inputs.</p>]]></summary>
      <examples>
        <example id="ex.id-0076.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL size_t c99lc_integers_count_digits(int x);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0077" name="idiom: Count set bits (popcount)" kind="idiom">
      <signature>unsigned int popcount(uint32_t value) {</signature>
      <summary><![CDATA[<p>Count the number of bits set to one in an unsigned integer.</p><p>Counts set bits (population count) in number treated as unsigned.<br>Works for all int values by casting to unsigned during the count.</p>]]></summary>
      <notes>
        <note id="note.id-0077.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation">https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0077.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdint.h>

unsigned int popcount(uint32_t value) {
    unsigned int count = 0;
    while (value) {
        value &= value - 1;
        ++count;
    }
    return count;
}
]]></code>
        </example>
        <example id="ex.id-0077.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_integers_count_set_bits(int number);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0078" name="idiom: Count substring occurrences" kind="idiom">
      <signature>size_t count_substrings(const char* s, const char* sub) {</signature>
      <summary><![CDATA[<p>Count the number of non-overlapping occurrences of a substring within a string.</p>]]></summary>
      <notes>
        <note id="note.id-0078.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/82/count-substring-occurrences">https://programming-idioms.org/idiom/82/count-substring-occurrences</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0078.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

size_t count_substrings(const char* s, const char* sub) {
    size_t count = 0;
    size_t len = strlen(sub);

    while ((s = strstr(s, sub)) != NULL) {
        ++count;
        s += len;
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0079" name="idiom: Count trailing zero bits" kind="idiom">
      <signature>size_t count_trailing_zeros(unsigned int value) {</signature>
      <summary><![CDATA[<p>Count the number of consecutive zero bits starting from the least significant bit.</p>]]></summary>
      <notes>
        <note id="note.id-0079.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/262/count-trailing-zero-bits">https://programming-idioms.org/idiom/262/count-trailing-zero-bits</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0079.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

size_t count_trailing_zeros(unsigned int value) {
    if (value == 0) {
        return sizeof(value) * 8;
    }

    size_t count = 0;
    while ((value & 1U) == 0) {
        value >>= 1;
        ++count;
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0080" name="idiom: Counted push with post-increment (your pattern) plus the &quot;guard&quot; form" kind="idiom">
      <signature>if (array_count &lt; ARRAY_CAP) {</signature>
      <summary><![CDATA[<p>The idiom is best when paired with an explicit bounds guard close by.</p>]]></summary>
      <examples>
        <example id="ex.id-0080.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (array_count < ARRAY_CAP) {
    array[array_count++] = value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0081" name="idiom: Create a 2-dimensional array" kind="idiom">
      <signature>void example_matrix(size_t rows, size_t cols) {</signature>
      <summary><![CDATA[<p>Declare a two-dimensional array of double values using C99 variable length arrays.</p>]]></summary>
      <notes>
        <note id="note.id-0081.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/26/create-a-2-dimensional-array">https://programming-idioms.org/idiom/26/create-a-2-dimensional-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0081.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void example_matrix(size_t rows, size_t cols) {
    double matrix[rows][cols];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0082" name="idiom: Create a 2D Point data structure" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Declare a lightweight structure representing a two-dimensional point using double-precision coordinates.</p>]]></summary>
      <notes>
        <note id="note.id-0082.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/5/create-a-2d-point-data-structure">https://programming-idioms.org/idiom/5/create-a-2d-point-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0082.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct {
    double x;
    double y;
} Point2D;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0083" name="idiom: Create a 3-dimensional array" kind="idiom">
      <signature>void example_tensor(size_t x, size_t y, size_t z) {</signature>
      <summary><![CDATA[<p>Declare a three-dimensional array of double values using C99 variable length arrays.</p>]]></summary>
      <notes>
        <note id="note.id-0083.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/27/create-a-3-dimensional-array">https://programming-idioms.org/idiom/27/create-a-3-dimensional-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0083.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void example_tensor(size_t x, size_t y, size_t z) {
    double tensor[x][y][z];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0084" name="idiom: Create a Binary Tree data structure" kind="idiom">
      <signature>typedef struct TreeNode {</signature>
      <summary><![CDATA[<p>Define a recursive structure for a binary tree node with left and right children.</p>]]></summary>
      <notes>
        <note id="note.id-0084.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/9/create-a-binary-tree-data-structure">https://programming-idioms.org/idiom/9/create-a-binary-tree-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0084.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct TreeNode {
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0085" name="idiom: Create a function" kind="idiom">
      <signature>int square_int(int value) {</signature>
      <summary><![CDATA[<p>Define a function that computes and returns the square of an integer value.</p>]]></summary>
      <notes>
        <note id="note.id-0085.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/4/create-a-function">https://programming-idioms.org/idiom/4/create-a-function</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0085.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int square_int(int value) {
    return value * value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0086" name="idiom: Create a map (associative array)" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Represent an associative mapping using an array of key-value structures, which is portable and explicit in C.</p>]]></summary>
      <notes>
        <note id="note.id-0086.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/8/create-a-map-associative-array">https://programming-idioms.org/idiom/8/create-a-map-associative-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0086.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct {
    const char* key;
    const char* value;
} KeyValue;

KeyValue map[] = {
    { "foo", "twenty" },
    { "bar", "three" }
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0087" name="idiom: Create a procedure" kind="idiom">
      <signature>void finish(void) {</signature>
      <summary><![CDATA[<p>Define a function that returns no value and performs side effects only.</p>]]></summary>
      <notes>
        <note id="note.id-0087.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/3/create-a-procedure">https://programming-idioms.org/idiom/3/create-a-procedure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0087.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void finish(void) {
    printf("My job here is done.\n");
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0088" name="idiom: Create a Tree data structure" kind="idiom">
      <signature>typedef struct TreeNode {</signature>
      <summary><![CDATA[<p>Define a recursive tree node structure where each node may have zero or more children and access to its siblings.</p>]]></summary>
      <notes>
        <note id="note.id-0088.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/17/create-a-tree-data-structure">https://programming-idioms.org/idiom/17/create-a-tree-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0088.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct TreeNode {
    int value;
    struct TreeNode* first_child;
    struct TreeNode* next_sibling;
} TreeNode;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0089" name="idiom: Create temp file" kind="idiom">
      <signature>FILE* create_temp_file(void) {</signature>
      <summary><![CDATA[<p>Create a temporary file using a secure, system-provided mechanism.</p>]]></summary>
      <notes>
        <note id="note.id-0089.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/138/create-temp-file">https://programming-idioms.org/idiom/138/create-temp-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0089.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

FILE* create_temp_file(void) {
    return tmpfile();
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0090" name="idiom: ctype functions: cast to unsigned char, and do not pass pointers" kind="idiom">
      <signature>if (isalpha((unsigned char)c)) { /* ... */ }</signature>
      <summary><![CDATA[<p><code>isalpha(0)</code> is defined to be false in the C locale, so <code>isalpha('\0')</code> is fine. Passing <code>NULL</code> is not "special"; it is just <code>0</code> as an integer constant, but treating it as a pointer concept is misleading. The real pitfall is <code>isalpha((signed char)0xE9)</code> which can be negative and is undefined unless you cast to <code>unsigned char</code> (or pass EOF).</p>]]></summary>
      <examples>
        <example id="ex.id-0090.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (isalpha((unsigned char)c)) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0091" name="idiom: Current executable name" kind="idiom">
      <signature>const char* executable_name(const char* argv0) {</signature>
      <summary><![CDATA[<p>Extract the executable name from the program invocation path.</p>]]></summary>
      <notes>
        <note id="note.id-0091.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/105/current-executable-name">https://programming-idioms.org/idiom/105/current-executable-name</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0091.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

const char* executable_name(const char* argv0) {
    const char* slash = strrchr(argv0, '/');
    return slash ? slash + 1 : argv0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0092" name="idiom: Custom allocation hooks via macros (malloc/free/realloc)" kind="idiom">
      <signature>Custom allocation hooks via macros (malloc/free/realloc)</signature>
      <summary><![CDATA[]]></summary>
      <examples>
        <example id="ex.id-0092.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#define C99_LEETCODE_MALLOC(ctx, size) ((void)(ctx), malloc(size))
]]></code>
        </example>
        <example id="ex.id-0092.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#define C99_LEETCODE_FREE(ctx, ptr) ((void)(ctx), free(ptr))
]]></code>
        </example>
        <example id="ex.id-0092.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
#define C99_LEETCODE_REALLOC(ctx, ptr, size) ((void)(ctx), realloc(ptr, size))
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0093" name="idiom: Date struct with year/month/day fields" kind="idiom">
      <signature>typedef struct c99lc_reasonable_date {</signature>
      <summary><![CDATA[<p>Date helpers</p>]]></summary>
      <examples>
        <example id="ex.id-0093.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct c99lc_reasonable_date {
    uint32_t year;
    uint32_t month;
    uint32_t day;
} c99lc_reasonable_date;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0094" name="idiom: Days in month with leap-year adjustment" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL uint32_t c99lc_date_days_in_month(uint32_t year, uint32_t month);</signature>
      <summary><![CDATA[<p>Returns the number of days in the given month of year.<br>Returns 0 if month is out of range 1..12.</p>]]></summary>
      <examples>
        <example id="ex.id-0094.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL uint32_t c99lc_date_days_in_month(uint32_t year, uint32_t month);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0095" name="idiom: Days since 1971-01-01 for date" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL uint32_t c99lc_date_days_since_1971(const c99lc_reasonable_date* d);</signature>
      <summary><![CDATA[<p>Counts days since 1971-01-01 for date d.<br>Returns 0 if d is NULL; assumes d contains a valid date.</p>]]></summary>
      <examples>
        <example id="ex.id-0095.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL uint32_t c99lc_date_days_since_1971(const c99lc_reasonable_date* d);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0096" name="idiom: Debug logging macro (compiled out in release)" kind="idiom">
      <signature>Debug logging macro (compiled out in release)</signature>
      <summary><![CDATA[<p>Emit debug-only log messages using conditional compilation.</p><p><code>((void)0)</code> keeps expression contexts well-typed.</p>]]></summary>
      <notes>
        <note id="note.id-0096.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/123/assert-condition">https://programming-idioms.org/idiom/123/assert-condition</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0096.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdio.h>

#ifdef DEBUG
#define DEBUG_LOG(fmt, ...) fprintf(stderr, fmt "\n", __VA_ARGS__)
#else
#define DEBUG_LOG(fmt, ...) ((void)0)
#endif
]]></code>
        </example>
        <example id="ex.id-0096.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#ifdef DEBUG
#define LOG(...) fprintf(stderr, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0097" name="idiom: Declare an enumeration" kind="idiom">
      <signature>typedef enum {</signature>
      <summary><![CDATA[<p>Define an enumeration type with a fixed set of named integer constants.</p>]]></summary>
      <notes>
        <note id="note.id-0097.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/122/declare-an-enumeration">https://programming-idioms.org/idiom/122/declare-an-enumeration</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0097.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef enum {
    SPADES,
    HEARTS,
    DIAMONDS,
    CLUBS
} Suit;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0098" name="idiom: Declare constant string" kind="idiom">
      <signature>const char* planet = &quot;Earth&quot;;</signature>
      <summary><![CDATA[<p>Declare a constant string literal.</p>]]></summary>
      <notes>
        <note id="note.id-0098.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/157/declare-constant-string">https://programming-idioms.org/idiom/157/declare-constant-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0098.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* planet = "Earth";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0099" name="idiom: Deduplicate sorted array in place" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL size_t c99lc_array_int_dedup_sorted(int* array, size_t size);</signature>
      <summary><![CDATA[<p>Removes consecutive duplicate elements from a sorted int array in place.<br>Input: array[0..size) must be sorted in ascending order.<br>Output: Unique elements are compacted at the beginning of array.<br>Returns: The new size (count of distinct elements).<br>Behavior:<br>- Returns 0 if array is NULL or size is 0.<br>- Returns 1 if size is 1.<br>- Does not modify elements beyond the returned size.<br>Example: [1,1,2,3,3,3,4] becomes [1,2,3,4] and returns 4.<br>Complexity: O(n) where n is size.</p>]]></summary>
      <examples>
        <example id="ex.id-0099.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL size_t c99lc_array_int_dedup_sorted(int* array, size_t size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0100" name="idiom: Delete file" kind="idiom">
      <signature>int delete_file(const char* path) {</signature>
      <summary><![CDATA[<p>Remove a file from the filesystem.</p>]]></summary>
      <notes>
        <note id="note.id-0100.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/155/delete-file">https://programming-idioms.org/idiom/155/delete-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0100.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int delete_file(const char* path) {
    return remove(path);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0101" name="idiom: Depth-first traversal in a graph" kind="idiom">
      <signature>typedef struct Node {</signature>
      <summary><![CDATA[<p>Perform a depth-first traversal over a graph represented by adjacency lists.</p>]]></summary>
      <notes>
        <note id="note.id-0101.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/130/depth-first-traversal-in-a-graph">https://programming-idioms.org/idiom/130/depth-first-traversal-in-a-graph</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0101.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

typedef struct Node {
    size_t index;
    struct Node** neighbors;
    size_t neighbor_count;
} Node;

void dfs(Node* node, int* visited) {
    if (visited[node->index]) {
        return;
    }

    visited[node->index] = 1;
    for (size_t i = 0; i < node->neighbor_count; ++i) {
        dfs(node->neighbors[i], visited);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0102" name="idiom: Designated initializers to document intent and avoid field-order coupling" kind="idiom">
      <signature>struct Config cfg = {</signature>
      <summary><![CDATA[<p>This makes changes to <code>struct Config</code> safer because you are not relying on declaration order.</p>]]></summary>
      <examples>
        <example id="ex.id-0102.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
struct Config cfg = {
    .timeout_ms = 250,
    .retries = 3,
    .path = "/tmp/app.sock",
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0103" name="idiom: Detect zero digit in base-10 representation" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_integers_has_zero_digit(int num);</signature>
      <summary><![CDATA[<p>Returns 1 if the base-10 representation of num contains at least one '0' digit, else 0.<br>Behavior:<br>- 0 returns 1 (its only digit is zero).<br>- Negative values are examined by their absolute value.<br>Examples: 101 -&gt; 1, 123 -&gt; 0, 909 -&gt; 1.<br>Complexity: O(d) where d is the number of decimal digits.</p>]]></summary>
      <examples>
        <example id="ex.id-0103.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_integers_has_zero_digit(int num);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0104" name="idiom: Dynamic int array with capacity growth" kind="idiom">
      <signature>typedef struct c99lc_leaf_values {</signature>
      <summary><![CDATA[<p>Lightweight dynamic array for ints</p><p>Allocates a growable array of int with initial_capacity (1 if 0).<br>Returns NULL on allocation failure.</p><p>Appends item to the end of the vector, growing capacity as needed.<br>If reallocation fails the push is dropped.</p><p>Frees the vector and its storage.<br>Safe to call with NULL.</p>]]></summary>
      <examples>
        <example id="ex.id-0104.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
typedef struct c99lc_leaf_values {
    size_t size;
    size_t capacity;
    int* items;
} c99lc_leaf_values;
]]></code>
        </example>
        <example id="ex.id-0104.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_leaf_values* c99lc_leaf_values_create(size_t initial_capacity);
]]></code>
        </example>
        <example id="ex.id-0104.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_leaf_values_push(c99lc_leaf_values* lv, int item);
]]></code>
        </example>
        <example id="ex.id-0104.4" lang="c99">
          <title>Example 4</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_leaf_values_destroy(c99lc_leaf_values* lv);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0105" name="idiom: Echo program implementation" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Print all command-line arguments except the program name, separated by spaces.</p>]]></summary>
      <notes>
        <note id="note.id-0105.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/71/echo-program-implementation">https://programming-idioms.org/idiom/71/echo-program-implementation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0105.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(int argc, char* argv[]) {
    for (int i = 1; i < argc; ++i) {
        printf("%s", argv[i]);
        if (i + 1 < argc) {
            printf(" ");
        }
    }
    printf("\n");
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0106" name="idiom: Execute procedures depending on options" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Execute different procedures based on parsed command-line options.</p>]]></summary>
      <notes>
        <note id="note.id-0106.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/162/execute-procedures-depending-on-options">https://programming-idioms.org/idiom/162/execute-procedures-depending-on-options</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0106.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>

int main(int argc, char* argv[]) {
    int opt;
    while ((opt = getopt(argc, argv, "bf")) != -1) {
        if (opt == 'b') {
            bat();
        } else if (opt == 'f') {
            fox();
        }
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0107" name="idiom: Exit program cleanly (EXIT_SUCCESS)" kind="idiom">
      <signature>void exit_success(void) {</signature>
      <summary><![CDATA[<p>Terminate the program and indicate successful completion to the operating system.</p><p>Terminate program execution immediately and report successful completion.</p>]]></summary>
      <notes>
        <note id="note.id-0107.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/186/exit-program-cleanly">https://programming-idioms.org/idiom/186/exit-program-cleanly</a></p>]]></description>
        </note>
        <note id="note.id-0107.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/87/stop-program">https://programming-idioms.org/idiom/87/stop-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0107.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

void exit_success(void) {
    exit(EXIT_SUCCESS);
}
]]></code>
        </example>
        <example id="ex.id-0107.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stdlib.h>

void stop_program(void) {
    exit(EXIT_SUCCESS);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0108" name="idiom: Extract a substring" kind="idiom">
      <signature>char* substring(const char* s, size_t start, size_t end) {</signature>
      <summary><![CDATA[<p>Extract a substring from a string using byte indices, allocating a new null-terminated string.</p>]]></summary>
      <notes>
        <note id="note.id-0108.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/38/extract-a-substring">https://programming-idioms.org/idiom/38/extract-a-substring</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0108.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* substring(const char* s, size_t start, size_t end) {
    if (end <= start) {
        return NULL;
    }

    size_t len = end - start;
    char* result = (char*)malloc(len + 1);
    if (!result) {
        return NULL;
    }

    memcpy(result, s + start, len);
    result[len] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0109" name="idiom: Extract file content to a string" kind="idiom">
      <signature>char* read_file_to_string(const char* path) {</signature>
      <summary><![CDATA[<p>Read the entire contents of a file into a dynamically allocated string using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0109.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/58/extract-file-content-to-a-string">https://programming-idioms.org/idiom/58/extract-file-content-to-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0109.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>

char* read_file_to_string(const char* path) {
    FILE* file = fopen(path, "rb");
    if (!file) {
        return NULL;
    }

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);

    char* buffer = (char*)malloc((size_t)size + 1);
    if (!buffer) {
        fclose(file);
        return NULL;
    }

    fread(buffer, 1, (size_t)size, file);
    buffer[size] = '\0';

    fclose(file);
    return buffer;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0110" name="idiom: Find substring position" kind="idiom">
      <signature>int find_substring_index(const char* s, const char* sub) {</signature>
      <summary><![CDATA[<p>Find the byte index of the first occurrence of a substring within a string.</p>]]></summary>
      <notes>
        <note id="note.id-0110.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/62/find-substring-position">https://programming-idioms.org/idiom/62/find-substring-position</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0110.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

int find_substring_index(const char* s, const char* sub) {
    const char* pos = strstr(s, sub);
    if (!pos) {
        return -1;
    }
    return (int)(pos - s);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0111" name="idiom: Fixed-capacity positive decimal digit buffer (LSB-first)" kind="idiom">
      <signature>typedef struct c99lc_digits_positive_int_buffer {</signature>
      <summary><![CDATA[<p>Fixed-capacity positive decimal digit buffer.<br>Represents a non-negative integer in base-10 with digits stored least-significant first.<br>Intended for problems like LeetCode 989 (Add to Array-Form of Integer) to avoid dynamic<br>allocation in intermediate steps.<br>Invariants:<br>- size in [1, capacity] when representing a value.<br>- digits[i] in [0,9].</p><p>Initializes buf with external storage digits[0..capacity).<br>After init the represented value is 0 (size==1, digits[0]==0).<br>Returns C99LC_RESULT_FAILED if arguments invalid (buf==NULL, digits==NULL, capacity==0).</p><p>Parses non-negative integer k into buf (overwriting previous contents).<br>Requires k&gt;=0 and buf previously initialized. Returns C99LC_RESULT_FAILED on NULL buf or<br>if capacity insufficient (when k has more digits than capacity).</p><p>Loads digits from a big-endian array src[0..n) (as typically provided by LeetCode where<br>the first element is the most significant digit). Fails if n==0, buf NULL, or n&gt;capacity.</p><p>Adds two buffers a and b storing LSB-first digits and writes result into out.<br>Fails if out capacity &lt; max(a.size,b.size)+1 or any pointer NULL. Out may alias neither a nor b.</p><p>Writes big-endian int array of the number in buf into dst[0..dst_cap). On success sets *out_size.<br>Fails if dst_cap &lt; buf-&gt;size. dst and buf must be non-null.</p>]]></summary>
      <examples>
        <example id="ex.id-0111.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
typedef struct c99lc_digits_positive_int_buffer {
    size_t size; /* number of used digits */
    size_t capacity; /* total available slots in digits[] */
    unsigned char* digits; /* LSB-first digit storage */
} c99lc_digits_positive_int_buffer;
]]></code>
        </example>
        <example id="ex.id-0111.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_positive_int_init(
    c99lc_digits_positive_int_buffer* buf, unsigned char* digits_mem, size_t capacity);
]]></code>
        </example>
        <example id="ex.id-0111.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_positive_int_from_int(
    c99lc_digits_positive_int_buffer* buf, int k);
]]></code>
        </example>
        <example id="ex.id-0111.4" lang="c99">
          <title>Example 4</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_positive_int_from_big_endian_array(
    c99lc_digits_positive_int_buffer* buf, const int* src, size_t n);
]]></code>
        </example>
        <example id="ex.id-0111.5" lang="c99">
          <title>Example 5</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_positive_int_add(
    const c99lc_digits_positive_int_buffer* a,
    const c99lc_digits_positive_int_buffer* b,
    c99lc_digits_positive_int_buffer* out);
]]></code>
        </example>
        <example id="ex.id-0111.6" lang="c99">
          <title>Example 6</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_digits_positive_int_to_big_endian_int_array(
    const c99lc_digits_positive_int_buffer* buf, int* dst, size_t dst_cap, size_t* out_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0112" name="idiom: Flexible &quot;build up an initializer&quot; with trailing commas" kind="idiom">
      <signature>int xs[] = {</signature>
      <summary><![CDATA[<p>C allows the trailing comma. It reduces diffs when adding and removing entries.</p>]]></summary>
      <examples>
        <example id="ex.id-0112.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int xs[] = {
    1,
    2,
    3,
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0113" name="idiom: Format a number with grouped thousands" kind="idiom">
      <signature>void print_grouped(int value) {</signature>
      <summary><![CDATA[<p>Format an integer with thousands separators using the current locale.</p>]]></summary>
      <notes>
        <note id="note.id-0113.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/173/format-a-number-with-grouped-thousands">https://programming-idioms.org/idiom/173/format-a-number-with-grouped-thousands</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0113.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <locale.h>

void print_grouped(int value) {
    setlocale(LC_ALL, "");
    printf("%'d\n", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0114" name="idiom: Format decimal number" kind="idiom">
      <signature>void format_percentage(double value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert a fractional value in the range [0,1] into a percentage string with one decimal digit.</p>]]></summary>
      <notes>
        <note id="note.id-0114.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/65/format-decimal-number">https://programming-idioms.org/idiom/65/format-decimal-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0114.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void format_percentage(double value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%.1f%%", value * 100.0);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0115" name="idiom: Formula with arrays" kind="idiom">
      <signature>void compute_formula(</signature>
      <summary><![CDATA[<p>Apply an element-wise mathematical formula to multiple arrays of equal length.</p>]]></summary>
      <notes>
        <note id="note.id-0115.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/208/formula-with-arrays">https://programming-idioms.org/idiom/208/formula-with-arrays</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0115.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stddef.h>

void compute_formula(
    double* a,
    const double* b,
    const double* c,
    const double* d,
    size_t count,
    double e
) {
    for (size_t i = 0; i < count; ++i) {
        a[i] = e * (a[i] + b[i] * c[i] + cos(d[i]));
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0116" name="idiom: Free and null a pointer" kind="idiom">
      <signature>void free_and_null(void** ptr) {</signature>
      <summary><![CDATA[<p>Release heap memory and clear the pointer to avoid accidental reuse.</p>]]></summary>
      <notes>
        <note id="note.id-0116.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/87/stop-program">https://programming-idioms.org/idiom/87/stop-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0116.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void free_and_null(void** ptr) {
    if (*ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0117" name="idiom: Get an environment variable" kind="idiom">
      <signature>const char* get_env_or_default(const char* name, const char* fallback) {</signature>
      <summary><![CDATA[<p>Read an environment variable and fall back to a default value if it is not set.</p>]]></summary>
      <notes>
        <note id="note.id-0117.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/205/get-an-environment-variable">https://programming-idioms.org/idiom/205/get-an-environment-variable</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0117.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

const char* get_env_or_default(const char* name, const char* fallback) {
    const char* value = getenv(name);
    return value ? value : fallback;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0118" name="idiom: Get current date" kind="idiom">
      <signature>time_t now(void) {</signature>
      <summary><![CDATA[<p>Retrieve the current date and time using the standard C time type.</p>]]></summary>
      <notes>
        <note id="note.id-0118.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/61/get-current-date">https://programming-idioms.org/idiom/61/get-current-date</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0118.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

time_t now(void) {
    return time(NULL);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0119" name="idiom: Get file size" kind="idiom">
      <signature>long file_size(const char* path) {</signature>
      <summary><![CDATA[<p>Determine the size of a file in bytes using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0119.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/95/get-file-size">https://programming-idioms.org/idiom/95/get-file-size</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0119.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

long file_size(const char* path) {
    FILE* file = fopen(path, "rb");
    if (!file) {
        return -1;
    }

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fclose(file);
    return size;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0120" name="idiom: Get folder containing current program" kind="idiom">
      <signature>char* executable_directory(void) {</signature>
      <summary><![CDATA[<p>Determine the directory containing the currently executing program on Unix-like systems.</p>]]></summary>
      <notes>
        <note id="note.id-0120.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/107/get-folder-containing-current-program">https://programming-idioms.org/idiom/107/get-folder-containing-current-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0120.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>
#include <limits.h>
#include <libgen.h>

char* executable_directory(void) {
    char path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (len < 0) {
        return NULL;
    }
    path[len] = '\0';
    return dirname(path);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0121" name="idiom: Get program working directory" kind="idiom">
      <signature>char* working_directory(void) {</signature>
      <summary><![CDATA[<p>Retrieve the current working directory path.</p>]]></summary>
      <notes>
        <note id="note.id-0121.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/106/get-program-working-directory">https://programming-idioms.org/idiom/106/get-program-working-directory</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0121.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>

char* working_directory(void) {
    return getcwd(NULL, 0);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0122" name="idiom: Handle invalid argument" kind="idiom">
      <signature>bool square_checked(int value, int* result) {</signature>
      <summary><![CDATA[<p>Validate a function argument and report failure using an explicit status code.</p>]]></summary>
      <notes>
        <note id="note.id-0122.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/89/handle-invalid-argument">https://programming-idioms.org/idiom/89/handle-invalid-argument</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0122.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

bool square_checked(int value, int* result) {
    if (value > 46340 || value < -46340) {
        return false;
    }
    *result = value * value;
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0123" name="idiom: Hex dump loop that is careful about signedness" kind="idiom">
      <signature>const unsigned char *b = buf;</signature>
      <summary><![CDATA[<p>Casting avoids <code>char</code> sign surprises.</p>]]></summary>
      <examples>
        <example id="ex.id-0123.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const unsigned char *b = buf;
for (size_t i = 0; i < n; ++i) printf("%02X", (unsigned)b[i]);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0124" name="idiom: Hex string to byte array" kind="idiom">
      <signature>unsigned char* hex_to_bytes(const char* hex, size_t* out_count) {</signature>
      <summary><![CDATA[<p>Convert a hexadecimal string into a byte array.</p>]]></summary>
      <notes>
        <note id="note.id-0124.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/176/hex-string-to-byte-array">https://programming-idioms.org/idiom/176/hex-string-to-byte-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0124.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <ctype.h>

unsigned char* hex_to_bytes(const char* hex, size_t* out_count) {
    size_t len = strlen(hex) / 2;
    unsigned char* bytes = (unsigned char*)malloc(len);
    if (!bytes) {
        return NULL;
    }

    for (size_t i = 0; i < len; ++i) {
        unsigned int value;
        sscanf(hex + i * 2, "%2x", &value);
        bytes[i] = (unsigned char)value;
    }

    *out_count = len;
    return bytes;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0125" name="idiom: Hexadecimal digits of an integer" kind="idiom">
      <signature>void int_to_hex(unsigned int value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert an integer value to its hexadecimal string representation.</p>]]></summary>
      <notes>
        <note id="note.id-0125.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/142/hexadecimal-digits-of-an-integer">https://programming-idioms.org/idiom/142/hexadecimal-digits-of-an-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0125.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void int_to_hex(unsigned int value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%x", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0126" name="idiom: Increment decimal digit array in place" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL void c99lc_digits_increment(unsigned char* digits, size_t digits_size);</signature>
      <summary><![CDATA[<p>Increments a big-endian decimal digit array in place by 1.<br>Digits must be in [0,9]; carry ripples from the least significant end.</p>]]></summary>
      <examples>
        <example id="ex.id-0126.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_digits_increment(unsigned char* digits, size_t digits_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0127" name="idiom: Integer exponentiation by squaring" kind="idiom">
      <signature>unsigned int int_pow(unsigned int base, unsigned int exp) {</signature>
      <summary><![CDATA[<p>Compute the power of a non-negative integer base raised to a non-negative integer exponent using exponentiation by squaring.</p>]]></summary>
      <notes>
        <note id="note.id-0127.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/32/integer-exponentiation-by-squaring">https://programming-idioms.org/idiom/32/integer-exponentiation-by-squaring</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0127.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int int_pow(unsigned int base, unsigned int exp) {
    if (exp == 0) {
        return 1;
    }
    if ((exp & 1U) == 0) {
        return int_pow(base * base, exp / 2);
    }
    return base * int_pow(base * base, (exp - 1) / 2);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0128" name="idiom: Interleave halves of array" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL void c99lc_array_int_interleave_halves(int* dst, const int* src, size_t n);</signature>
      <summary><![CDATA[<p>Interleave halves of an int array.<br>Input:  src holds 2*n ints as [x1, x2, ..., xn, y1, y2, ..., yn].<br>Output: dst becomes [x1, y1, x2, y2, ..., xn, yn].<br>No allocation; no-op if pointers are NULL or n==0.</p>]]></summary>
      <examples>
        <example id="ex.id-0128.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_array_int_interleave_halves(int* dst, const int* src, size_t n);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0129" name="idiom: Iterate over list indexes and values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Iterate over an array while accessing both index and value in a type-safe and explicit manner.</p>]]></summary>
      <notes>
        <note id="note.id-0129.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values">https://programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0129.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

typedef struct {
    const char* name;
} Item;

const char* item_to_string(Item item) {
    return item.name;
}

void print_items(const Item* items, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        printf("Item %zu = %s\n", i, item_to_string(items[i]));
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0130" name="idiom: Iterate over list values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Iterate over each element of an array and apply a processing function to each element, with all required context explicitly defined.</p>]]></summary>
      <notes>
        <note id="note.id-0130.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/6/iterate-over-list-values">https://programming-idioms.org/idiom/6/iterate-over-list-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0130.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

typedef struct {
    int id;
} Item;

void process_item(Item* item) {
    item->id += 1;
}

void process_items(Item* items, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        process_item(&items[i]);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0131" name="idiom: Join a list of strings" kind="idiom">
      <signature>void join_strings(</signature>
      <summary><![CDATA[<p>Concatenate an array of strings into a single buffer using a fixed separator.</p>]]></summary>
      <notes>
        <note id="note.id-0131.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/53/join-a-list-of-strings">https://programming-idioms.org/idiom/53/join-a-list-of-strings</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0131.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

void join_strings(
    const char** parts,
    size_t count,
    const char* separator,
    char* output,
    size_t output_size
) {
    output[0] = '\0';

    for (size_t i = 0; i < count; ++i) {
        if (i > 0) {
            strncat(output, separator, output_size - strlen(output) - 1);
        }
        strncat(output, parts[i], output_size - strlen(output) - 1);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0132" name="idiom: Join integer from LSB-first digit array" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL int c99lc_integers_join_digits_from_array(const unsigned char* src_array,</signature>
      <summary><![CDATA[<p>Reconstructs an integer from digits stored LSB-first in src_array.<br>Returns 0 if src_array is NULL or src_array_size is 0.</p>]]></summary>
      <examples>
        <example id="ex.id-0132.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_integers_join_digits_from_array(const unsigned char* src_array,
    size_t src_array_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0133" name="idiom: Last element of list" kind="idiom">
      <signature>int last_element(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Retrieve the last element of a non-empty array.</p>]]></summary>
      <notes>
        <note id="note.id-0133.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/165/last-element-of-list">https://programming-idioms.org/idiom/165/last-element-of-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0133.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int last_element(const int* array, size_t count) {
    return array[count - 1];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0134" name="idiom: Launch other program" kind="idiom">
      <signature>int launch_program(const char* command) {</signature>
      <summary><![CDATA[<p>Execute another program using the system shell.</p>]]></summary>
      <notes>
        <note id="note.id-0134.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/111/launch-other-program">https://programming-idioms.org/idiom/111/launch-other-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0134.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int launch_program(const char* command) {
    return system(command);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0135" name="idiom: Leap year check (Gregorian 4/100/400 rule)" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL bool c99lc_date_is_leap_year(uint32_t year);</signature>
      <summary><![CDATA[<p>Returns true if year is a Gregorian leap year.<br>Applies the 4, 100, 400 rule.</p>]]></summary>
      <examples>
        <example id="ex.id-0135.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_date_is_leap_year(uint32_t year);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0136" name="idiom: List files in directory" kind="idiom">
      <signature>int list_directory(const char* path) {</signature>
      <summary><![CDATA[<p>List entries in a directory without recursion.</p>]]></summary>
      <notes>
        <note id="note.id-0136.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/180/list-files-in-directory">https://programming-idioms.org/idiom/180/list-files-in-directory</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0136.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <dirent.h>

int list_directory(const char* path) {
    DIR* dir = opendir(path);
    if (!dir) {
        return -1;
    }

    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }

    closedir(dir);
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0137" name="idiom: Local static for expensive one-time setup inside a function" kind="idiom">
      <signature>const char *lookup(int k) {</signature>
      <summary><![CDATA[<p>This avoids repeated initialization and keeps the table close to the code that uses it.</p>]]></summary>
      <examples>
        <example id="ex.id-0137.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char *lookup(int k) {
    static const char *tbl[] = { "zero", "one", "two" };
    return (k >= 0 && k < (int)(sizeof tbl / sizeof tbl[0])) ? tbl[k] : "unknown";
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0138" name="idiom: Make an infinite loop" kind="idiom">
      <signature>for (;;) {</signature>
      <summary><![CDATA[<p>Execute a loop without a termination condition.</p>]]></summary>
      <notes>
        <note id="note.id-0138.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/50/make-an-infinite-loop">https://programming-idioms.org/idiom/50/make-an-infinite-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0138.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (;;) {
    /* loop forever */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0139" name="idiom: Measure elapsed CPU time" kind="idiom">
      <signature>double elapsed_seconds(clock_t start, clock_t end) {</signature>
      <summary><![CDATA[<p>Measure elapsed processor time using the standard C clock.</p>]]></summary>
      <notes>
        <note id="note.id-0139.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/61/get-current-date">https://programming-idioms.org/idiom/61/get-current-date</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0139.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

double elapsed_seconds(clock_t start, clock_t end) {
    return (double)(end - start) / CLOCKS_PER_SEC;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0140" name="idiom: Memset a struct via its address, not by casting" kind="idiom">
      <signature>memset(&amp;s, 0, sizeof s);</signature>
      <summary><![CDATA[<p>Straightforward, but still the correct idiom when <code>{0}</code> is not possible.</p>]]></summary>
      <examples>
        <example id="ex.id-0140.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
memset(&s, 0, sizeof s);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0141" name="idiom: Multi-line string literal" kind="idiom">
      <signature>const char* s =</signature>
      <summary><![CDATA[<p>Assign a string literal composed of multiple lines using implicit string literal concatenation.</p>]]></summary>
      <notes>
        <note id="note.id-0141.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/48/multi-line-string-literal">https://programming-idioms.org/idiom/48/multi-line-string-literal</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0141.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* s =
    "Huey\n"
    "Dewey\n"
    "Louie\n";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0142" name="idiom: Multiple return values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Return multiple values from a function by grouping them in a structure.</p>]]></summary>
      <notes>
        <note id="note.id-0142.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/126/multiple-return-values">https://programming-idioms.org/idiom/126/multiple-return-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0142.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

typedef struct {
    const char* text;
    bool ok;
} Result;

Result make_result(void) {
    Result r = { "Hello", true };
    return r;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0143" name="idiom: Multiply all the elements of a list" kind="idiom">
      <signature>void scale_ints(int* array, size_t count, int factor) {</signature>
      <summary><![CDATA[<p>Multiply each element of an integer array by a constant factor.</p>]]></summary>
      <notes>
        <note id="note.id-0143.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list">https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0143.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

void scale_ints(int* array, size_t count, int factor) {
    for (size_t i = 0; i < count; ++i) {
        array[i] *= factor;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0144" name="idiom: Number of bytes of a type" kind="idiom">
      <signature>size_t bytes_of(int value) {</signature>
      <summary><![CDATA[<p>Determine the number of bytes occupied by a variable.</p>]]></summary>
      <notes>
        <note id="note.id-0144.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type">https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0144.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

size_t bytes_of(int value) {
    return sizeof(value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0145" name="idiom: Packed bitset with test/set/clear" kind="idiom">
      <signature>typedef struct c99lc_bitset {</signature>
      <summary><![CDATA[<p>Compact bitset using uint8_t array with flexible array member.<br>Stores bits packed into bytes, providing efficient storage for boolean flags.<br>Bit indices are zero-based; bit i resides in items[i/8] at position (i%8).</p><p>Creates a bitset capable of storing up to bits_capacity bits.<br>All bits are initialized to 0.<br>Returns NULL on allocation failure or if bits_capacity is 0.<br>Complexity: O(n) where n = (bits_capacity + 7) / 8.</p><p>Destroys a bitset and frees its memory.<br>Safe to call with NULL pointer.</p><p>Tests whether the bit at bit_index is set (1) or clear (0).<br>Returns true if the bit is set, false otherwise.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p><p>Sets the bit at bit_index to 1.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p><p>Clears the bit at bit_index to 0.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p>]]></summary>
      <examples>
        <example id="ex.id-0145.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
typedef struct c99lc_bitset {
    size_t bytes_capacity; /* number of bytes allocated in items[] */
    size_t bits_capacity; /* maximum number of bits that can be stored */
    uint8_t items[]; /* flexible array member for bit storage */
} c99lc_bitset;
]]></code>
        </example>
        <example id="ex.id-0145.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_bitset* c99lc_bitset_create(size_t bits_capacity);
]]></code>
        </example>
        <example id="ex.id-0145.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_bitset_destroy(c99lc_bitset* bitset);
]]></code>
        </example>
        <example id="ex.id-0145.4" lang="c99">
          <title>Example 4</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_bitset_test(const c99lc_bitset* bitset, size_t bit_index);
]]></code>
        </example>
        <example id="ex.id-0145.5" lang="c99">
          <title>Example 5</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_bitset_set(c99lc_bitset* bitset, size_t bit_index);
]]></code>
        </example>
        <example id="ex.id-0145.6" lang="c99">
          <title>Example 6</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_bitset_clear(c99lc_bitset* bitset, size_t bit_index);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0146" name="idiom: Parenthesis classification and matching" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL bool c99lc_char_is_open_paren(char ch);</signature>
      <summary><![CDATA[<p>Returns true if the character is an opening parenthesis: '(', '{', or '['.<br>Returns false for any other character.</p><p>Returns true if the character is a closing parenthesis: ')', '}', or ']'.<br>Returns false for any other character.</p><p>Returns the matching parenthesis for the given character.<br>Maps '(' to ')', '{' to '}', '[' to ']' and vice versa.<br>Returns '\0' if the character is not a recognized parenthesis.</p>]]></summary>
      <examples>
        <example id="ex.id-0146.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_char_is_open_paren(char ch);
]]></code>
        </example>
        <example id="ex.id-0146.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL bool c99lc_char_is_close_paren(char ch);
]]></code>
        </example>
        <example id="ex.id-0146.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL char c99lc_char_paren_reverse(char ch);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0147" name="idiom: Parse integer digits to LSB-first array" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL void c99lc_integers_parse_digits_to_array(</signature>
      <summary><![CDATA[<p>Decomposes source into decimal digits written LSB-first into dest_array.<br>Writes up to dest_array_size digits; negative numbers produce absolute digits.</p>]]></summary>
      <examples>
        <example id="ex.id-0147.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_integers_parse_digits_to_array(
    int source, unsigned char* dest_array, size_t dest_array_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0148" name="idiom: Parse ISO date string YYYY-MM-DD with validation" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_reasonable_date_parse_from_string(</signature>
      <summary><![CDATA[<p>Parses "YYYY-MM-DD" into out and validates month and day ranges.<br>Returns C99LC_RESULT_SUCCESS on success, otherwise C99LC_RESULT_FAILED.</p>]]></summary>
      <examples>
        <example id="ex.id-0148.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_reasonable_date_parse_from_string(
    const char* date_string, c99lc_reasonable_date* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0149" name="idiom: Parse uint32 from ASCII decimal string (validated)" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_integer_parse_uint32_from_string(</signature>
      <summary><![CDATA[<p>Parses ASCII decimal digits from input[0..input_size) into *out.<br>Fails on non-digits or empty input; returns a C99LC_RESULT_* code.</p>]]></summary>
      <examples>
        <example id="ex.id-0149.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL c99lc_result c99lc_integer_parse_uint32_from_string(
    const char* input, size_t input_size, uint32_t* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0150" name="idiom: Parse with `strtol` and keep the end pointer in the loop header" kind="idiom">
      <signature>for (char *p = s; *p; ) {</signature>
      <summary><![CDATA[<p>This is a robust skeleton for numeric tokenization.</p>]]></summary>
      <examples>
        <example id="ex.id-0150.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (char *p = s; *p; ) {
    char *end;
    long v = strtol(p, &end, 10);
    if (end == p) break;     /* no progress */
    /* use v */
    p = end;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0151" name="idiom: Pass a runnable procedure as parameter" kind="idiom">
      <signature>void run(void (*fn)(void)) {</signature>
      <summary><![CDATA[<p>Accept a function pointer as an argument and invoke it.</p>]]></summary>
      <notes>
        <note id="note.id-0151.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/93/pass-a-runnable-procedure-as-parameter">https://programming-idioms.org/idiom/93/pass-a-runnable-procedure-as-parameter</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0151.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void run(void (*fn)(void)) {
    fn();
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0152" name="idiom: Pause execution for 5 seconds" kind="idiom">
      <signature>void sleep_seconds(unsigned int seconds) {</signature>
      <summary><![CDATA[<p>Pause program execution for approximately five seconds using only standard C time facilities.</p>]]></summary>
      <notes>
        <note id="note.id-0152.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/45/pause-execution-for-5-seconds">https://programming-idioms.org/idiom/45/pause-execution-for-5-seconds</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0152.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

void sleep_seconds(unsigned int seconds) {
    time_t start = time(NULL);
    while (difftime(time(NULL), start) < seconds) {
        /* busy wait */
    }
}

void pause_five_seconds(void) {
    sleep_seconds(5);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0153" name="idiom: Pick a random element from a list" kind="idiom">
      <signature>int pick_random_int(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Select one element uniformly at random from a non-empty integer array.</p>]]></summary>
      <notes>
        <note id="note.id-0153.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/11/pick-a-random-element-from-a-list">https://programming-idioms.org/idiom/11/pick-a-random-element-from-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0153.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int pick_random_int(const int* array, size_t count) {
    return array[rand() % count];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0154" name="idiom: Pick uniformly a random floating point number in [a..b)" kind="idiom">
      <signature>double random_double_range(double a, double b) {</signature>
      <summary><![CDATA[<p>Generate a floating point value greater than or equal to a and strictly less than b.</p>]]></summary>
      <notes>
        <note id="note.id-0154.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/14/pick-uniformly-a-random-floating-point-number-in-a-b">https://programming-idioms.org/idiom/14/pick-uniformly-a-random-floating-point-number-in-a-b</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0154.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

double random_double_range(double a, double b) {
    return a + (b - a) * ((double)rand() / (double)RAND_MAX);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0155" name="idiom: Pick uniformly a random integer in [a..b]" kind="idiom">
      <signature>int random_int_range(int a, int b) {</signature>
      <summary><![CDATA[<p>Generate a uniformly distributed integer in a closed interval while avoiding modulo bias.</p>]]></summary>
      <notes>
        <note id="note.id-0155.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/15/pick-uniformly-a-random-integer-in-a-b">https://programming-idioms.org/idiom/15/pick-uniformly-a-random-integer-in-a-b</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0155.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int random_int_range(int a, int b) {
    const int range = b - a + 1;
    const int limit = RAND_MAX - (RAND_MAX % range);
    int r;

    do {
        r = rand();
    } while (r >= limit);

    return a + (r % range);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0156" name="idiom: Pointer iteration over array with end pointer" kind="idiom">
      <signature>void increment_all(int* data, size_t count) {</signature>
      <summary><![CDATA[<p>Process a contiguous buffer using pointer arithmetic and an explicit length.</p><p>You avoid repeated indexing arithmetic and it composes well with subranges.</p>]]></summary>
      <notes>
        <note id="note.id-0156.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/6/iterate-over-list-values">https://programming-idioms.org/idiom/6/iterate-over-list-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0156.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stddef.h>

void increment_all(int* data, size_t count) {
    int* end = data + count;
    while (data < end) {
        (*data)++;
        data++;
    }
}
]]></code>
        </example>
        <example id="ex.id-0156.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
for (int *p = a, *e = a + n; p != e; ++p) {
    *p += 1;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0157" name="idiom: Preserve `errno` across cleanup that might clobber it" kind="idiom">
      <signature>int saved = errno;</signature>
      <summary><![CDATA[<p>This matters when callers use <code>errno</code> to diagnose the original failure.</p>]]></summary>
      <examples>
        <example id="ex.id-0157.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int saved = errno;
/* cleanup that might call functions touching errno */
errno = saved;
return -1;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0158" name="idiom: Print `size_t` and pointers correctly" kind="idiom">
      <signature>printf(&quot;n=%zu\n&quot;, n);</signature>
      <summary><![CDATA[<p>These format specifiers prevent subtle UB and portability bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0158.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
printf("n=%zu\n", n);
printf("p=%p\n", (void *)p);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0159" name="idiom: Print Hello 10 times" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Execute the same output operation a fixed number of times using a deterministic loop.</p>]]></summary>
      <notes>
        <note id="note.id-0159.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/2/print-hello-10-times">https://programming-idioms.org/idiom/2/print-hello-10-times</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0159.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    for (int i = 0; i < 10; ++i) {
        printf("Hello\n");
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0160" name="idiom: Print Hello World" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Print a literal string followed by a newline to the standard output stream using a generic formatted output function.</p>]]></summary>
      <notes>
        <note id="note.id-0160.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/1/print-hello-world">https://programming-idioms.org/idiom/1/print-hello-world</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0160.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0161" name="idiom: Print integer array with brackets" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL void c99lc_print_integer_array(const unsigned char* a, size_t n);</signature>
      <summary><![CDATA[<p>Prints digits as "[d0, d1, ...]\n" to stdout.<br>Safe to call with NULL pointer (prints an empty list).</p>]]></summary>
      <examples>
        <example id="ex.id-0161.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_print_integer_array(const unsigned char* a, size_t n);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0162" name="idiom: Print list elements by group of 2" kind="idiom">
      <signature>void print_pairs(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Print elements of an integer array two at a time.</p>]]></summary>
      <notes>
        <note id="note.id-0162.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/163/print-list-elements-by-group-of-2">https://programming-idioms.org/idiom/163/print-list-elements-by-group-of-2</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0162.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void print_pairs(const int* array, size_t count) {
    for (size_t i = 0; i + 1 < count; i += 2) {
        printf("%d, %d\n", array[i], array[i + 1]);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0163" name="idiom: Public declaration macro for C/C++ linkage (extern/static)" kind="idiom">
      <signature>Public declaration macro for C/C++ linkage (extern/static)</signature>
      <summary><![CDATA[]]></summary>
      <examples>
        <example id="ex.id-0163.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define C99_LEETCODE_PUBLIC_DECL extern
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0164" name="idiom: Quine program" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Output the program source code itself without reading from external files.</p>]]></summary>
      <notes>
        <note id="note.id-0164.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/182/quine-program">https://programming-idioms.org/idiom/182/quine-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0164.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    const char* s =
        "#include <stdio.h>\n\n"
        "int main(void) {\n"
        "    const char* s = \"%s\";\n"
        "    printf(s, s);\n"
        "    return 0;\n"
        "}\n";
    printf(s, s);
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0165" name="idiom: Read command line argument" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Read the first command-line argument after the program name.</p>]]></summary>
      <notes>
        <note id="note.id-0165.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/60/read-command-line-argument">https://programming-idioms.org/idiom/60/read-command-line-argument</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0165.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int main(int argc, char* argv[]) {
    if (argc > 1) {
        const char* arg = argv[1];
        (void)arg;
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0166" name="idiom: Read file line by line" kind="idiom">
      <signature>void read_lines(FILE* file) {</signature>
      <summary><![CDATA[<p>Read a text file line by line using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0166.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/120/read-integer-from-stdin">https://programming-idioms.org/idiom/120/read-integer-from-stdin</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0166.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void read_lines(FILE* file) {
    char buffer[256];
    while (fgets(buffer, sizeof(buffer), file)) {
        printf("%s", buffer);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0167" name="idiom: Read integer from stdin" kind="idiom">
      <signature>int read_int(void) {</signature>
      <summary><![CDATA[<p>Read an integer value from standard input.</p>]]></summary>
      <notes>
        <note id="note.id-0167.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/120/read-integer-from-stdin">https://programming-idioms.org/idiom/120/read-integer-from-stdin</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0167.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int read_int(void) {
    int value = 0;
    scanf("%d", &value);
    return value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0168" name="idiom: Recursive factorial (simple)" kind="idiom">
      <signature>unsigned int factorial(unsigned int n) {</signature>
      <summary><![CDATA[<p>Compute the factorial of a non-negative integer using a simple recursive definition.</p>]]></summary>
      <notes>
        <note id="note.id-0168.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/31/recursive-factorial-simple">https://programming-idioms.org/idiom/31/recursive-factorial-simple</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0168.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int factorial(unsigned int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0169" name="idiom: Rename file" kind="idiom">
      <signature>int rename_file(const char* from, const char* to) {</signature>
      <summary><![CDATA[<p>Rename a file on the filesystem.</p>]]></summary>
      <notes>
        <note id="note.id-0169.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/343/rename-file">https://programming-idioms.org/idiom/343/rename-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0169.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int rename_file(const char* from, const char* to) {
    return rename(from, to);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0170" name="idiom: Repeated string" kind="idiom">
      <signature>char* repeat_string(const char* value, size_t times) {</signature>
      <summary><![CDATA[<p>Create a new string consisting of a base string repeated a fixed number of times.</p>]]></summary>
      <notes>
        <note id="note.id-0170.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/266/repeated-string">https://programming-idioms.org/idiom/266/repeated-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0170.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* repeat_string(const char* value, size_t times) {
    size_t len = strlen(value);
    char* result = (char*)malloc(len * times + 1);
    if (!result) {
        return NULL;
    }

    char* p = result;
    for (size_t i = 0; i < times; ++i) {
        memcpy(p, value, len);
        p += len;
    }
    result[len * times] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0171" name="idiom: Resize dynamic array safely" kind="idiom">
      <signature>void* xrealloc(void* ptr, size_t size) {</signature>
      <summary><![CDATA[<p>Grow or shrink a dynamic allocation while preserving existing data.</p>]]></summary>
      <notes>
        <note id="note.id-0171.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/58/extract-file-content-to-a-string">https://programming-idioms.org/idiom/58/extract-file-content-to-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0171.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void* xrealloc(void* ptr, size_t size) {
    void* new_ptr = realloc(ptr, size);
    if (!new_ptr) {
        free(ptr);
        return NULL;
    }
    return new_ptr;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0172" name="idiom: Result code enum for success/failure" kind="idiom">
      <signature>typedef int c99lc_result;</signature>
      <summary><![CDATA[]]></summary>
      <examples>
        <example id="ex.id-0172.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef int c99lc_result;
enum { C99LC_RESULT_SUCCESS = 0, C99LC_RESULT_FAILED = 1 };
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0173" name="idiom: Return fraction and exponent of a real number" kind="idiom">
      <signature>void print_fraction_exponent(double value) {</signature>
      <summary><![CDATA[<p>Decompose a floating point value into its normalized fraction and exponent.</p>]]></summary>
      <notes>
        <note id="note.id-0173.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/204/return-fraction-and-exponent-of-a-real-number">https://programming-idioms.org/idiom/204/return-fraction-and-exponent-of-a-real-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0173.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stdio.h>

void print_fraction_exponent(double value) {
    int exponent;
    double fraction = frexp(value, &exponent);
    printf("%f %d\n", fraction, exponent);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0174" name="idiom: Return static string literal" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL const char* c99lc_helloworld(void);</signature>
      <summary><![CDATA[<p>Returns a pointer to a constant, null-terminated "Hello, World!" string.<br>Storage duration is static; caller must not free the returned pointer.</p><p>Returns the library version string such as "0.1".<br>String has static storage duration; caller must not free it.</p>]]></summary>
      <examples>
        <example id="ex.id-0174.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL const char* c99lc_helloworld(void);
]]></code>
        </example>
        <example id="ex.id-0174.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL const char* c99lc_version(void);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0175" name="idiom: Return status/error code with output parameters" kind="idiom">
      <signature>bool parse_positive_int(const char* s, int* out_value) {</signature>
      <summary><![CDATA[<p>Return a success flag while writing the result through an output parameter.</p><p>Search a 2D integer matrix for a value and return its coordinates using output parameters.</p><p>Callers can stack-allocate <code>struct Result</code> and you avoid heap ownership questions.</p>]]></summary>
      <notes>
        <note id="note.id-0175.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/89/handle-invalid-argument">https://programming-idioms.org/idiom/89/handle-invalid-argument</a></p>]]></description>
        </note>
        <note id="note.id-0175.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/20/return-two-values">https://programming-idioms.org/idiom/20/return-two-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0175.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdbool.h>

bool parse_positive_int(const char* s, int* out_value) {
    int value = atoi(s);
    if (value <= 0) {
        return false;
    }
    *out_value = value;
    return true;
}
]]></code>
        </example>
        <example id="ex.id-0175.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool find_in_matrix(
    const int* matrix,
    size_t rows,
    size_t cols,
    int target,
    size_t* out_row,
    size_t* out_col
) {
    for (size_t r = 0; r < rows; ++r) {
        for (size_t c = 0; c < cols; ++c) {
            if (matrix[r * cols + c] == target) {
                *out_row = r;
                *out_col = c;
                return true;
            }
        }
    }
    return false;
}
]]></code>
        </example>
        <example id="ex.id-0175.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
int parse(const char *s, struct Result *out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0176" name="idiom: Reverse a string" kind="idiom">
      <signature>char* reverse_string(const char* s) {</signature>
      <summary><![CDATA[<p>Create a new string containing the characters of the input string in reverse byte order. Multibyte encodings are not preserved.</p>]]></summary>
      <notes>
        <note id="note.id-0176.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/41/reverse-a-string">https://programming-idioms.org/idiom/41/reverse-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0176.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* reverse_string(const char* s) {
    size_t len = strlen(s);
    char* result = (char*)malloc(len + 1);
    if (!result) {
        return NULL;
    }

    for (size_t i = 0; i < len; ++i) {
        result[i] = s[len - 1 - i];
    }
    result[len] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0177" name="idiom: Reverse array/list in place" kind="idiom">
      <signature>void reverse_ints(int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Reverse the elements of an integer array in place.</p><p>Reverses array[0..array_size) in place.<br>No-op if array is NULL or array_size is 0.</p>]]></summary>
      <notes>
        <note id="note.id-0177.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/19/reverse-a-list">https://programming-idioms.org/idiom/19/reverse-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0177.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stddef.h>

void reverse_ints(int* array, size_t count) {
    size_t left = 0;
    size_t right = count ? count - 1 : 0;

    while (left < right) {
        int tmp = array[left];
        array[left] = array[right];
        array[right] = tmp;
        ++left;
        --right;
    }
}
]]></code>
        </example>
        <example id="ex.id-0177.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_array_int_reverse_in_place(int* array, size_t array_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0178" name="idiom: Reverse loop without unsigned underflow traps" kind="idiom">
      <signature>for (size_t i = n; i-- &gt; 0; ) {</signature>
      <summary><![CDATA[<p>This avoids <code>i &gt;= 0</code> (which is always true for <code>size_t</code>) and avoids underflow bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0178.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (size_t i = n; i-- > 0; ) {
    /* uses i = n-1 down to 0 */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0179" name="idiom: Roman numeral conversion (char map + subtractive parse)" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL int c99lc_roman_char_to_int(char ch);</signature>
      <summary><![CDATA[<p>Maps a single Roman numeral character to its integer value.<br>Returns 0 for unsupported characters.</p><p>Converts a Roman numeral string using standard subtractive notation.<br>Returns 0 for NULL or for a string that contributes no valid symbols.</p>]]></summary>
      <examples>
        <example id="ex.id-0179.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_roman_char_to_int(char ch);
]]></code>
        </example>
        <example id="ex.id-0179.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_roman_to_int(const char* s);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0180" name="idiom: Round floating point number to integer" kind="idiom">
      <signature>int round_to_int(double value) {</signature>
      <summary><![CDATA[<p>Round a floating point value to the nearest integer, with ties rounded upward.</p>]]></summary>
      <notes>
        <note id="note.id-0180.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/81/round-floating-point-number-to-integer">https://programming-idioms.org/idiom/81/round-floating-point-number-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0180.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>

int round_to_int(double value) {
    return (int)floor(value + 0.5);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0181" name="idiom: Safe memory allocation" kind="idiom">
      <signature>void* xmalloc(size_t size) {</signature>
      <summary><![CDATA[<p>Allocate memory and fail fast if allocation is unsuccessful.</p>]]></summary>
      <notes>
        <note id="note.id-0181.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/88/allocate-1m-bytes">https://programming-idioms.org/idiom/88/allocate-1m-bytes</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0181.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

void* xmalloc(size_t size) {
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0182" name="idiom: Safe string copy with truncation" kind="idiom">
      <signature>void safe_strcpy(char* dst, size_t dst_size, const char* src) {</signature>
      <summary><![CDATA[<p>Copy a string into a fixed buffer while guaranteeing null termination.</p>]]></summary>
      <notes>
        <note id="note.id-0182.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places">https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0182.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

void safe_strcpy(char* dst, size_t dst_size, const char* src) {
    if (dst_size == 0) {
        return;
    }
    strncpy(dst, src, dst_size - 1);
    dst[dst_size - 1] = '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0183" name="idiom: Seed random generator" kind="idiom">
      <signature>void seed_random(unsigned int seed) {</signature>
      <summary><![CDATA[<p>Initialize the pseudo-random number generator with a fixed seed.</p>]]></summary>
      <notes>
        <note id="note.id-0183.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/69/seed-random-generator">https://programming-idioms.org/idiom/69/seed-random-generator</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0183.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void seed_random(unsigned int seed) {
    srand(seed);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0184" name="idiom: Set, clear, and test a bit" kind="idiom">
      <signature>void set_bit(unsigned int* value, unsigned int bit) {</signature>
      <summary><![CDATA[<p>Manipulate individual bits using bit masks.</p>]]></summary>
      <notes>
        <note id="note.id-0184.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation">https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0184.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

void set_bit(unsigned int* value, unsigned int bit) {
    *value |= (1U << bit);
}

void clear_bit(unsigned int* value, unsigned int bit) {
    *value &= ~(1U << bit);
}

bool test_bit(unsigned int value, unsigned int bit) {
    return (value & (1U << bit)) != 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0185" name="idiom: Shuffle a list" kind="idiom">
      <signature>void shuffle_ints(int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Randomly permute the elements of an integer array using the Fisher-Yates algorithm.</p>]]></summary>
      <notes>
        <note id="note.id-0185.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/10/shuffle-a-list">https://programming-idioms.org/idiom/10/shuffle-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0185.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

void shuffle_ints(int* array, size_t count) {
    if (count < 2) {
        return;
    }

    for (size_t i = count - 1; i > 0; --i) {
        size_t j = (size_t)(rand() % (i + 1));
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0186" name="idiom: Simple stack using array" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Implement a fixed-size stack using an array and an index.</p>]]></summary>
      <notes>
        <note id="note.id-0186.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list">https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0186.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

#define STACK_CAPACITY 32

typedef struct {
    int data[STACK_CAPACITY];
    int top;
} Stack;

void stack_init(Stack* s) {
    s->top = 0;
}

bool stack_push(Stack* s, int value) {
    if (s->top >= STACK_CAPACITY) {
        return false;
    }
    s->data[s->top++] = value;
    return true;
}

bool stack_pop(Stack* s, int* out_value) {
    if (s->top == 0) {
        return false;
    }
    *out_value = s->data[--s->top];
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0187" name="idiom: Single-exit cleanup with `goto`" kind="idiom">
      <signature>int f(void) {</signature>
      <summary><![CDATA[<p>This scales when you add resources; you do not multiply cleanup code.</p>]]></summary>
      <examples>
        <example id="ex.id-0187.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int f(void) {
    int rc = -1;
    FILE *fp = 0;
    void *buf = 0;

    fp = fopen("x", "rb");
    if (!fp) goto out;

    buf = malloc(4096);
    if (!buf) goto out;

    rc = 0;
out:
    free(buf);
    if (fp) fclose(fp);
    return rc;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0188" name="idiom: Single-header library with implementation macro and feature toggles" kind="idiom">
      <signature>Single-header library with implementation macro and feature toggles</signature>
      <summary><![CDATA[<p>c99-leetcode.h - v0.1 - single-header C99 utilities<br>Public Domain or MIT, your choice, see end of file.</p><p>Overview<br>Tiny stb-style header providing small, dependency-free helpers commonly<br>needed in coding challenge style problems: integer digit routines,<br>bit counting and parity, array reversal, Roman numeral conversion,<br>ASCII decimal parsing, a minimal int vector, and simple date helpers.</p><p>Design<br>- Single-header; include this file everywhere.<br>- In one translation unit: #define C99_LEETCODE_IMPLEMENTATION before include.<br>- Optional C99_LEETCODE_STATIC makes definitions 'static' in that TU.<br>- Optional C99_LEETCODE_NO_STDIO omits printf-based helpers.<br>- No hidden global state. Allocation hooks are provided but optional.</p><p>Build<br>In one source file:<br>#define C99_LEETCODE_IMPLEMENTATION<br>#include "c99-leetcode.h"<br>In all other files:<br>#include "c99-leetcode.h"</p>]]></summary>
    </function>

    <function id="fn.idiom.id-0189" name="idiom: Size-in, size-out for buffers (and report required size)" kind="idiom">
      <signature>int encode(char *dst, size_t dst_sz, size_t *out_sz);</signature>
      <summary><![CDATA[<p>On overflow, set <code>*out_sz</code> to the needed size and return an error.</p>]]></summary>
      <examples>
        <example id="ex.id-0189.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int encode(char *dst, size_t dst_sz, size_t *out_sz);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0190" name="idiom: Sort by a comparator (qsort/bsearch)" kind="idiom">
      <signature>int compare_ints(const void* a, const void* b) {</signature>
      <summary><![CDATA[<p>Sort an array of integers using qsort with a custom comparator.</p><p>Sort an array of structures by an integer field using qsort and a comparator.</p><p>Comparison function for int arrays compatible with qsort and bsearch.<br>Returns negative if *a &lt; *b, zero if *a == *b, positive if *a &gt; *b.<br>Avoids overflow by using subtraction comparison idiom.<br>Example: qsort(array, size, sizeof(int), c99lc_array_int_compare);<br>Complexity: O(1).</p>]]></summary>
      <notes>
        <note id="note.id-0190.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/100/sort-by-a-comparator">https://programming-idioms.org/idiom/100/sort-by-a-comparator</a></p>]]></description>
        </note>
        <note id="note.id-0190.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/28/sort-by-a-property">https://programming-idioms.org/idiom/28/sort-by-a-property</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0190.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

int compare_ints(const void* a, const void* b) {
    int x = *(const int*)a;
    int y = *(const int*)b;

    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
}

void sort_ints(int* values, size_t count) {
    qsort(values, count, sizeof(int), compare_ints);
}
]]></code>
        </example>
        <example id="ex.id-0190.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stdlib.h>

typedef struct {
    int priority;
} Item;

int compare_item_priority(const void* a, const void* b) {
    const Item* ia = (const Item*)a;
    const Item* ib = (const Item*)b;

    if (ia->priority < ib->priority) {
        return -1;
    }
    if (ia->priority > ib->priority) {
        return 1;
    }
    return 0;
}

void sort_items(Item* items, size_t count) {
    qsort(items, count, sizeof(Item), compare_item_priority);
}
]]></code>
        </example>
        <example id="ex.id-0190.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL int c99lc_array_int_compare(const void* a, const void* b);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0191" name="idiom: Source code inclusion" kind="idiom">
      <signature>void foo(void) {</signature>
      <summary><![CDATA[<p>Include source code from another file directly into a function body.</p>]]></summary>
      <notes>
        <note id="note.id-0191.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/127/source-code-inclusion">https://programming-idioms.org/idiom/127/source-code-inclusion</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0191.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void foo(void) {
#include "foobody.txt"
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0192" name="idiom: Sparse array initialization with designated indices" kind="idiom">
      <signature>int map[256] = { [0 ... 255] = -1, [&apos;A&apos;] = 0, [&apos;B&apos;] = 1 };</signature>
      <summary><![CDATA[<p>Range designators (<code>[0 ... 255]</code>) are a GCC/Clang extension, not C99. The strictly C99 part is designated indices like <code>['A']</code>. If you need strict portability, stick to explicit indices.</p>]]></summary>
      <examples>
        <example id="ex.id-0192.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int map[256] = { [0 ... 255] = -1, ['A'] = 0, ['B'] = 1 };
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0193" name="idiom: Split a space-separated string" kind="idiom">
      <signature>size_t split_spaces(char* s, char** tokens, size_t max_tokens) {</signature>
      <summary><![CDATA[<p>Split a mutable string into space-separated tokens using the standard C tokenizer.</p>]]></summary>
      <notes>
        <note id="note.id-0193.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/49/split-a-space-separated-string">https://programming-idioms.org/idiom/49/split-a-space-separated-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0193.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

size_t split_spaces(char* s, char** tokens, size_t max_tokens) {
    size_t count = 0;
    char* token = strtok(s, " ");

    while (token && count < max_tokens) {
        tokens[count++] = token;
        token = strtok(NULL, " ");
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0194" name="idiom: Strict aliasing safe type-punning: use `memcpy`, not pointer casts" kind="idiom">
      <signature>float f;</signature>
      <summary><![CDATA[<p>Pointer-cast punning can break under optimization; <code>memcpy</code> is the portable way.</p>]]></summary>
      <examples>
        <example id="ex.id-0194.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
float f;
uint32_t u;
memcpy(&u, &f, sizeof u);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0195" name="idiom: String interpolation" kind="idiom">
      <signature>void format_planets(int count, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Format a string by inserting an integer value into a text template.</p>]]></summary>
      <notes>
        <note id="note.id-0195.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/302/string-interpolation">https://programming-idioms.org/idiom/302/string-interpolation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0195.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void format_planets(int count, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "Our sun has %d planets", count);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0196" name="idiom: Stringize and concatenate for generating names and messages" kind="idiom">
      <signature>int CAT(tmp_, __LINE__);</signature>
      <summary><![CDATA[<p>These are building blocks for debugging macros and generated identifiers.</p>]]></summary>
      <examples>
        <example id="ex.id-0196.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define STR_(x) #x
#define STR(x) STR_(x)

#define CAT_(a,b) a##b
#define CAT(a,b) CAT_(a,b)

int CAT(tmp_, __LINE__);
const char *msg = "line " STR(__LINE__);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0197" name="idiom: Successive conditions" kind="idiom">
      <signature>void dispatch(int c1, int c2, int c3) {</signature>
      <summary><![CDATA[<p>Execute the first matching branch among several mutually exclusive conditions.</p>]]></summary>
      <notes>
        <note id="note.id-0197.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/131/successive-conditions">https://programming-idioms.org/idiom/131/successive-conditions</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0197.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void dispatch(int c1, int c2, int c3) {
    if (c1) {
        f1();
    } else if (c2) {
        f2();
    } else if (c3) {
        f3();
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0198" name="idiom: Sum digits in array" kind="idiom">
      <signature>C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_digits_sum(const unsigned char* digits,</signature>
      <summary><![CDATA[<p>Sums the decimal digits in digits[0..digits_size).<br>Returns 0 if digits is NULL or digits_size is 0.</p>]]></summary>
      <examples>
        <example id="ex.id-0198.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL unsigned char c99lc_digits_sum(const unsigned char* digits,
    size_t digits_size);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0199" name="idiom: Swap values via temporary" kind="idiom">
      <signature>void swap_ints(int* a, int* b) {</signature>
      <summary><![CDATA[<p>Swap the values of two integers using a temporary variable.</p><p>Swaps two 32-bit unsigned integers pointed to by a and b.<br>No-op if either pointer is NULL.</p><p>The macro version above uses <code>__typeof__</code>, which is a GNU extension, not C99. In strict C99, you typically hand-write swaps or use a function specialized per type.</p>]]></summary>
      <notes>
        <note id="note.id-0199.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/21/swap-values">https://programming-idioms.org/idiom/21/swap-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0199.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
void swap_ints(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
]]></code>
        </example>
        <example id="ex.id-0199.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
C99_LEETCODE_PUBLIC_DECL void c99lc_util_swap_u32(uint32_t* a, uint32_t* b);
]]></code>
        </example>
        <example id="ex.id-0199.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
#define SWAP(a,b) do { __typeof__(a) _t = (a); (a) = (b); (b) = _t; } while (0)
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0200" name="idiom: Switch-driven state machine with intentional fallthrough" kind="idiom">
      <signature>switch (state) {</signature>
      <summary><![CDATA[<p>The convenience is real, but comment intentional fallthrough because compilers warn and humans misread.</p>]]></summary>
      <examples>
        <example id="ex.id-0200.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
switch (state) {
case S_START:
    /* ... */
    state = S_BODY;
    /* fall through */
case S_BODY:
    /* ... */
    break;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0201" name="idiom: Test if string is empty" kind="idiom">
      <signature>bool is_empty(const char* s) {</signature>
      <summary><![CDATA[<p>Check whether a string has zero length.</p>]]></summary>
      <notes>
        <note id="note.id-0201.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/320/test-if-string-is-empty">https://programming-idioms.org/idiom/320/test-if-string-is-empty</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0201.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool is_empty(const char* s) {
    return s[0] == '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0202" name="idiom: The canonical &quot;walk a C string&quot; pointer loop" kind="idiom">
      <signature>for (const unsigned char *p = (const unsigned char *)s; *p; ++p) {</signature>
      <summary><![CDATA[<p>Using <code>unsigned char</code> avoids undefined behavior with the ctype family when chars are negative.</p>]]></summary>
      <examples>
        <example id="ex.id-0202.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (const unsigned char *p = (const unsigned char *)s; *p; ++p) {
    /* ... */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0203" name="idiom: The comma operator for tight loops (use sparingly)" kind="idiom">
      <signature>for (i = 0, p = a; i &lt; n; ++i, ++p) { /* ... */ }</signature>
      <summary><![CDATA[<p>It is idiomatic in C, but readability drops if you overpack logic into the header.</p>]]></summary>
      <examples>
        <example id="ex.id-0203.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (i = 0, p = a; i < n; ++i, ++p) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0204" name="idiom: The do-while(0) macro wrapper so statements behave like statements" kind="idiom">
      <signature>The do-while(0) macro wrapper so statements behave like statements</signature>
      <summary><![CDATA[<p>This prevents surprises with <code>if (cond) CHECK(...); else ...</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0204.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define CHECK(x) do { if (!(x)) return -1; } while (0)
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0205" name="idiom: Tokenize without `strtok` by using `strcspn` and manual slicing" kind="idiom">
      <signature>for (char *p = s; *p; ) {</signature>
      <summary><![CDATA[<p>No global state, re-entrant, and it works with custom delimiters.</p>]]></summary>
      <examples>
        <example id="ex.id-0205.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (char *p = s; *p; ) {
    p += strspn(p, " \t");
    size_t len = strcspn(p, " \t");
    if (len == 0) break;
    /* token is p..p+len */
    p += len;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0206" name="idiom: Trim prefix" kind="idiom">
      <signature>const char* trim_prefix(const char* s, const char* prefix) {</signature>
      <summary><![CDATA[<p>Remove a prefix from a string if it is present.</p>]]></summary>
      <notes>
        <note id="note.id-0206.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/167/trim-prefix">https://programming-idioms.org/idiom/167/trim-prefix</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0206.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

const char* trim_prefix(const char* s, const char* prefix) {
    size_t len = strlen(prefix);
    return strncmp(s, prefix, len) == 0 ? s + len : s;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0207" name="idiom: Trim whitespace in place (two pointers)" kind="idiom">
      <signature>char* trim_whitespace(char* s) {</signature>
      <summary><![CDATA[<p>Remove leading and trailing ASCII whitespace from a mutable string.</p><p>This is a reusable skeleton for whitespace trimming without allocating.</p>]]></summary>
      <notes>
        <note id="note.id-0207.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/110/check-if-string-is-blank">https://programming-idioms.org/idiom/110/check-if-string-is-blank</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0207.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <ctype.h>
#include <string.h>

char* trim_whitespace(char* s) {
    while (isspace((unsigned char)*s)) {
        ++s;
    }

    char* end = s + strlen(s);
    while (end > s && isspace((unsigned char)*(end - 1))) {
        --end;
    }
    *end = '\0';
    return s;
}
]]></code>
        </example>
        <example id="ex.id-0207.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
char *p = s;
while (*p == ' ' || *p == '\t') ++p;

char *e = p + strlen(p);
while (e > p && (e[-1] == ' ' || e[-1] == '\t' || e[-1] == '\n')) --e;
*e = '\0';

if (p != s) memmove(s, p, (size_t)(e - p) + 1);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0208" name="idiom: Truncate floating point number to integer" kind="idiom">
      <signature>int truncate_to_int(double value) {</signature>
      <summary><![CDATA[<p>Convert a floating point value to an integer by truncating toward zero.</p>]]></summary>
      <notes>
        <note id="note.id-0208.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/80/truncate-floating-point-number-to-integer">https://programming-idioms.org/idiom/80/truncate-floating-point-number-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0208.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int truncate_to_int(double value) {
    return (int)value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0209" name="idiom: Turn a character into a string" kind="idiom">
      <signature>void char_to_string(char c, char* buffer) {</signature>
      <summary><![CDATA[<p>Create a null-terminated string containing a single character.</p>]]></summary>
      <notes>
        <note id="note.id-0209.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/152/turn-a-character-into-a-string">https://programming-idioms.org/idiom/152/turn-a-character-into-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0209.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void char_to_string(char c, char* buffer) {
    buffer[0] = c;
    buffer[1] = '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0210" name="idiom: Use `__FILE__` and `__LINE__` for trace points" kind="idiom">
      <signature>fprintf(stderr, &quot;%s:%d: failed\n&quot;, __FILE__, __LINE__);</signature>
      <summary><![CDATA[<p>This is a low-tech, high-value breadcrumb.</p>]]></summary>
      <examples>
        <example id="ex.id-0210.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
fprintf(stderr, "%s:%d: failed\n", __FILE__, __LINE__);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0211" name="idiom: Use `const` to document and enforce read-only inputs" kind="idiom">
      <signature>int hash(const void *data, size_t n, uint32_t *out);</signature>
      <summary><![CDATA[<p>This eliminates entire classes of accidental mutation bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0211.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int hash(const void *data, size_t n, uint32_t *out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0212" name="idiom: Use `restrict` (C99) when you can prove non-aliasing" kind="idiom">
      <signature>void saxpy(float *restrict y, const float *restrict x, size_t n, float a);</signature>
      <summary><![CDATA[<p>It can unlock optimizations and documents a strong contract.</p>]]></summary>
      <examples>
        <example id="ex.id-0212.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void saxpy(float *restrict y, const float *restrict x, size_t n, float a);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0213" name="idiom: Use `sizeof (type){0}` to get a type size without naming an object" kind="idiom">
      <signature>size_t n = sizeof (struct Header){0};</signature>
      <summary><![CDATA[<p>This is occasionally useful in macros and generic helpers where you do not want an actual variable.</p>]]></summary>
      <examples>
        <example id="ex.id-0213.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t n = sizeof (struct Header){0};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0214" name="idiom: Use clock as random generator seed" kind="idiom">
      <signature>void seed_random_with_time(void) {</signature>
      <summary><![CDATA[<p>Seed the pseudo-random number generator using the current system time.</p>]]></summary>
      <notes>
        <note id="note.id-0214.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/70/use-clock-as-random-generator-seed">https://programming-idioms.org/idiom/70/use-clock-as-random-generator-seed</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0214.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <time.h>

void seed_random_with_time(void) {
    srand((unsigned int)time(NULL));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0215" name="idiom: Use scansets in `sscanf` when you really do want it (bounded)" kind="idiom">
      <signature>char key[32];</signature>
      <summary><![CDATA[<p>The width prevents buffer overflow; the scanset is a powerful but underused feature.</p>]]></summary>
      <examples>
        <example id="ex.id-0215.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
char key[32];
if (sscanf(line, "%31[^=]=%*s", key) == 1) { /* key before '=' */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0216" name="idiom: Write to standard error stream" kind="idiom">
      <signature>void report_negative(int x) {</signature>
      <summary><![CDATA[<p>Print a formatted message to the standard error stream.</p>]]></summary>
      <notes>
        <note id="note.id-0216.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/59/write-to-standard-error-stream">https://programming-idioms.org/idiom/59/write-to-standard-error-stream</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0216.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void report_negative(int x) {
    fprintf(stderr, "%d is negative\n", x);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0217" name="idiom: X-macro tables: one list, many derived artifacts" kind="idiom">
      <signature>X(RED)        \</signature>
      <summary><![CDATA[<p>This avoids keeping enum, strings, and other metadata in sync by hand.</p>]]></summary>
      <examples>
        <example id="ex.id-0217.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
/* list */
#define COLORS(X) \
    X(RED)        \
    X(GREEN)      \
    X(BLUE)

/* enum */
#define X(name) name,
enum Color { COLORS(X) };
#undef X

/* to-string */
#define X(name) case name: return #name;
const char *color_name(enum Color c) {
    switch (c) { COLORS(X) default: return "?"; }
}
#undef X
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0218" name="idiom: Xor integers" kind="idiom">
      <signature>int xor_ints(int a, int b) {</signature>
      <summary><![CDATA[<p>Compute the bitwise exclusive OR of two integers.</p>]]></summary>
      <notes>
        <note id="note.id-0218.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/237/xor-integers">https://programming-idioms.org/idiom/237/xor-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0218.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int xor_ints(int a, int b) {
    return a ^ b;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0219" name="idiom: Zero-initialize heap allocation with calloc" kind="idiom">
      <signature>int* create_zeroed_ints(size_t count) {</signature>
      <summary><![CDATA[<p>Allocate an integer array initialized with zeros.</p><p>It communicates "I want zeroed memory" and can be optimized by the runtime.</p>]]></summary>
      <notes>
        <note id="note.id-0219.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/284/create-a-zeroed-list-of-integers">https://programming-idioms.org/idiom/284/create-a-zeroed-list-of-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0219.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

int* create_zeroed_ints(size_t count) {
    return (int*)calloc(count, sizeof(int));
}
]]></code>
        </example>
        <example id="ex.id-0219.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
T *p = calloc(count, sizeof *p);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0220" name="idiom: Zero-initialize scalars and aggregates with `{0}` (and know what it really does)" kind="idiom">
      <signature>int x = 0;</signature>
      <summary><![CDATA[<p>For objects with static storage duration, zero-init happens anyway; for locals, <code>{0}</code> forces a full zero fill by the rules for aggregate initialization. It is concise and hard to get wrong.</p>]]></summary>
      <examples>
        <example id="ex.id-0220.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int x = 0;
int a[10] = {0};
struct S s = {0};
]]></code>
        </example>
      </examples>
    </function>
    </header>
  </category>
</document>
