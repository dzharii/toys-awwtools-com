<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>C99 Library Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="topbar">
    <button id="sidebarToggle" type="button" aria-controls="sidebar">Contents</button>
    <div class="topbar-title">C99 Library Reference</div>
  </div>

  <div class="app">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>C99 Library Reference</h1>
        <p>Offline, single-page C99 standard library notes with copy-ready examples.</p>
      </div>
      <div class="search">
        <label for="searchInput">Search</label>
        <input id="searchInput" type="search" placeholder="Function, header, keyword, or parameter" autocomplete="off">
        <div class="search-hint" id="searchHint">Showing full table of contents.</div>
      </div>
      <nav class="toc" id="toc"></nav>
    </aside>

    <main class="content" aria-live="polite">
      <section id="errors" class="error-banner" hidden></section>
      <div id="content"></div>
      <section id="projectInfo" class="info-block">
        <h2>About this page</h2>
        <p>
          I built this C99 reference as a single-page, offline-first cheat sheet I can keep open while I code. The goal
          is fast lookup of signatures, parameter rules, return behavior, and safe usage patterns, without tab switching
          and without hiding content that breaks browser search.
        </p>
        <p>
          The content on this page started as structured XML documents generated with AI assistance. I iterated on the
          structure and wording until each entry had deterministic rules, clear constraints, and copy-pasteable
          examples.
          The XML is embedded directly into this HTML file, and a small vanilla JavaScript renderer parses it, builds a
          navigation index, and renders everything in a consistent layout.
        </p>
        <p>
          AI tools used: I used ChatGPT (GPT-5.2 Thinking) to design the XML structure and draft the documentation
          content. I used OpenAI Codex to implement the page itself (HTML, CSS, and vanilla JavaScript) and to integrate
          the embedded XML into the final single-page reference.
        </p>
        <p>
          Code blocks are highlighted with microlight.js (ASVD, microlight 0.0.7), a tiny client-side syntax highlighter
          used to improve code readability without external dependencies. The microlight library is bundled locally with
          this project so the page works fully offline.
        </p>
        <p class="info-created">Created: 2026-01-20.</p>
      </section>
    </main>
  </div>

  <div id="sidebarBackdrop" aria-hidden="true"></div>

  <section id="data" hidden>
    <!-- XML blocks are embedded verbatim for offline parsing. -->
    <!-- No XML block contains a </script> sequence, so no splitting is required. -->
    <script id="library-xml-2026-01-20T16-11-47-9fed4cbe-6012-4482-8d7d-c497a86a6364" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="text.classification.case_mapping" name="Text classification and case mapping">
    <summary><![CDATA[
<p>
Character classification and case mapping for bytes and wide characters. These APIs are the standard, portable way
to test whether a character is a digit/letter/space/punctuation and to convert case.
</p>
<p>
Use these functions to write parsers, tokenizers, input validators, and normalization steps (for example, case-folding
a command or identifier). For safety and portability, always respect the required input domains (for example,
cast byte input to <code>unsigned char</code> before calling <code>ctype.h</code> functions), and remember that results
may depend on the active locale (typically <code>LC_CTYPE</code>).
</p>
]]></summary>

    <keywords>
      <kw>ctype</kw>
      <kw>wctype</kw>
      <kw>classification</kw>
      <kw>case mapping</kw>
      <kw>locale</kw>
      <kw>LC_CTYPE</kw>
      <kw>unsigned char</kw>
      <kw>EOF</kw>
      <kw>wint_t</kw>
      <kw>WEOF</kw>
      <kw>Unicode</kw>
      <kw>parsing</kw>
      <kw>tokenizer</kw>
    </keywords>

    <header id="hdr.ctype" name="ctype.h">
      <summary><![CDATA[
<p>
Byte-oriented character classification and case mapping. The classification predicates return non-zero for true and 0 for false.
These functions often exist as macros for performance; treat them as pure, side-effect-free predicates.
</p>
<p>
Input safety rule: the argument must be <code>EOF</code> or representable as <code>unsigned char</code>. Passing a negative
<code>char</code> value directly is undefined behavior on platforms where <code>char</code> is signed.
</p>
]]></summary>

      <function id="fn.isalnum" name="isalnum" kind="function_or_macro">
        <signature>int isalnum(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is alphanumeric (a letter or a decimal digit) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isalnum.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or a value representable as <code>unsigned char</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.ctype.domain" severity="important">
                <description><![CDATA[
<p>Passing any value other than <code>EOF</code> or an <code>unsigned char</code> value is undefined behavior.</p>
]]></description>
              </constraint>
              <constraint id="c.ctype.locale" severity="info">
                <description><![CDATA[
<p>Classification depends on the active locale. In the "C" locale, behavior matches basic ASCII classes.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphanumeric, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isalnum.identifier_scan" lang="c99">
            <title>Scan a token of [A-Za-z0-9] in a locale-aware way</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t scan_alnum_token(const char* s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isalnum((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isalpha" name="isalpha" kind="function_or_macro">
        <signature>int isalpha(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is an alphabetic character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isalpha.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isalpha.domain" severity="important">
                <description><![CDATA[
<p>Cast byte data to <code>unsigned char</code> before passing to <code>isalpha</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.isalpha.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. Use explicit ASCII checks if you require ASCII-only behavior.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphabetic, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isalpha.word_start" lang="c99">
            <title>Find the first alphabetic character</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t find_first_alpha(const char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isalpha((int)uc)) {
            return i;
        }
    }
    return (size_t)-1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isdigit" name="isdigit" kind="function_or_macro">
        <signature>int isdigit(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a decimal digit ('0'..'9'). In C99, this classification is not locale-variant for ASCII digits.</p>
]]></summary>
        <parameters>
          <param id="p.isdigit.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isdigit.domain" severity="important">
                <description><![CDATA[
<p>Do not pass a negative <code>char</code> value. Cast to <code>unsigned char</code> first.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a decimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isdigit.count_digits" lang="c99">
            <title>Count digits in a string safely</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t count_digits(const char* s) {
    size_t n = 0;
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isdigit((int)uc)) {
            ++n;
        }
    }
    return n;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isspace" name="isspace" kind="function_or_macro">
        <signature>int isspace(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is whitespace (for example space, tab, newline) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isspace.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isspace.domain" severity="important">
                <description><![CDATA[
<p>Cast byte input to <code>unsigned char</code> before calling.</p>
]]></description>
              </constraint>
              <constraint id="c.isspace.locale" severity="info">
                <description><![CDATA[
<p>Whitespace set can vary by locale beyond the basic ASCII set.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if whitespace, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isspace.trim_left" lang="c99">
            <title>Trim leading whitespace</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t trim_left_index(const char* s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isspace((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.islower" name="islower" kind="function_or_macro">
        <signature>int islower(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a lowercase letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.islower.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.islower.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior if <code>c</code> is neither <code>EOF</code> nor an <code>unsigned char</code> value.</p>
]]></description>
              </constraint>
              <constraint id="c.islower.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. For ASCII-only rules, use explicit range checks ('a'..'z').</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if lowercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.islower.any_lower" lang="c99">
            <title>Detect whether a string contains any lowercase letters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int contains_lowercase(const char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (islower((int)uc)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isupper" name="isupper" kind="function_or_macro">
        <signature>int isupper(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is an uppercase letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isupper.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isupper.domain" severity="important">
                <description><![CDATA[
<p>Cast to <code>unsigned char</code> when passing a <code>char</code> value.</p>
]]></description>
              </constraint>
              <constraint id="c.isupper.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. For ASCII-only behavior, use explicit range checks ('A'..'Z').</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if uppercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isupper.all_upper" lang="c99">
            <title>Check whether all letters in a token are uppercase</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int token_is_all_upper(const char* s) {
    int saw_letter = 0;
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isalpha((int)uc)) {
            saw_letter = 1;
            if (!isupper((int)uc)) {
                return 0;
            }
        }
    }
    return saw_letter ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ispunct" name="ispunct" kind="function_or_macro">
        <signature>int ispunct(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a punctuation character (neither alphanumeric nor whitespace) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.ispunct.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.ispunct.domain" severity="important">
                <description><![CDATA[
<p>Pass only <code>EOF</code> or values representable as <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.ispunct.locale" severity="info">
                <description><![CDATA[
<p>Punctuation set is locale-dependent. If you need a fixed ASCII punctuation set, define it explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if punctuation, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.ispunct.strip_punct" lang="c99">
            <title>Copy only non-punctuation characters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t copy_without_punct(char* dst, size_t cap, const char* src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != '\0' && j + 1 < cap; ++i) {
        unsigned char uc = (unsigned char)src[i];
        if (!ispunct((int)uc)) {
            dst[j++] = (char)uc;
        }
    }
    dst[j] = '\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isprint" name="isprint" kind="function_or_macro">
        <signature>int isprint(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is printable (including space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isprint.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isprint.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior if given a negative <code>char</code> value that is not <code>EOF</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.isprint.locale" severity="info">
                <description><![CDATA[
<p>What counts as printable may vary by locale and encoding.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if printable, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isprint.sanitize" lang="c99">
            <title>Sanitize bytes: replace non-printables with '.'</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void sanitize_printable(char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (!isprint((int)uc)) {
            s[i] = '.';
        }
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iscntrl" name="iscntrl" kind="function_or_macro">
        <signature>int iscntrl(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a control character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iscntrl.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.iscntrl.domain" severity="important">
                <description><![CDATA[
<p>Cast to <code>unsigned char</code> when testing a <code>char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.iscntrl.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. In the "C" locale, ASCII control characters typically satisfy this predicate.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if control character, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iscntrl.reject_controls" lang="c99">
            <title>Reject strings containing control characters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int has_control_chars(const char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (iscntrl((int)uc)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isxdigit" name="isxdigit" kind="function_or_macro">
        <signature>int isxdigit(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a hexadecimal digit ('0'..'9', 'a'..'f', 'A'..'F') according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isxdigit.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isxdigit.domain" severity="important">
                <description><![CDATA[
<p>Only pass <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a hexadecimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isxdigit.scan_hex" lang="c99">
            <title>Scan a run of hex digits</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t scan_hex_digits(const char* s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isxdigit((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.tolower" name="tolower" kind="function_or_macro">
        <signature>int tolower(int c);</signature>
        <summary><![CDATA[
<p>Converts <code>c</code> to lowercase if it has a lowercase mapping in the current locale; otherwise returns <code>c</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.tolower.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to convert, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.tolower.domain" severity="important">
                <description><![CDATA[
<p>Passing a negative <code>char</code> value (other than <code>EOF</code>) is undefined behavior. Cast to <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.tolower.locale" severity="info">
                <description><![CDATA[
<p>Mapping is locale-dependent. For ASCII-only behavior, map 'A'..'Z' explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Lowercased character value if applicable; otherwise the original value. If input is <code>EOF</code>, returns <code>EOF</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.tolower.safe_cast" severity="important" topic="input-domain">
            <description><![CDATA[
<p>
When converting a byte stored in a <code>char</code>, use <code>tolower((unsigned char)ch)</code>.
This avoids undefined behavior on platforms where <code>char</code> is signed.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.tolower.ascii_fold_command" lang="c99">
            <title>Lowercase a command token safely (byte string)</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void lowercase_in_place(char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        int lc = tolower((int)uc);
        s[i] = (char)lc;
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.toupper" name="toupper" kind="function_or_macro">
        <signature>int toupper(int c);</signature>
        <summary><![CDATA[
<p>Converts <code>c</code> to uppercase if it has an uppercase mapping in the current locale; otherwise returns <code>c</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.toupper.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to convert, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.toupper.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior unless <code>c</code> is <code>EOF</code> or representable as <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.toupper.locale" severity="info">
                <description><![CDATA[
<p>Mapping is locale-dependent. For ASCII-only behavior, map 'a'..'z' explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Uppercased character value if applicable; otherwise the original value. If input is <code>EOF</code>, returns <code>EOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.toupper.headerize" lang="c99">
            <title>Uppercase a token safely (byte string)</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void uppercase_in_place(char* s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        int uc2 = toupper((int)uc);
        s[i] = (char)uc2;
    }
}
]]></code>
          </example>
        </examples>
      </function>

    </header>

    <header id="hdr.wctype" name="wctype.h">
      <summary><![CDATA[
<p>
Wide-character classification and case mapping. Use these functions when working with <code>wchar_t</code> and <code>wint_t</code>
values (for example, when processing wide strings or locale-dependent wide character input).
</p>
<p>
Input safety rule: arguments must be <code>WEOF</code> or representable as <code>wint_t</code> values corresponding to valid wide characters.
Like <code>ctype.h</code>, behavior depends on the active locale (typically <code>LC_CTYPE</code>).
</p>
]]></summary>

      <function id="fn.iswalnum" name="iswalnum" kind="function_or_macro">
        <signature>int iswalnum(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is alphanumeric according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswalnum.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character representable as <code>wint_t</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.wctype.domain" severity="important">
                <description><![CDATA[
<p>Passing values that are neither <code>WEOF</code> nor valid wide characters yields unspecified or undefined behavior depending on implementation.</p>
]]></description>
              </constraint>
              <constraint id="c.wctype.locale" severity="info">
                <description><![CDATA[
<p>Classification is locale-dependent.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphanumeric, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswalnum.scan" lang="c99">
            <title>Scan an alphanumeric prefix in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t scan_walnum_prefix(const wchar_t* s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswalnum((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswalpha" name="iswalpha" kind="function_or_macro">
        <signature>int iswalpha(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is alphabetic according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswalpha.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswalpha.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent; do not assume ASCII-only semantics.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphabetic, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswalpha.find" lang="c99">
            <title>Find first alphabetic wide character</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t find_first_walpha(const wchar_t* s) {
    for (size_t i = 0; s[i] != L'\0'; ++i) {
        if (iswalpha((wint_t)s[i])) {
            return i;
        }
    }
    return (size_t)-1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswblank" name="iswblank" kind="function_or_macro">
        <signature>int iswblank(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a blank character (typically space or horizontal tab) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswblank.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswblank.locale" severity="info">
                <description><![CDATA[
<p>Exact set of "blank" characters can be locale-dependent.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if blank, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswblank.skip" lang="c99">
            <title>Skip leading blanks in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t skip_wblanks(const wchar_t* s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswblank((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswcntrl" name="iswcntrl" kind="function_or_macro">
        <signature>int iswcntrl(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a control character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswcntrl.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a control character, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswcntrl.reject" lang="c99">
            <title>Detect control characters in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_has_controls(const wchar_t* s) {
    for (; *s != L'\0'; ++s) {
        if (iswcntrl((wint_t) * s)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswdigit" name="iswdigit" kind="function_or_macro">
        <signature>int iswdigit(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a decimal digit according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswdigit.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswdigit.locale" severity="info">
                <description><![CDATA[
<p>Unlike byte <code>isdigit</code>, wide digit classification may include locale-specific digits depending on implementation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswdigit.count" lang="c99">
            <title>Count digit characters in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t count_wdigits(const wchar_t* s) {
    size_t n = 0;
    for (size_t i = 0; s[i] != L'\0'; ++i) {
        if (iswdigit((wint_t)s[i])) {
            ++n;
        }
    }
    return n;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswgraph" name="iswgraph" kind="function_or_macro">
        <signature>int iswgraph(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a graphical character (printable excluding space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswgraph.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if graphical, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswgraph.filter" lang="c99">
            <title>Filter out non-graphical characters</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t copy_wgraph(wchar_t* dst, size_t cap, const wchar_t* src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != L'\0' && j + 1 < cap; ++i) {
        if (iswgraph((wint_t)src[i])) {
            dst[j++] = src[i];
        }
    }
    dst[j] = L'\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswlower" name="iswlower" kind="function_or_macro">
        <signature>int iswlower(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a lowercase wide letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswlower.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if lowercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswlower.any" lang="c99">
            <title>Detect lowercase in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_contains_lower(const wchar_t* s) {
    for (; *s != L'\0'; ++s) {
        if (iswlower((wint_t) * s)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswprint" name="iswprint" kind="function_or_macro">
        <signature>int iswprint(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is printable (including space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswprint.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if printable, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswprint.sanitize" lang="c99">
            <title>Replace non-printable wide characters with '?'</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void sanitize_wprintable(wchar_t* s) {
    for (; *s != L'\0'; ++s) {
        if (!iswprint((wint_t) * s)) {
            *s = L'?';
        }
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswpunct" name="iswpunct" kind="function_or_macro">
        <signature>int iswpunct(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is punctuation (neither alphanumeric nor whitespace) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswpunct.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if punctuation, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswpunct.strip" lang="c99">
            <title>Remove punctuation from a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t copy_without_wpunct(wchar_t* dst, size_t cap, const wchar_t* src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != L'\0' && j + 1 < cap; ++i) {
        if (!iswpunct((wint_t)src[i])) {
            dst[j++] = src[i];
        }
    }
    dst[j] = L'\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswspace" name="iswspace" kind="function_or_macro">
        <signature>int iswspace(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is whitespace according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswspace.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if whitespace, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswspace.trim" lang="c99">
            <title>Trim leading whitespace in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t trim_left_wspace(const wchar_t* s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswspace((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswupper" name="iswupper" kind="function_or_macro">
        <signature>int iswupper(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is an uppercase wide letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswupper.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if uppercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswupper.all" lang="c99">
            <title>Check if all letters in a wide string are uppercase</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_letters_all_upper(const wchar_t* s) {
    int saw_letter = 0;
    for (; *s != L'\0'; ++s) {
        wint_t wc = (wint_t) * s;
        if (iswalpha(wc)) {
            saw_letter = 1;
            if (!iswupper(wc)) {
                return 0;
            }
        }
    }
    return saw_letter ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswxdigit" name="iswxdigit" kind="function_or_macro">
        <signature>int iswxdigit(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a hexadecimal digit according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswxdigit.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a hexadecimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswxdigit.scan" lang="c99">
            <title>Scan hex digits in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t scan_whex(const wchar_t* s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswxdigit((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towlower" name="towlower" kind="function_or_macro">
        <signature>wint_t towlower(wint_t wc);</signature>
        <summary><![CDATA[
<p>Converts <code>wc</code> to lowercase if it has a lowercase mapping in the current locale; otherwise returns <code>wc</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.towlower.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to convert, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.towlower.locale" severity="info">
                <description><![CDATA[
<p>Mapping depends on locale. Case conversion for wide characters can be more complex than ASCII.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Lowercased wide character if applicable; otherwise original. If input is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towlower.fold" lang="c99">
            <title>Lowercase a wide string in place</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_lowercase_in_place(wchar_t* s) {
    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towlower((wint_t) * s);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towupper" name="towupper" kind="function_or_macro">
        <signature>wint_t towupper(wint_t wc);</signature>
        <summary><![CDATA[
<p>Converts <code>wc</code> to uppercase if it has an uppercase mapping in the current locale; otherwise returns <code>wc</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.towupper.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to convert, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Uppercased wide character if applicable; otherwise original. If input is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towupper.fold" lang="c99">
            <title>Uppercase a wide string in place</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_uppercase_in_place(wchar_t* s) {
    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towupper((wint_t) * s);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wctype" name="wctype" kind="function">
        <signature>wctype_t wctype(const char* property);</signature>
        <summary><![CDATA[
<p>
Maps a property name to a <code>wctype_t</code> classification descriptor that can be used with <code>iswctype</code>
(if you choose to include it) or for caching a classification category by name.
</p>
<p>
Standard property names correspond to the <code>isw*</code> classes, such as "alpha", "digit", "space", "upper", "lower",
"xdigit", and related names. If the property is not recognized, returns 0.
</p>
]]></summary>
        <parameters>
          <param id="p.wctype.property" name="property" direction="in" type="const char*">
            <description><![CDATA[
<p>Nul-terminated property name string. Examples include "alpha", "digit", "space", "upper", "lower", "xdigit".</p>
]]></description>
            <constraints>
              <constraint id="c.wctype.property_null" severity="important">
                <description><![CDATA[
<p><code>property</code> must not be NULL.</p>
]]></description>
              </constraint>
              <constraint id="c.wctype.property_locale" severity="info">
                <description><![CDATA[
<p>Property interpretation depends on the current locale.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wctype_t">
            <description><![CDATA[
<p>Classification descriptor for the named property, or 0 if the name is not recognized.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.wctype.cache" severity="important" topic="performance">
            <description><![CDATA[
<p>
If you need dynamic selection by name, call <code>wctype</code> once and cache the returned descriptor instead of
repeating string lookups.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.wctype.lookup" lang="c99">
            <title>Lookup and validate a classification property name</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

wctype_t get_class_or_zero(const char* name) {
    /* name must be non-NULL and NUL-terminated */
    wctype_t t = wctype(name);
    return t; /* 0 means "unknown property" */
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wctrans" name="wctrans" kind="function">
        <signature>wctrans_t wctrans(const char* property);</signature>
        <summary><![CDATA[
<p>
Maps a transformation property name to a <code>wctrans_t</code> descriptor used by <code>towctrans</code>.
Standard transformation property names include "tolower" and "toupper".
</p>
<p>If the property is not recognized, returns 0.</p>
]]></summary>
        <parameters>
          <param id="p.wctrans.property" name="property" direction="in" type="const char*">
            <description><![CDATA[
<p>Nul-terminated transformation name string, typically "tolower" or "toupper".</p>
]]></description>
            <constraints>
              <constraint id="c.wctrans.property_null" severity="important">
                <description><![CDATA[
<p><code>property</code> must not be NULL.</p>
]]></description>
              </constraint>
              <constraint id="c.wctrans.locale" severity="info">
                <description><![CDATA[
<p>Transformation behavior depends on the current locale.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wctrans_t">
            <description><![CDATA[
<p>Transformation descriptor, or 0 if the name is not recognized.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.wctrans.lookup" lang="c99">
            <title>Lookup a case transformation descriptor by name</title>
            <code><![CDATA[
#include <wctype.h>

wctrans_t get_transformation(const char* name) {
    /* name must be non-NULL */
    return wctrans(name); /* 0 means "unknown transformation" */
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towctrans" name="towctrans" kind="function">
        <signature>wint_t towctrans(wint_t wc, wctrans_t desc);</signature>
        <summary><![CDATA[
<p>Applies the transformation described by <code>desc</code> to <code>wc</code> and returns the transformed wide character.</p>
]]></summary>
        <parameters>
          <param id="p.towctrans.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to transform, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
          <param id="p.towctrans.desc" name="desc" direction="in" type="wctrans_t">
            <description><![CDATA[
<p>Transformation descriptor returned by <code>wctrans</code>. A value of 0 indicates an invalid or unknown descriptor.</p>
]]></description>
            <constraints>
              <constraint id="c.towctrans.desc_valid" severity="important">
                <description><![CDATA[
<p>Do not pass 0 as <code>desc</code>. Validate the result of <code>wctrans</code> before calling.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Transformed wide character. If <code>wc</code> is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towctrans.dynamic_case" lang="c99">
            <title>Apply case conversion selected by name</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_apply_case(wchar_t* s, const char* which) {
    wctrans_t tr = wctrans(which);
    if (tr == 0) {
        /* Unknown transformation name */
        return;
    }

    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towctrans((wint_t) * s, tr);
    }
}
]]></code>
          </example>
        </examples>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-20T16-12-30-bd774ff8-f2e4-4840-8484-d0941f5605ab" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="strings.raw_memory" name="Strings and raw memory (byte and wide)">
    <summary><![CDATA[
<p>
Primitives for working with raw memory buffers, NUL-terminated byte strings, and NUL-terminated wide strings.
These APIs are the standard toolkit for copying, comparing, searching, tokenizing, and transforming data in-place.
</p>
<p>
Use the raw-memory functions when you are working with counted buffers (not NUL-terminated), and use the string
functions when you are working with NUL-terminated sequences. For safety and portability, always size your
destinations correctly, know whether overlap is permitted, and treat locale-sensitive operations (for example
collation/transform) as distinct from byte-wise comparisons.
</p>
]]></summary>

    <keywords>
      <kw>string.h</kw>
      <kw>wchar.h</kw>
      <kw>memcpy</kw>
      <kw>memmove</kw>
      <kw>buffer overlap</kw>
      <kw>NUL terminator</kw>
      <kw>strlen</kw>
      <kw>strcmp</kw>
      <kw>strncpy</kw>
      <kw>strtok</kw>
      <kw>strerror</kw>
      <kw>wide string</kw>
      <kw>multibyte</kw>
      <kw>mbstate_t</kw>
      <kw>swprintf</kw>
    </keywords>

    <header id="hdr.string" name="string.h">
      <summary><![CDATA[
<p>
Byte-level raw memory and NUL-terminated byte string operations. The memory functions operate on counted buffers.
The string functions generally require NUL-terminated inputs and often require sufficient space in the destination
for the copied data plus the terminating NUL.
</p>
]]></summary>

      <notes>
        <note id="n.string.shared.overlap" severity="important" topic="overlap">
          <description><![CDATA[
<p>
Overlapping copy: use <code>memmove</code> (or <code>wmemmove</code> for wide). Using <code>memcpy</code> (or <code>wmemcpy</code>) with overlap is undefined behavior.
</p>
]]></description>
        </note>
        <note id="n.string.shared.termination" severity="important" topic="nul-termination">
          <description><![CDATA[
<p>
Functions like <code>strcpy</code>, <code>strcat</code>, and friends require that inputs are NUL-terminated.
If you have counted data that may contain NULs, use the <code>mem*</code> family instead.
</p>
]]></description>
        </note>
        <note id="n.string.shared.strncpy" severity="warning" topic="common-pitfall">
          <description><![CDATA[
<p>
<code>strncpy</code> does not guarantee NUL-termination if the source length is at least <code>n</code>. Many bugs come from assuming it always terminates.
If you need a guaranteed terminator, you must add it yourself.
</p>
]]></description>
        </note>
        <note id="n.string.shared.strtok" severity="warning" topic="reentrancy">
          <description><![CDATA[
<p>
<code>strtok</code> modifies the input buffer and uses internal state. It is not suitable for nested parsing or concurrent use.
Use <code>wcstok</code> for wide strings; for byte strings, consider a manual scan if you need explicit state.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.memcpy" name="memcpy" kind="function">
        <signature>void* memcpy(void* dest, const void* src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> bytes from <code>src</code> to <code>dest</code>. The memory regions must not overlap.</p>
]]></summary>
        <parameters>
          <param id="p.memcpy.dest" name="dest" direction="out" type="void*">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes available.</p>
]]></description>
          </param>
          <param id="p.memcpy.src" name="src" direction="in" type="const void*">
            <description><![CDATA[
<p>Source buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to copy.</p>
]]></description>
            <constraints>
              <constraint id="c.memcpy.no_overlap" severity="important">
                <description><![CDATA[
<p><code>dest</code> and <code>src</code> must not overlap. If they can overlap, use <code>memmove</code>.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memcpy.copy_struct" lang="c99">
            <title>Copy fixed-size bytes into a struct field</title>
            <code><![CDATA[
#include <string.h>
#include <stdint.h>

struct Header {
    uint8_t magic[4];
};

void set_magic(struct Header* h, const uint8_t src[4]) {
    /* Regions do not overlap; memcpy is correct. */
    memcpy(h->magic, src, 4u);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memmove" name="memmove" kind="function">
        <signature>void* memmove(void* dest, const void* src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> bytes from <code>src</code> to <code>dest</code>. The regions may overlap.</p>
]]></summary>
        <parameters>
          <param id="p.memmove.dest" name="dest" direction="out" type="void*">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes available.</p>
]]></description>
          </param>
          <param id="p.memmove.src" name="src" direction="in" type="const void*">
            <description><![CDATA[
<p>Source buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memmove.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to move.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memmove.delete_range" lang="c99">
            <title>Delete a slice from a byte buffer in place (overlap-safe)</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

/* Delete [pos, pos+len) from buf of length *n, shifting tail left. */
void delete_range(unsigned char* buf, size_t* n, size_t pos, size_t len) {
    if (pos > *n) return;
    if (len > *n - pos) len = *n - pos;

    /* Regions overlap: must use memmove. */
    memmove(buf + pos, buf + pos + len, (*n - pos - len));
    *n -= len;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memset" name="memset" kind="function">
        <signature>void* memset(void* s, int c, size_t n);</signature>
        <summary><![CDATA[
<p>Sets the first <code>n</code> bytes of the object pointed to by <code>s</code> to the byte value <code>(unsigned char)c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.memset.s" name="s" direction="inout" type="void*">
            <description><![CDATA[
<p>Buffer to fill, must have at least <code>n</code> bytes writable.</p>
]]></description>
          </param>
          <param id="p.memset.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Fill byte value; only the low 8 bits are used.</p>
]]></description>
          </param>
          <param id="p.memset.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to set.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Returns <code>s</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memset.zero_init" lang="c99">
            <title>Zero-initialize a buffer</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

void clear_bytes(void* p, size_t n) {
    memset(p, 0, n);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memcmp" name="memcmp" kind="function">
        <signature>int memcmp(const void* s1, const void* s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares the first <code>n</code> bytes of two buffers lexicographically as unsigned bytes.</p>
]]></summary>
        <parameters>
          <param id="p.memcmp.s1" name="s1" direction="in" type="const void*">
            <description><![CDATA[
<p>First buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcmp.s2" name="s2" direction="in" type="const void*">
            <description><![CDATA[
<p>Second buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0 if s1 &lt; s2, 0 if equal, greater than 0 if s1 &gt; s2 (based on the first differing byte).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.memcmp.not_string" severity="important" topic="semantics">
            <description><![CDATA[
<p><code>memcmp</code> is for counted buffers. It does not stop at NUL and is not a locale-aware string compare.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.memchr" name="memchr" kind="function">
        <signature>void* memchr(const void* s, int c, size_t n);</signature>
        <summary><![CDATA[
<p>Searches the first <code>n</code> bytes of <code>s</code> for the first occurrence of the byte <code>(unsigned char)c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.memchr.s" name="s" direction="in" type="const void*">
            <description><![CDATA[
<p>Buffer to search, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Target byte; only the low 8 bits are used.</p>
]]></description>
          </param>
          <param id="p.memchr.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to scan.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Pointer to the matching byte within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strlen" name="strlen" kind="function">
        <signature>size_t strlen(const char* s);</signature>
        <summary><![CDATA[
<p>Returns the length of the NUL-terminated byte string <code>s</code>, not including the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strlen.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string. Must contain a terminating NUL within accessible memory.</p>
]]></description>
            <constraints>
              <constraint id="c.strlen.must_terminate" severity="important">
                <description><![CDATA[
<p>If <code>s</code> is not properly terminated, <code>strlen</code> will read past bounds (undefined behavior).</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes before the first NUL.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strlen.performance" severity="info" topic="performance">
            <description><![CDATA[
<p>Repeated <code>strlen</code> calls on the same string are O(n) each. Cache the result if needed.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strcmp" name="strcmp" kind="function">
        <signature>int strcmp(const char* s1, const char* s2);</signature>
        <summary><![CDATA[
<p>Compares two NUL-terminated byte strings lexicographically using unsigned char ordering.</p>
]]></summary>
        <parameters>
          <param id="p.strcmp.s1" name="s1" direction="in" type="const char*">
            <description><![CDATA[
<p>First NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strcmp.s2" name="s2" direction="in" type="const char*">
            <description><![CDATA[
<p>Second NUL-terminated string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0 if s1 &lt; s2, 0 if equal, greater than 0 if s1 &gt; s2 (based on the first differing byte).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcmp.locale" severity="important" topic="collation">
            <description><![CDATA[
<p><code>strcmp</code> is byte-wise, not locale collation. For locale-aware ordering, use <code>strcoll</code> (not in this category list).</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncmp" name="strncmp" kind="function">
        <signature>int strncmp(const char* s1, const char* s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares up to <code>n</code> bytes of two NUL-terminated strings, stopping early if a NUL is reached.</p>
]]></summary>
        <parameters>
          <param id="p.strncmp.s1" name="s1" direction="in" type="const char*">
            <description><![CDATA[
<p>First NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncmp.s2" name="s2" direction="in" type="const char*">
            <description><![CDATA[
<p>Second NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 as with <code>strcmp</code>, but limited to at most <code>n</code> bytes.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strncmp.prefix" severity="info" topic="prefix-check">
            <description><![CDATA[
<p>
For prefix checks, ensure lengths match your intent. Example: <code>strncmp(s, "ab", 2) == 0</code> matches "ab" and "abc".
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strcpy" name="strcpy" kind="function">
        <signature>char* strcpy(char* dest, const char* src);</signature>
        <summary><![CDATA[
<p>Copies the NUL-terminated string <code>src</code> (including terminator) into <code>dest</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strcpy.dest" name="dest" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer, must be large enough for all of <code>src</code> plus the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.strcpy.src" name="src" direction="in" type="const char*">
            <description><![CDATA[
<p>Source NUL-terminated string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcpy.safety" severity="warning" topic="buffer-size">
            <description><![CDATA[
<p><code>strcpy</code> has no bounds parameter. Use only when you have a proven bound for <code>dest</code>.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncpy" name="strncpy" kind="function">
        <signature>char* strncpy(char* dest, const char* src, size_t n);</signature>
        <summary><![CDATA[
<p>
Copies up to <code>n</code> bytes from <code>src</code> into <code>dest</code>. If <code>src</code> is shorter than <code>n</code>,
pads <code>dest</code> with NUL bytes. If <code>src</code> is at least <code>n</code> bytes, no terminator is written.
</p>
]]></summary>
        <parameters>
          <param id="p.strncpy.dest" name="dest" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes writable.</p>
]]></description>
          </param>
          <param id="p.strncpy.src" name="src" direction="in" type="const char*">
            <description><![CDATA[
<p>Source NUL-terminated string (read stops at NUL or after <code>n</code> bytes, whichever comes first).</p>
]]></description>
          </param>
          <param id="p.strncpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to write to <code>dest</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.strncpy.no_termination" severity="important">
                <description><![CDATA[
<p>If <code>src</code> length is at least <code>n</code>, <code>dest</code> will not be NUL-terminated. Add a terminator yourself if required.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strncpy.safe_terminate" lang="c99">
            <title>Copy with explicit terminator</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

void copy_token(char* dst, size_t cap, const char* src) {
    if (cap == 0) return;

    /* Copy at most cap-1 bytes and always terminate. */
    strncpy(dst, src, cap - 1u);
    dst[cap - 1u] = '\0';
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strcat" name="strcat" kind="function">
        <signature>char* strcat(char* dest, const char* src);</signature>
        <summary><![CDATA[
<p>Appends the NUL-terminated string <code>src</code> to the end of <code>dest</code>, overwriting <code>dest</code>'s terminator and writing a new one.</p>
]]></summary>
        <parameters>
          <param id="p.strcat.dest" name="dest" direction="inout" type="char*">
            <description><![CDATA[
<p>Destination NUL-terminated string with enough free space to hold the result.</p>
]]></description>
          </param>
          <param id="p.strcat.src" name="src" direction="in" type="const char*">
            <description><![CDATA[
<p>Source NUL-terminated string to append.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcat.safety" severity="warning" topic="buffer-size">
            <description><![CDATA[
<p><code>strcat</code> has no bounds parameter. Use only with proven remaining capacity, or prefer a bounded approach using <code>strncat</code> plus explicit accounting.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncat" name="strncat" kind="function">
        <signature>char* strncat(char* dest, const char* src, size_t n);</signature>
        <summary><![CDATA[
<p>
Appends up to <code>n</code> bytes from <code>src</code> to <code>dest</code>, and then writes a terminating NUL.
Stops early if a NUL is encountered in <code>src</code>.
</p>
]]></summary>
        <parameters>
          <param id="p.strncat.dest" name="dest" direction="inout" type="char*">
            <description><![CDATA[
<p>Destination NUL-terminated string with space for the additional bytes plus one NUL terminator.</p>
]]></description>
          </param>
          <param id="p.strncat.src" name="src" direction="in" type="const char*">
            <description><![CDATA[
<p>Source NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncat.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to append from <code>src</code> (excluding the final NUL which is always written).</p>
]]></description>
            <constraints>
              <constraint id="c.strncat.capacity" severity="important">
                <description><![CDATA[
<p>
You must still ensure destination capacity: <code>strlen(dest) + min(strlen(src), n) + 1</code> bytes total.
</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strchr" name="strchr" kind="function">
        <signature>char* strchr(const char* s, int c);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of character <code>(char)c</code> in <code>s</code>, including possibly the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strchr.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character to find, converted to <code>char</code>. Use 0 to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the first match within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strrchr" name="strrchr" kind="function">
        <signature>char* strrchr(const char* s, int c);</signature>
        <summary><![CDATA[
<p>Finds the last occurrence of character <code>(char)c</code> in <code>s</code>, including possibly the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strrchr.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strrchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character to find, converted to <code>char</code>. Use 0 to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the last match within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strstr" name="strstr" kind="function">
        <signature>char* strstr(const char* haystack, const char* needle);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of substring <code>needle</code> within <code>haystack</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strstr.haystack" name="haystack" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strstr.needle" name="needle" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated substring to find. If empty, the result is <code>haystack</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the start of the first match within <code>haystack</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strstr.find_extension" lang="c99">
            <title>Find a file extension separator</title>
            <code><![CDATA[
#include <string.h>

const char* find_dot(const char* path) {
    /* Use strrchr for last '.', but strstr shown as substring search pattern. */
    return strrchr(path, '.');
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtok" name="strtok" kind="function">
        <signature>char* strtok(char* s, const char* delim);</signature>
        <summary><![CDATA[
<p>Tokenizes <code>s</code> by replacing delimiter characters with NUL and returning successive tokens across calls.</p>
]]></summary>
        <parameters>
          <param id="p.strtok.s" name="s" direction="inout" type="char*">
            <description><![CDATA[
<p>
String to tokenize on the first call, then NULL on subsequent calls to continue tokenizing the same string.
The buffer is modified in place.
</p>
]]></description>
          </param>
          <param id="p.strtok.delim" name="delim" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated set of delimiter characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the next token, or NULL when no tokens remain.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtok.modifies" severity="important" topic="input-mutated">
            <description><![CDATA[
<p><code>strtok</code> overwrites delimiters with NUL. If you need the original string, work on a copy.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strtok.split_csv_simple" lang="c99">
            <title>Split a simple comma-separated line in place</title>
            <code><![CDATA[
#include <string.h>
#include <stdio.h>

void print_fields(char* line) {
    /* line is modified in-place. */
    const char* delim = ",";

    char* tok = strtok(line, delim);
    while (tok != NULL) {
        puts(tok);
        tok = strtok(NULL, delim);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strspn" name="strspn" kind="function">
        <signature>size_t strspn(const char* s, const char* accept);</signature>
        <summary><![CDATA[
<p>Returns the length of the initial segment of <code>s</code> consisting only of bytes from <code>accept</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strspn.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to scan.</p>
]]></description>
          </param>
          <param id="p.strspn.accept" name="accept" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated set of accepted characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes in the initial accepted prefix.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strcspn" name="strcspn" kind="function">
        <signature>size_t strcspn(const char* s, const char* reject);</signature>
        <summary><![CDATA[
<p>Returns the length of the initial segment of <code>s</code> consisting of bytes not in <code>reject</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strcspn.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to scan.</p>
]]></description>
          </param>
          <param id="p.strcspn.reject" name="reject" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated set of rejected characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes in the initial segment containing no rejected characters.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strpbrk" name="strpbrk" kind="function">
        <signature>char* strpbrk(const char* s, const char* accept);</signature>
        <summary><![CDATA[
<p>Finds the first character in <code>s</code> that matches any character from <code>accept</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strpbrk.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strpbrk.accept" name="accept" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated set of accepted characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the first matching character in <code>s</code>, or NULL if none found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strerror" name="strerror" kind="function">
        <signature>char* strerror(int errnum);</signature>
        <summary><![CDATA[
<p>Returns a pointer to a human-readable message describing error number <code>errnum</code> (commonly values from <code>errno</code>).</p>
]]></summary>
        <parameters>
          <param id="p.strerror.errnum" name="errnum" direction="in" type="int">
            <description><![CDATA[
<p>Error code to describe (often <code>errno</code>).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to a NUL-terminated message string. The storage may be reused by subsequent calls.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strerror.storage" severity="important" topic="lifetime">
            <description><![CDATA[
<p>The returned pointer may refer to static storage that is overwritten by later calls. Copy it if you need to keep it.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strerror.format_errno" lang="c99">
            <title>Format errno for logging</title>
            <code><![CDATA[
#include <string.h>
#include <errno.h>
#include <stdio.h>

void log_errno(const char* where) {
    int e = errno;
    /* Copy if you need to keep the message beyond this point. */
    printf("%s: errno=%d (%s)\n", where, e, strerror(e));
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.warnings.missing_entries" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category list intentionally includes only the functions you specified from <code>string.h</code>.
Other standard functions also exist in <code>string.h</code> (for example <code>strcoll</code>, <code>strxfrm</code>), but they are not included here.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.wchar" name="wchar.h">
      <summary><![CDATA[
<p>
Wide character and wide string operations, plus multibyte to wide conversion utilities and wide formatted output helpers.
Use these when your program processes wide strings (<code>wchar_t</code>) and when you need locale-aware multibyte decoding.
</p>
<p>
Conversion functions use an explicit <code>mbstate_t</code> state object to support stateful encodings.
When in doubt, initialize a state to zero and reuse it consistently for a stream.
</p>
]]></summary>

      <notes>
        <note id="n.wchar.shared.termination" severity="important" topic="nul-termination">
          <description><![CDATA[
<p>
The <code>wcs*</code> string functions expect NUL-terminated wide strings.
The <code>wmem*</code> functions operate on counted wide buffers and do not require a terminator.
</p>
]]></description>
        </note>
        <note id="n.wchar.shared.overlap" severity="important" topic="overlap">
          <description><![CDATA[
<p>
Overlapping copy: use <code>wmemmove</code>. Using <code>wmemcpy</code> with overlap is undefined behavior.
</p>
]]></description>
        </note>
        <note id="n.wchar.shared.mbstate" severity="important" topic="mbstate_t">
          <description><![CDATA[
<p>
For multibyte conversions, pass a valid <code>mbstate_t *</code>. A zero-initialized state represents the initial shift state.
Using a consistent state object is critical for stateful encodings.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.wcslen" name="wcslen" kind="function">
        <signature>size_t wcslen(const wchar_t* s);</signature>
        <summary><![CDATA[
<p>Returns the length of NUL-terminated wide string <code>s</code>, not including the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcslen.s" name="s" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated wide string. Must contain a terminator within accessible memory.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of wide characters before the first wide NUL.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscmp" name="wcscmp" kind="function">
        <signature>int wcscmp(const wchar_t* s1, const wchar_t* s2);</signature>
        <summary><![CDATA[
<p>Compares two NUL-terminated wide strings lexicographically (code unit order, not locale collation).</p>
]]></summary>
        <parameters>
          <param id="p.wcscmp.s1" name="s1" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcscmp.s2" name="s2" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 based on the first differing wide character.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncmp" name="wcsncmp" kind="function">
        <signature>int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares up to <code>n</code> wide characters of two wide strings, stopping early at a wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcsncmp.s1" name="s1" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncmp.s2" name="s2" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0, limited to at most <code>n</code> wide characters.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscpy" name="wcscpy" kind="function">
        <signature>wchar_t* wcscpy(wchar_t* dest, const wchar_t* src);</signature>
        <summary><![CDATA[
<p>Copies the wide string <code>src</code> (including terminator) into <code>dest</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcscpy.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer, must have enough space for all of <code>src</code> plus the terminating wide NUL.</p>
]]></description>
          </param>
          <param id="p.wcscpy.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncpy" name="wcsncpy" kind="function">
        <signature>wchar_t* wcsncpy(wchar_t* dest, const wchar_t* src, size_t n);</signature>
        <summary><![CDATA[
<p>
Copies up to <code>n</code> wide characters from <code>src</code> into <code>dest</code>. Pads with wide NULs if <code>src</code> is shorter.
If <code>src</code> length is at least <code>n</code>, no terminator is written.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsncpy.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> writable wide characters.</p>
]]></description>
          </param>
          <param id="p.wcsncpy.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to write.</p>
]]></description>
            <constraints>
              <constraint id="c.wcsncpy.no_termination" severity="important">
                <description><![CDATA[
<p>If <code>src</code> is at least <code>n</code> wide characters long, <code>dest</code> is not terminated. Add a terminator if required.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscat" name="wcscat" kind="function">
        <signature>wchar_t* wcscat(wchar_t* dest, const wchar_t* src);</signature>
        <summary><![CDATA[
<p>Appends wide string <code>src</code> to <code>dest</code>, writing a new terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcscat.dest" name="dest" direction="inout" type="wchar_t*">
            <description><![CDATA[
<p>Destination NUL-terminated wide string with enough free capacity.</p>
]]></description>
          </param>
          <param id="p.wcscat.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source NUL-terminated wide string to append.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncat" name="wcsncat" kind="function">
        <signature>wchar_t* wcsncat(wchar_t* dest, const wchar_t* src, size_t n);</signature>
        <summary><![CDATA[
<p>
Appends up to <code>n</code> wide characters from <code>src</code> to <code>dest</code>, then terminates with a wide NUL.
Stops early if a wide NUL occurs in <code>src</code>.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsncat.dest" name="dest" direction="inout" type="wchar_t*">
            <description><![CDATA[
<p>Destination NUL-terminated wide string with enough capacity for appended data plus terminator.</p>
]]></description>
          </param>
          <param id="p.wcsncat.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncat.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to append (excluding the final terminator).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcschr" name="wcschr" kind="function">
        <signature>wchar_t* wcschr(const wchar_t* s, wchar_t c);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of wide character <code>c</code> in <code>s</code>, including possibly the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcschr.s" name="s" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcschr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to find. Use L'\0' to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Pointer to first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsrchr" name="wcsrchr" kind="function">
        <signature>wchar_t* wcsrchr(const wchar_t* s, wchar_t c);</signature>
        <summary><![CDATA[
<p>Finds the last occurrence of wide character <code>c</code> in <code>s</code>, including possibly the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcsrchr.s" name="s" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcsrchr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to find.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Pointer to last match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsstr" name="wcsstr" kind="function">
        <signature>wchar_t* wcsstr(const wchar_t* haystack, const wchar_t* needle);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of substring <code>needle</code> within <code>haystack</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcsstr.haystack" name="haystack" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcsstr.needle" name="needle" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated wide substring to find. If empty, the result is <code>haystack</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Pointer to first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcstok" name="wcstok" kind="function">
        <signature>wchar_t* wcstok(wchar_t* s, const wchar_t* delim, wchar_t**ptr);</signature>
        <summary><![CDATA[
<p>
Tokenizes a wide string in place. Unlike <code>strtok</code>, <code>wcstok</code> uses an explicit state pointer <code>ptr</code>,
making the state caller-managed.
</p>
]]></summary>
        <parameters>
          <param id="p.wcstok.s" name="s" direction="inout" type="wchar_t*">
            <description><![CDATA[
<p>String to tokenize on first call, then NULL to continue.</p>
]]></description>
          </param>
          <param id="p.wcstok.delim" name="delim" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>NUL-terminated set of delimiter wide characters.</p>
]]></description>
          </param>
          <param id="p.wcstok.ptr" name="ptr" direction="inout" type="wchar_t**">
            <description><![CDATA[
<p>Caller-managed tokenizer state. Must point to a <code>wchar_t* </code> variable that persists across calls.</p>
]]></description>
            <constraints>
              <constraint id="c.wcstok.ptr_required" severity="important">
                <description><![CDATA[
<p><code>ptr</code> must not be NULL. It carries the scan position between calls.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Pointer to next token, or NULL when no tokens remain.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.wcstok.split" lang="c99">
            <title>Split a wide string with explicit state</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdio.h>

void print_wfields(wchar_t* line) {
    wchar_t* state = NULL;
    const wchar_t* delim = L",";

    wchar_t* tok = wcstok(line, delim, &state);
    while (tok != NULL) {
        /* Print using wide I/O if desired; here just show call shape. */
        /* wprintf(L"%ls\n", tok); */
        tok = wcstok(NULL, delim, &state);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wcsxfrm" name="wcsxfrm" kind="function">
        <signature>size_t wcsxfrm(wchar_t* dest, const wchar_t* src, size_t n);</signature>
        <summary><![CDATA[
<p>
Transforms <code>src</code> into a form suitable for locale-aware comparison using <code>wcscoll</code>-like ordering.
The transformed sequence is placed into <code>dest</code> if <code>n</code> permits.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsxfrm.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer for the transformed form. May be NULL if <code>n</code> is 0 to query required length.</p>
]]></description>
          </param>
          <param id="p.wcsxfrm.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source NUL-terminated wide string to transform.</p>
]]></description>
          </param>
          <param id="p.wcsxfrm.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to write to <code>dest</code>, including the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns the length of the transformed string (not including terminator). If return value is at least <code>n</code>,
the output was truncated and you should allocate a larger buffer.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscoll" name="wcscoll" kind="function">
        <signature>int wcscoll(const wchar_t* s1, const wchar_t* s2);</signature>
        <summary><![CDATA[
<p>Compares two wide strings using the current locale collation order (unlike <code>wcscmp</code> which is code unit order).</p>
]]></summary>
        <parameters>
          <param id="p.wcscoll.s1" name="s1" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcscoll.s2" name="s2" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 depending on locale collation order.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.wcscoll.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Collation depends on the active locale (typically <code>LC_COLLATE</code>).</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wmemcpy" name="wmemcpy" kind="function">
        <signature>wchar_t* wmemcpy(wchar_t* dest, const wchar_t* src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> wide characters from <code>src</code> to <code>dest</code>. Regions must not overlap.</p>
]]></summary>
        <parameters>
          <param id="p.wmemcpy.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> wide characters writable.</p>
]]></description>
          </param>
          <param id="p.wmemcpy.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source buffer with at least <code>n</code> wide characters readable.</p>
]]></description>
          </param>
          <param id="p.wmemcpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to copy.</p>
]]></description>
            <constraints>
              <constraint id="c.wmemcpy.no_overlap" severity="important">
                <description><![CDATA[
<p>Buffers must not overlap. Use <code>wmemmove</code> if overlap is possible.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemmove" name="wmemmove" kind="function">
        <signature>wchar_t* wmemmove(wchar_t* dest, const wchar_t* src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> wide characters from <code>src</code> to <code>dest</code>. Regions may overlap.</p>
]]></summary>
        <parameters>
          <param id="p.wmemmove.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> wide characters writable.</p>
]]></description>
          </param>
          <param id="p.wmemmove.src" name="src" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Source buffer with at least <code>n</code> wide characters readable.</p>
]]></description>
          </param>
          <param id="p.wmemmove.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to move.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemset" name="wmemset" kind="function">
        <signature>wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);</signature>
        <summary><![CDATA[
<p>Sets the first <code>n</code> wide characters of <code>s</code> to <code>c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wmemset.s" name="s" direction="inout" type="wchar_t*">
            <description><![CDATA[
<p>Buffer to fill, must be writable for <code>n</code> wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemset.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Fill wide character value.</p>
]]></description>
          </param>
          <param id="p.wmemset.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to set.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>s</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemcmp" name="wmemcmp" kind="function">
        <signature>int wmemcmp(const wchar_t* s1, const wchar_t* s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares the first <code>n</code> wide characters of two buffers.</p>
]]></summary>
        <parameters>
          <param id="p.wmemcmp.s1" name="s1" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>First buffer with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemcmp.s2" name="s2" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Second buffer with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemcmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 based on the first differing wide character.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemchr" name="wmemchr" kind="function">
        <signature>wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);</signature>
        <summary><![CDATA[
<p>Searches the first <code>n</code> wide characters of <code>s</code> for the first occurrence of <code>c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wmemchr.s" name="s" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Buffer to search, with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemchr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Target wide character.</p>
]]></description>
          </param>
          <param id="p.wmemchr.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to scan.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Pointer to the first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.btowc" name="btowc" kind="function">
        <signature>wint_t btowc(int c);</signature>
        <summary><![CDATA[
<p>Converts a single byte <code>c</code> to a wide character if possible in the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.btowc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to convert, typically <code>EOF</code> or an unsigned byte value (0..UCHAR_MAX).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Converted wide character, or <code>WEOF</code> if <code>c</code> is <code>EOF</code> or not convertible as a single byte.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wctob" name="wctob" kind="function">
        <signature>int wctob(wint_t c);</signature>
        <summary><![CDATA[
<p>Converts a wide character <code>c</code> to a single byte if representable as a single-byte character in the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.wctob.c" name="c" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character to convert, or <code>WEOF</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Converted unsigned byte value (as an <code>unsigned char</code> promoted to int), or <code>EOF</code> if not representable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbrlen" name="mbrlen" kind="function">
        <signature>size_t mbrlen(const char* s, size_t n, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Determines the number of bytes that make up the next multibyte character in <code>s</code>, using conversion state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.mbrlen.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>Pointer to bytes to examine, or NULL to reset/query the shift state (implementation-defined behavior but widely used as reset).</p>
]]></description>
          </param>
          <param id="p.mbrlen.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes available at <code>s</code>.</p>
]]></description>
          </param>
          <param id="p.mbrlen.ps" name="ps" direction="inout" type="mbstate_t*">
            <description><![CDATA[
<p>Pointer to conversion state object. If NULL, an internal static state may be used.</p>
]]></description>
            <constraints>
              <constraint id="c.mbrlen.state" severity="important">
                <description><![CDATA[
<p>Prefer a caller-owned <code>mbstate_t</code> to avoid hidden shared state and to support stream decoding safely.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns number of bytes for the next character; 0 if the next character is the terminating NUL; (size_t)-1 on encoding error;
(size_t)-2 if the next character is incomplete with the given <code>n</code>.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbrtowc" name="mbrtowc" kind="function">
        <signature>size_t mbrtowc(wchar_t* pwc, const char* s, size_t n, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Converts the next multibyte character from <code>s</code> to a wide character stored in <code>*pwc</code>, using state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.mbrtowc.pwc" name="pwc" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Output location for the converted wide character. May be NULL if you only want to advance state/validate.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>Pointer to bytes to convert, or NULL to reset the shift state.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes available at <code>s</code>.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.ps" name="ps" direction="inout" type="mbstate_t*">
            <description><![CDATA[
<p>Pointer to conversion state. If NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns number of bytes consumed; 0 if converted character is wide NUL; (size_t)-1 on encoding error; (size_t)-2 if incomplete.
</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.mbrtowc.stream_decode" lang="c99">
            <title>Decode a multibyte buffer into wide characters with explicit state</title>
            <code><![CDATA[
#include <wchar.h>
#include <stddef.h>

size_t decode_some(const char* in, size_t in_len, wchar_t* out, size_t out_cap) {
    mbstate_t st;
    /* Zero-initialize conversion state. */
    st = (mbstate_t){0};

    size_t i = 0;
    size_t o = 0;

    while (i < in_len && o < out_cap) {
        wchar_t wc = 0;
        size_t r = mbrtowc(&wc, in + i, in_len - i, &st);

        if (r == (size_t)-1) {
            /* Encoding error. */
            break;
        }
        if (r == (size_t)-2) {
            /* Incomplete character at end of buffer. */
            break;
        }
        if (r == 0) {
            /* Reached terminating NUL. */
            out[o++] = L'\0';
            break;
        }

        out[o++] = wc;
        i += r;
    }

    return o;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wcrtomb" name="wcrtomb" kind="function">
        <signature>size_t wcrtomb(char* s, wchar_t wc, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Converts wide character <code>wc</code> to its multibyte sequence, writing into <code>s</code>, using state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcrtomb.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer for the multibyte sequence. Must have enough space for at least <code>MB_CUR_MAX</code> bytes. If NULL, resets state.</p>
]]></description>
          </param>
          <param id="p.wcrtomb.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to convert.</p>
]]></description>
          </param>
          <param id="p.wcrtomb.ps" name="ps" direction="inout" type="mbstate_t*">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes written; (size_t)-1 on encoding error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbsrtowcs" name="mbsrtowcs" kind="function">
        <signature>size_t mbsrtowcs(wchar_t* dest, const char**src, size_t len, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>
Converts a multibyte string starting at <code>*src</code> into wide characters. Updates <code>*src</code> as input is consumed.
Stops after converting a terminating NUL or after producing <code>len</code> wide characters.
</p>
]]></summary>
        <parameters>
          <param id="p.mbsrtowcs.dest" name="dest" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination buffer for wide characters. May be NULL to query required length.</p>
]]></description>
          </param>
          <param id="p.mbsrtowcs.src" name="src" direction="inout" type="const char**">
            <description><![CDATA[
<p>
Pointer to the input pointer. On success, updated to point after the last converted byte, or set to NULL if the terminator was converted.
</p>
]]></description>
            <constraints>
              <constraint id="c.mbsrtowcs.src_nonnull" severity="important">
                <description><![CDATA[
<p><code>src</code> must not be NULL, and <code>*src</code> must point to a valid NUL-terminated multibyte string.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.mbsrtowcs.len" name="len" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to store in <code>dest</code>.</p>
]]></description>
          </param>
          <param id="p.mbsrtowcs.ps" name="ps" direction="inout" type="mbstate_t*">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Number of wide characters written (excluding the terminating wide NUL). Returns (size_t)-1 on encoding error.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsrtombs" name="wcsrtombs" kind="function">
        <signature>size_t wcsrtombs(char* dest, const wchar_t**src, size_t len, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>
Converts a wide string starting at <code>*src</code> into multibyte characters. Updates <code>*src</code> as input is consumed.
Stops after converting the terminating wide NUL or after producing <code>len</code> bytes.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsrtombs.dest" name="dest" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer for multibyte bytes. May be NULL to query required length.</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.src" name="src" direction="inout" type="const wchar_t**">
            <description><![CDATA[
<p>
Pointer to the wide input pointer. On success, updated similarly to <code>mbsrtowcs</code>, potentially set to NULL when terminator is converted.
</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.len" name="len" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to store in <code>dest</code>.</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.ps" name="ps" direction="inout" type="mbstate_t*">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Number of bytes written (excluding the terminating NUL). Returns (size_t)-1 on encoding error.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.swprintf" name="swprintf" kind="function">
        <signature>int swprintf(wchar_t* s, size_t n, const wchar_t* format, ...);</signature>
        <summary><![CDATA[
<p>Formats wide output according to <code>format</code> and writes into <code>s</code>, writing at most <code>n</code> wide characters including terminator.</p>
]]></summary>
        <parameters>
          <param id="p.swprintf.s" name="s" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination wide buffer.</p>
]]></description>
          </param>
          <param id="p.swprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in wide characters, including space for the terminating wide NUL.</p>
]]></description>
            <constraints>
              <constraint id="c.swprintf.capacity" severity="important">
                <description><![CDATA[
<p>Always pass the true buffer capacity. Do not guess. This is your primary safety guarantee.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.swprintf.format" name="format" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Wide format string (printf-style). Must be NUL-terminated.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of wide characters written (excluding terminator), or a negative value on encoding/formatting error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.swprintf.format_path" lang="c99">
            <title>Build a wide string with bounded formatting</title>
            <code><![CDATA[
#include <wchar.h>

int build_message(wchar_t* buf, size_t cap, int code) {
    /* cap is in wide characters, not bytes. */
    return swprintf(buf, cap, L"status=%d", code);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.vswprintf" name="vswprintf" kind="function">
        <signature>int vswprintf(wchar_t* s, size_t n, const wchar_t* format, va_list arg);</signature>
        <summary><![CDATA[
<p>Variadic-list form of <code>swprintf</code>, writing formatted wide output into <code>s</code> with capacity <code>n</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vswprintf.s" name="s" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination wide buffer.</p>
]]></description>
          </param>
          <param id="p.vswprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in wide characters, including terminator.</p>
]]></description>
          </param>
          <param id="p.vswprintf.format" name="format" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Wide format string.</p>
]]></description>
          </param>
          <param id="p.vswprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list created with <code>va_start</code> by the caller.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of wide characters written (excluding terminator), or a negative value on error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.vswprintf.wrap" lang="c99">
            <title>Wrapper that formats from a va_list</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdarg.h>

int wfmt(wchar_t* buf, size_t cap, const wchar_t* fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    int r = vswprintf(buf, cap, fmt, ap);
    va_end(ap);
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wchar.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category list intentionally includes only the wide-string and conversion functions you specified from <code>wchar.h</code>.
Wide I/O functions (for example <code>fgetwc</code>, <code>fputwc</code>) are part of a separate I/O category.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-20T16-13-11-b1c0987c-1854-4b44-bf88-047f60a8b43e" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="io.file.console" name="File and console input-output (byte and wide)">
    <summary><![CDATA[
<p>
Standard I/O for files and streams: opening/closing, buffered reads and writes, seeking, temporary files, buffering control,
formatted I/O, and basic console helpers. The wide I/O subset provides the analogous operations for wide characters and wide strings.
</p>
<p>
Use these APIs for portable file and console I/O. Prefer bounded operations where available (for example <code>snprintf</code>,
explicit buffer sizes, and checked return values). Treat all I/O as fallible: check for NULL pointers, EOF, short reads/writes,
and error returns. Be explicit about text vs binary modes when portability matters (for example, use "rb"/"wb" on platforms where
they differ).
</p>
]]></summary>

    <keywords>
      <kw>stdio</kw>
      <kw>FILE</kw>
      <kw>stream</kw>
      <kw>buffering</kw>
      <kw>fopen</kw>
      <kw>fread</kw>
      <kw>fwrite</kw>
      <kw>fgets</kw>
      <kw>printf</kw>
      <kw>snprintf</kw>
      <kw>tmpfile</kw>
      <kw>seek</kw>
      <kw>wide</kw>
      <kw>wchar</kw>
    </keywords>

    <notes>
      <note id="n.io.text_vs_binary" severity="important" topic="portability">
        <description><![CDATA[
<p>
On some platforms, text and binary modes differ (for example newline translation). Use "rb"/"wb" if you need byte-exact behavior.
</p>
]]></description>
      </note>
      <note id="n.io.buffering" severity="important" topic="buffering">
        <description><![CDATA[
<p>
Most streams are buffered. Output may not appear until a flush, newline, buffer fill, or close. Use <code>fflush</code> to force output.
</p>
]]></description>
      </note>
      <note id="n.io.errors" severity="important" topic="error_handling">
        <description><![CDATA[
<p>
Many functions signal failure via NULL, EOF, or a negative value. Always check return values. For diagnosing errors, the
<code>errno</code> value is commonly set and <code>perror</code> can print a message based on it.
</p>
]]></description>
      </note>
      <note id="n.io.partial_io" severity="important" topic="short_reads_writes">
        <description><![CDATA[
<p>
Short reads and short writes are normal for many streams. <code>fread</code> and <code>fwrite</code> return counts and may be less than requested.
You must loop if you require "all bytes" semantics.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.stdio" name="stdio.h">
      <summary><![CDATA[
<p>
Byte-oriented stream I/O based on <code>FILE* </code> streams. Includes file operations, buffering control, formatted output,
and basic character and line I/O.
</p>
]]></summary>

      <function id="fn.fopen" name="fopen" kind="function">
        <signature>FILE* fopen(const char* filename, const char* mode);</signature>
        <summary><![CDATA[
<p>Opens a file and returns a stream handle, or NULL on failure.</p>
]]></summary>
        <parameters>
          <param id="p.fopen.filename" name="filename" direction="in" type="const char*">
            <description><![CDATA[
<p>Path to the file to open. Must be a NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.fopen.mode" name="mode" direction="in" type="const char*">
            <description><![CDATA[
<p>
Open mode string, such as "r", "w", "a", optionally with "+" and optionally with "b" (for example "rb", "w+b").
Mode details are defined by the C standard with some implementation-defined extensions.
</p>
]]></description>
            <constraints>
              <constraint id="c.fopen.mode_valid" severity="important">
                <description><![CDATA[
<p>Pass a valid mode string. If you need byte-exact I/O portability, include "b" where supported.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="FILE*">
            <description><![CDATA[
<p>Stream pointer on success, NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fopen.read_all_bytes" lang="c99">
            <title>Open in binary mode and read entire file into memory</title>
            <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>

unsigned char* read_entire_file(const char* path, size_t* out_size) {
    *out_size = 0;

    FILE* f = fopen(path, "rb");
    if (!f) return NULL;

    if (fseek(f, 0, SEEK_END) != 0) {
        fclose(f);
        return NULL;
    }

    long end = ftell(f);
    if (end < 0) {
        fclose(f);
        return NULL;
    }
    if (fseek(f, 0, SEEK_SET) != 0) {
        fclose(f);
        return NULL;
    }

    size_t n = (size_t)end;
    unsigned char* buf = (unsigned char*)malloc(n ? n : 1u);
    if (!buf) {
        fclose(f);
        return NULL;
    }

    size_t got = fread(buf, 1u, n, f);
    if (got != n) {
        free(buf);
        fclose(f);
        return NULL;
    }

    fclose(f);
    *out_size = n;
    return buf;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fclose" name="fclose" kind="function">
        <signature>int fclose(FILE* stream);</signature>
        <summary><![CDATA[
<p>Flushes and closes a stream. After this call, <code>stream</code> must not be used.</p>
]]></summary>
        <parameters>
          <param id="p.fclose.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Open stream pointer. Passing NULL is invalid.</p>
]]></description>
            <constraints>
              <constraint id="c.fclose.nonnull" severity="important">
                <description><![CDATA[
<p><code>stream</code> must be a valid open stream pointer.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, EOF on failure (for example if a flush fails).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fclose.failure" severity="important" topic="write_errors">
            <description><![CDATA[
<p>On output streams, check <code>fclose</code> return value because buffered data may fail to flush at close time.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fflush" name="fflush" kind="function">
        <signature>int fflush(FILE* stream);</signature>
        <summary><![CDATA[
<p>Flushes buffered output for <code>stream</code>. If <code>stream</code> is NULL, flushes all open output streams.</p>
]]></summary>
        <parameters>
          <param id="p.fflush.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream to flush, or NULL to flush all output streams.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, EOF on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fflush.input" severity="info" topic="input_streams">
            <description><![CDATA[
<p>Flushing input streams has implementation-defined behavior. Use <code>fflush</code> primarily for output streams.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fread" name="fread" kind="function">
        <signature>size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);</signature>
        <summary><![CDATA[
<p>Reads up to <code>nmemb</code> items of size <code>size</code> into <code>ptr</code> from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fread.ptr" name="ptr" direction="out" type="void*">
            <description><![CDATA[
<p>Destination buffer with room for <code>size * nmemb</code> bytes.</p>
]]></description>
          </param>
          <param id="p.fread.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Item size in bytes. If 0, no bytes are read and 0 is returned.</p>
]]></description>
          </param>
          <param id="p.fread.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of items to read. If 0, no bytes are read and 0 is returned.</p>
]]></description>
            <constraints>
              <constraint id="c.fread.overflow" severity="important">
                <description><![CDATA[
<p>Ensure <code>size * nmemb</code> does not overflow and matches the destination capacity.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fread.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of items successfully read (not bytes). If less than <code>nmemb</code>, either EOF occurred or an error occurred.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fread.loop_exact" lang="c99">
            <title>Read exactly N bytes by looping</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int read_exact(FILE* f, void* buf, size_t n) {
    unsigned char* p = (unsigned char*)buf;
    size_t off = 0;

    while (off < n) {
        size_t got = fread(p + off, 1u, n - off, f);
        if (got == 0) {
            /* EOF or error; caller can consult errno or other diagnostics if desired. */
            return 0;
        }
        off += got;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fwrite" name="fwrite" kind="function">
        <signature>size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream);</signature>
        <summary><![CDATA[
<p>Writes up to <code>nmemb</code> items of size <code>size</code> from <code>ptr</code> to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fwrite.ptr" name="ptr" direction="in" type="const void*">
            <description><![CDATA[
<p>Source buffer containing <code>size * nmemb</code> bytes.</p>
]]></description>
          </param>
          <param id="p.fwrite.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Item size in bytes. If 0, no bytes are written and 0 is returned.</p>
]]></description>
          </param>
          <param id="p.fwrite.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of items to write. If 0, no bytes are written and 0 is returned.</p>
]]></description>
            <constraints>
              <constraint id="c.fwrite.overflow" severity="important">
                <description><![CDATA[
<p>Ensure <code>size * nmemb</code> does not overflow and reflects the actual buffer size.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fwrite.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of items successfully written. If less than <code>nmemb</code>, an error occurred.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fwrite.loop_exact" lang="c99">
            <title>Write exactly N bytes by looping and flushing at the end</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int write_exact(FILE* f, const void* buf, size_t n) {
    const unsigned char* p = (const unsigned char*)buf;
    size_t off = 0;

    while (off < n) {
        size_t put = fwrite(p + off, 1u, n - off, f);
        if (put == 0) {
            return 0;
        }
        off += put;
    }

    /* Optional: force output now rather than later. */
    if (fflush(f) == EOF) {
        return 0;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fseek" name="fseek" kind="function">
        <signature>int fseek(FILE* stream, long offset, int whence);</signature>
        <summary><![CDATA[
<p>Moves the file position indicator for <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fseek.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream to seek.</p>
]]></description>
          </param>
          <param id="p.fseek.offset" name="offset" direction="in" type="long">
            <description><![CDATA[
<p>Offset in bytes relative to <code>whence</code>.</p>
]]></description>
          </param>
          <param id="p.fseek.whence" name="whence" direction="in" type="int">
            <description><![CDATA[
<p>One of <code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fseek.text_streams" severity="info" topic="text_streams">
            <description><![CDATA[
<p>
Seeking in text streams can have restrictions on some platforms. For portable random access, prefer binary mode where appropriate.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.ftell" name="ftell" kind="function">
        <signature>long ftell(FILE* stream);</signature>
        <summary><![CDATA[
<p>Returns the current file position indicator for <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ftell.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream to query.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Current position as a <code>long</code>, or -1L on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ftell.limit" severity="info" topic="large_files">
            <description><![CDATA[
<p>
Because the return type is <code>long</code>, very large file offsets may not be representable on some platforms.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.rewind" name="rewind" kind="function">
        <signature>void rewind(FILE* stream);</signature>
        <summary><![CDATA[
<p>Sets the file position to the beginning of the stream and clears error indicators.</p>
]]></summary>
        <parameters>
          <param id="p.rewind.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream to rewind.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value. If you need error reporting, use <code>fseek(stream, 0, SEEK_SET)</code> and check the result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.remove" name="remove" kind="function">
        <signature>int remove(const char* filename);</signature>
        <summary><![CDATA[
<p>Deletes the named file (or removes a directory where supported by the implementation).</p>
]]></summary>
        <parameters>
          <param id="p.remove.filename" name="filename" direction="in" type="const char*">
            <description><![CDATA[
<p>Path to remove.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rename" name="rename" kind="function">
        <signature>int rename(const char* oldname, const char* newname);</signature>
        <summary><![CDATA[
<p>Renames a file. Semantics around overwriting and cross-filesystem moves are implementation-defined.</p>
]]></summary>
        <parameters>
          <param id="p.rename.oldname" name="oldname" direction="in" type="const char*">
            <description><![CDATA[
<p>Existing path.</p>
]]></description>
          </param>
          <param id="p.rename.newname" name="newname" direction="in" type="const char*">
            <description><![CDATA[
<p>New path.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.rename.atomicity" severity="info" topic="atomicity">
            <description><![CDATA[
<p>
Atomicity is not guaranteed by the C standard. If you need atomic replace semantics, document platform expectations explicitly.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.tmpfile" name="tmpfile" kind="function">
        <signature>FILE* tmpfile(void);</signature>
        <summary><![CDATA[
<p>Creates a temporary binary file opened for update ("wb+"). The file is removed automatically when closed.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="FILE*">
            <description><![CDATA[
<p>Stream pointer on success, NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.tmpfile.spool" lang="c99">
            <title>Spool data to a temporary file and then read it back</title>
            <code><![CDATA[
#include <stdio.h>
#include <string.h>

int roundtrip_temp(void) {
    FILE* t = tmpfile();
    if (!t) return 0;

    const char msg[] = "hello\n";
    if (fwrite(msg, 1u, sizeof(msg) - 1u, t) != sizeof(msg) - 1u) {
        fclose(t);
        return 0;
    }

    rewind(t);

    char buf[16];
    if (!fgets(buf, (int)sizeof(buf), t)) {
        fclose(t);
        return 0;
    }

    fclose(t);
    return (strcmp(buf, "hello\n") == 0) ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.tmpnam" name="tmpnam" kind="function">
        <signature>char* tmpnam(char* s);</signature>
        <summary><![CDATA[
<p>Generates a name for a temporary file. The result is a string; the file is not created.</p>
]]></summary>
        <parameters>
          <param id="p.tmpnam.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Optional destination buffer (at least <code>L_tmpnam</code> bytes). If NULL, returns a pointer to internal static storage.</p>
]]></description>
            <constraints>
              <constraint id="c.tmpnam.race" severity="warning">
                <description><![CDATA[
<p>
Temporary name generation without creating the file is inherently vulnerable to race conditions. Prefer <code>tmpfile</code> when possible.
</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the generated name (either <code>s</code> or internal storage), or NULL on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.setvbuf" name="setvbuf" kind="function">
        <signature>int setvbuf(FILE* stream, char* buf, int mode, size_t size);</signature>
        <summary><![CDATA[
<p>Controls buffering for a stream. Must be called before I/O on the stream (other than possible initial open operations).</p>
]]></summary>
        <parameters>
          <param id="p.setvbuf.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream whose buffering behavior is to be configured.</p>
]]></description>
          </param>
          <param id="p.setvbuf.buf" name="buf" direction="in" type="char*">
            <description><![CDATA[
<p>
User-provided buffer, or NULL to have the implementation allocate one. If provided, it must remain valid until buffering is changed again or the stream is closed.
</p>
]]></description>
          </param>
          <param id="p.setvbuf.mode" name="mode" direction="in" type="int">
            <description><![CDATA[
<p>One of <code>_IOFBF</code> (full), <code>_IOLBF</code> (line), <code>_IONBF</code> (none).</p>
]]></description>
          </param>
          <param id="p.setvbuf.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Buffer size in bytes (meaningful for buffered modes).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.setvbuf.timing" severity="important" topic="when_to_call">
            <description><![CDATA[
<p>Call <code>setvbuf</code> immediately after opening a stream, before any reads or writes, to avoid implementation-defined behavior.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.setvbuf.line_buffer_stdout" lang="c99">
            <title>Force line buffering for stdout when writing to a console</title>
            <code><![CDATA[
#include <stdio.h>

void configure_stdout(void) {
    /* If this fails, program can still proceed with default buffering. */
    (void)setvbuf(stdout, NULL, _IOLBF, 0);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.setbuf" name="setbuf" kind="function">
        <signature>void setbuf(FILE* stream, char* buf);</signature>
        <summary><![CDATA[
<p>Legacy buffering helper: equivalent to <code>setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ)</code>.</p>
]]></summary>
        <parameters>
          <param id="p.setbuf.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Stream to configure.</p>
]]></description>
          </param>
          <param id="p.setbuf.buf" name="buf" direction="in" type="char*">
            <description><![CDATA[
<p>User buffer of at least <code>BUFSIZ</code> bytes, or NULL to disable buffering.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value. Use <code>setvbuf</code> if you need error reporting or precise control.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fprintf" name="fprintf" kind="function">
        <signature>int fprintf(FILE* stream, const char* format, ...);</signature>
        <summary><![CDATA[
<p>Writes formatted output to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fprintf.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
          <param id="p.fprintf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string. Must be NUL-terminated.</p>
]]></description>
            <constraints>
              <constraint id="c.printf.format_security" severity="important">
                <description><![CDATA[
<p>Never pass untrusted input as the format string. Use a fixed format and pass untrusted data as arguments.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of characters printed, or a negative value on output error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.printf" name="printf" kind="function">
        <signature>int printf(const char* format, ...);</signature>
        <summary><![CDATA[
<p>Writes formatted output to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.printf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of characters printed, or a negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.snprintf" name="snprintf" kind="function">
        <signature>int snprintf(char* s, size_t n, const char* format, ...);</signature>
        <summary><![CDATA[
<p>Formats into a byte buffer of capacity <code>n</code>, ensuring at most <code>n</code> bytes are written including the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.snprintf.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer. May be NULL if <code>n</code> is 0 to query required size.</p>
]]></description>
          </param>
          <param id="p.snprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in bytes, including space for the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.snprintf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>
Number of characters that would have been written excluding the terminating NUL. If the return value is at least <code>n</code>,
output was truncated. A negative value indicates an encoding or output error.
</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.snprintf.safe_build" lang="c99">
            <title>Build a message with truncation detection</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int build_msg(char* buf, size_t cap, const char* name, int code) {
    int r = snprintf(buf, cap, "name=%s code=%d", name, code);
    if (r < 0) return 0;
    if ((size_t)r >= cap) {
        /* Truncated. Caller can allocate more if needed. */
        return 0;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.vfprintf" name="vfprintf" kind="function">
        <signature>int vfprintf(FILE* stream, const char* format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>fprintf</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vfprintf.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
          <param id="p.vfprintf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vfprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list from <code>va_start</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Characters printed, or negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.vprintf" name="vprintf" kind="function">
        <signature>int vprintf(const char* format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>printf</code>, writing to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vprintf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Characters printed, or negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.vsnprintf" name="vsnprintf" kind="function">
        <signature>int vsnprintf(char* s, size_t n, const char* format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>snprintf</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vsnprintf.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer (may be NULL if <code>n</code> is 0 to query size).</p>
]]></description>
          </param>
          <param id="p.vsnprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Buffer capacity in bytes.</p>
]]></description>
          </param>
          <param id="p.vsnprintf.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vsnprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Would-have-written count excluding NUL, truncated if >= n, negative on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputs" name="fputs" kind="function">
        <signature>int fputs(const char* s, FILE* stream);</signature>
        <summary><![CDATA[
<p>Writes a NUL-terminated string to <code>stream</code> (does not automatically append a newline).</p>
]]></summary>
        <parameters>
          <param id="p.fputs.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to write (terminator is not written).</p>
]]></description>
          </param>
          <param id="p.fputs.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.puts" name="puts" kind="function">
        <signature>int puts(const char* s);</signature>
        <summary><![CDATA[
<p>Writes a string to <code>stdout</code> followed by a newline.</p>
]]></summary>
        <parameters>
          <param id="p.puts.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated string to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputc" name="fputc" kind="function">
        <signature>int fputc(int c, FILE* stream);</signature>
        <summary><![CDATA[
<p>Writes a byte (converted to unsigned char) to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fputc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write, passed as int.</p>
]]></description>
          </param>
          <param id="p.fputc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character (as unsigned char promoted to int) on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putc" name="putc" kind="function_or_macro">
        <signature>int putc(int c, FILE* stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fputc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.putc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write.</p>
]]></description>
          </param>
          <param id="p.putc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putchar" name="putchar" kind="function_or_macro">
        <signature>int putchar(int c);</signature>
        <summary><![CDATA[
<p>Writes a byte to <code>stdout</code>. Often implemented as a macro calling <code>putc(c, stdout)</code>.</p>
]]></summary>
        <parameters>
          <param id="p.putchar.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fgets" name="fgets" kind="function">
        <signature>char* fgets(char* s, int n, FILE* stream);</signature>
        <summary><![CDATA[
<p>
Reads at most <code>n - 1</code> bytes into <code>s</code> from <code>stream</code>, stopping after a newline or EOF, and NUL-terminates.
If a newline is read, it is included in the buffer.
</p>
]]></summary>
        <parameters>
          <param id="p.fgets.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer to receive the line, NUL-terminated on success.</p>
]]></description>
          </param>
          <param id="p.fgets.n" name="n" direction="in" type="int">
            <description><![CDATA[
<p>Buffer capacity in bytes. Must be greater than 0 for a useful read.</p>
]]></description>
            <constraints>
              <constraint id="c.fgets.n_positive" severity="important">
                <description><![CDATA[
<p>If <code>n</code> is 0 or negative, behavior is undefined or implementation-defined. Pass a positive size.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fgets.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Returns <code>s</code> on success. Returns NULL if no characters were read due to EOF or error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fgets.read_lines" lang="c99">
            <title>Read lines safely and detect truncation</title>
            <code><![CDATA[
#include <stdio.h>
#include <string.h>

void read_lines(FILE* in) {
    char buf[256];

    while (fgets(buf, (int)sizeof(buf), in)) {
        size_t len = strlen(buf);

        /* If no newline and buffer filled, the line may be longer than the buffer. */
        if (len > 0 && buf[len - 1u] != '\n' && len == sizeof(buf) - 1u) {
            /* Truncated line fragment. Handle continuation if needed. */
        }

        /* Process buf (includes newline if present). */
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fgetc" name="fgetc" kind="function">
        <signature>int fgetc(FILE* stream);</signature>
        <summary><![CDATA[
<p>Reads the next byte from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fgetc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Returns the byte as an unsigned char converted to int, or EOF on end-of-file or error.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fgetc.eof" severity="important" topic="eof_vs_byte">
            <description><![CDATA[
<p>
Because valid bytes are 0..UCHAR_MAX and EOF is negative, always store the result in an <code>int</code>, not a <code>char</code>.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.getc" name="getc" kind="function_or_macro">
        <signature>int getc(FILE* stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fgetc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.getc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Next byte as unsigned char promoted to int, or EOF.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getchar" name="getchar" kind="function_or_macro">
        <signature>int getchar(void);</signature>
        <summary><![CDATA[
<p>Reads the next byte from <code>stdin</code>. Often implemented as a macro calling <code>getc(stdin)</code>.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Next byte as unsigned char promoted to int, or EOF.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ungetc" name="ungetc" kind="function">
        <signature>int ungetc(int c, FILE* stream);</signature>
        <summary><![CDATA[
<p>
Pushes a byte back onto the input stream so it will be returned by the next read operation.
This is commonly used for one-character lookahead in parsers.
</p>
]]></summary>
        <parameters>
          <param id="p.ungetc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte to push back. If <code>c</code> is EOF, the operation fails and EOF is returned.</p>
]]></description>
          </param>
          <param id="p.ungetc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream to push back onto.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Returns the pushed-back character on success, EOF on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ungetc.guarantee" severity="info" topic="pushback_depth">
            <description><![CDATA[
<p>
The standard guarantees at least one character of pushback if <code>c</code> is not EOF. Additional pushbacks may work but are implementation-defined.
</p>
]]></description>
          </note>
          <note id="n.ungetc.buffering" severity="important" topic="stream_position">
            <description><![CDATA[
<p>After pushing back a character, the file position and buffering semantics can be subtle. Use it narrowly for lookahead.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.ungetc.peek_nonspace" lang="c99">
            <title>Skip whitespace then put back the first non-space byte</title>
            <code><![CDATA[
#include <stdio.h>
#include <ctype.h>

int skip_spaces_and_peek(FILE* in) {
    int ch;
    do {
        ch = fgetc(in);
        if (ch == EOF) return EOF;
    } while (isspace((unsigned char)ch));

    /* Put it back so caller can read it again. */
    if (ungetc(ch, in) == EOF) return EOF;
    return ch;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.perror" name="perror" kind="function">
        <signature>void perror(const char* s);</signature>
        <summary><![CDATA[
<p>Prints <code>s</code>, a colon and space (implementation-defined formatting), and a message corresponding to the current <code>errno</code>, then a newline.</p>
]]></summary>
        <parameters>
          <param id="p.perror.s" name="s" direction="in" type="const char*">
            <description><![CDATA[
<p>Prefix string. If NULL or empty, an implementation-defined behavior prints just the error message.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.perror.errno" severity="important" topic="diagnostics">
            <description><![CDATA[
<p>
Call <code>perror</code> soon after the failing operation, before another library call can change <code>errno</code>.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.perror.open_fail" lang="c99">
            <title>Diagnose a failed fopen</title>
            <code><![CDATA[
#include <stdio.h>

int try_open(const char* path) {
    FILE* f = fopen(path, "rb");
    if (!f) {
        perror("fopen");
        return 0;
    }
    fclose(f);
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.stdio.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category includes the stdio.h functions you specified. Other standard stdio facilities exist (for example <code>feof</code>, <code>ferror</code>,
<code>clearerr</code>, <code>fscanf</code>, <code>fgets</code> variants, and more) and can be added as separate entries if desired.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.wchar_wide_io" name="wchar.h (wide I/O subset)">
      <summary><![CDATA[
<p>
Wide-character I/O functions that mirror basic stdio operations for wide characters and wide strings. These functions operate on <code>FILE* </code>
streams but read and write <code>wchar_t</code> data (via <code>wint_t</code> return types where EOF must be representable).
</p>
]]></summary>

      <notes>
        <note id="n.wideio.weof" severity="important" topic="weof">
          <description><![CDATA[
<p>
Wide character input functions return <code>wint_t</code> and use <code>WEOF</code> to signal end-of-file or error. Store results in <code>wint_t</code>.
</p>
]]></description>
        </note>
        <note id="n.wideio.locale" severity="important" topic="locale">
          <description><![CDATA[
<p>
Wide I/O interpretation depends on the current locale and the stream orientation. Document your locale assumptions when portability matters.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.fgetwc" name="fgetwc" kind="function">
        <signature>wint_t fgetwc(FILE* stream);</signature>
        <summary><![CDATA[
<p>Reads the next wide character from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fgetwc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character as <code>wint_t</code>, or <code>WEOF</code> on end-of-file or error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputwc" name="fputwc" kind="function">
        <signature>wint_t fputwc(wchar_t wc, FILE* stream);</signature>
        <summary><![CDATA[
<p>Writes wide character <code>wc</code> to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fputwc.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
          <param id="p.fputwc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character (as <code>wint_t</code>) on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getwc" name="getwc" kind="function_or_macro">
        <signature>wint_t getwc(FILE* stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fgetwc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.getwc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character, or <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putwc" name="putwc" kind="function_or_macro">
        <signature>wint_t putwc(wchar_t wc, FILE* stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fputwc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.putwc.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
          <param id="p.putwc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getwchar" name="getwchar" kind="function_or_macro">
        <signature>wint_t getwchar(void);</signature>
        <summary><![CDATA[
<p>Reads the next wide character from <code>stdin</code>.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character, or <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putwchar" name="putwchar" kind="function_or_macro">
        <signature>wint_t putwchar(wchar_t wc);</signature>
        <summary><![CDATA[
<p>Writes wide character <code>wc</code> to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.putwchar.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fgetws" name="fgetws" kind="function">
        <signature>wchar_t* fgetws(wchar_t* s, int n, FILE* stream);</signature>
        <summary><![CDATA[
<p>
Reads at most <code>n - 1</code> wide characters into <code>s</code>, stopping after a newline or EOF, and NUL-terminates.
If a newline is read, it is included.
</p>
]]></summary>
        <parameters>
          <param id="p.fgetws.s" name="s" direction="out" type="wchar_t*">
            <description><![CDATA[
<p>Destination wide buffer to receive the line.</p>
]]></description>
          </param>
          <param id="p.fgetws.n" name="n" direction="in" type="int">
            <description><![CDATA[
<p>Capacity in wide characters. Must be positive.</p>
]]></description>
          </param>
          <param id="p.fgetws.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t*">
            <description><![CDATA[
<p>Returns <code>s</code> on success, NULL if no characters were read due to EOF or error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fgetws.read_wlines" lang="c99">
            <title>Read wide lines safely</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdio.h>

void read_wlines(FILE* in) {
    wchar_t buf[256];

    while (fgetws(buf, (int)(sizeof(buf) / sizeof(buf[0])), in)) {
        /* Process buf; it includes newline if present. */
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fputws" name="fputws" kind="function">
        <signature>int fputws(const wchar_t* s, FILE* stream);</signature>
        <summary><![CDATA[
<p>Writes a NUL-terminated wide string to <code>stream</code> (does not automatically append a newline).</p>
]]></summary>
        <parameters>
          <param id="p.fputws.s" name="s" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Wide string to write (terminator is not written).</p>
]]></description>
          </param>
          <param id="p.fputws.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, or EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ungetwc" name="ungetwc" kind="function">
        <signature>wint_t ungetwc(wint_t wc, FILE* stream);</signature>
        <summary><![CDATA[
<p>Pushes a wide character back onto the input stream so it will be returned by the next wide read.</p>
]]></summary>
        <parameters>
          <param id="p.ungetwc.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character to push back. If <code>wc</code> is <code>WEOF</code>, the operation fails.</p>
]]></description>
          </param>
          <param id="p.ungetwc.stream" name="stream" direction="in" type="FILE*">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Pushed-back character on success, or <code>WEOF</code> on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ungetwc.guarantee" severity="info" topic="pushback_depth">
            <description><![CDATA[
<p>As with <code>ungetc</code>, only limited pushback is guaranteed by the standard. Use narrowly for lookahead.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wideio.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes only the wide I/O functions you specified. The full <code>wchar.h</code> header also contains wide string and conversion
functions that belong in the strings/raw-memory category.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-20T16-15-03-9e1ddf04-13fc-4758-8da1-3e099d111f9b" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="numeric.parsing.formatting.utilities" name="Numeric parsing, integer formatting helpers, and general utilities">
    <summary><![CDATA[
<p>
Core runtime services and numeric conversion helpers: memory allocation and cleanup, program termination hooks,
environment queries, pseudo-random number generation, robust numeric parsing from strings, and generic searching/sorting.
This category also includes integer-width portable parsing helpers from <code>inttypes.h</code> for maximum-width integers.
</p>
<p>
Treat these APIs as low-level building blocks. Prefer explicit error checking for all conversions and allocations,
avoid undefined behavior from overflow, and be careful with process-wide side effects (environment variables, <code>system</code>,
global PRNG state, and exit handlers). For conversions, prefer the <code>strto*</code> family over <code>atoi</code>-style functions
because the <code>strto*</code> functions provide error detection and end-pointer reporting.
</p>
]]></summary>

    <keywords>
      <kw>stdlib</kw>
      <kw>inttypes</kw>
      <kw>malloc</kw>
      <kw>free</kw>
      <kw>realloc</kw>
      <kw>calloc</kw>
      <kw>exit</kw>
      <kw>atexit</kw>
      <kw>getenv</kw>
      <kw>system</kw>
      <kw>rand</kw>
      <kw>srand</kw>
      <kw>strtol</kw>
      <kw>strtoll</kw>
      <kw>strtoul</kw>
      <kw>strtoull</kw>
      <kw>strtod</kw>
      <kw>qsort</kw>
      <kw>bsearch</kw>
      <kw>strtoimax</kw>
      <kw>strtoumax</kw>
    </keywords>

    <notes>
      <note id="n.numeric.alloc_overflow" severity="important" topic="allocation_overflow">
        <description><![CDATA[
<p>
When computing allocation sizes, guard against overflow in <code>count * size</code>. Overflow can wrap to a small value,
leading to undersized allocations and out-of-bounds writes.
</p>
]]></description>
      </note>
      <note id="n.numeric.conversion_errno" severity="important" topic="strto_error_handling">
        <description><![CDATA[
<p>
For <code>strto*</code> conversions, set <code>errno = 0</code> before the call and then check:
(1) whether the end pointer advanced (at least one digit/char converted),
(2) whether <code>errno == ERANGE</code> to detect overflow/underflow,
(3) whether there is unexpected trailing text.
</p>
]]></description>
      </note>
      <note id="n.numeric.prng_quality" severity="warning" topic="rand_quality">
        <description><![CDATA[
<p>
<code>rand</code>/<code>srand</code> provide a simple pseudo-random generator with implementation-defined quality and period.
Do not use for security-sensitive randomness. For non-security uses, document your seeding and distribution approach.
</p>
]]></description>
      </note>
      <note id="n.numeric.qsort_cmp" severity="important" topic="qsort_comparator">
        <description><![CDATA[
<p>
The comparator for <code>qsort</code>/<code>bsearch</code> must define a strict weak ordering and must not overflow.
Prefer comparisons using relational operators rather than subtracting integers.
</p>
]]></description>
      </note>
      <note id="n.numeric.system_side_effects" severity="warning" topic="system">
        <description><![CDATA[
<p>
<code>system</code> invokes a command processor with environment-dependent semantics and security implications.
Avoid on untrusted input. Prefer dedicated APIs outside the C standard library for controlled process execution.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.stdlib" name="stdlib.h">
      <summary><![CDATA[
<p>
General utilities: dynamic memory management, program termination and cleanup hooks, environment queries, command execution,
pseudo-random numbers, numeric parsing, absolute value helpers, quotient/remainder helpers, and generic algorithms.
</p>
]]></summary>

      <function id="fn.malloc" name="malloc" kind="function">
        <signature>void* malloc(size_t size);</signature>
        <summary><![CDATA[
<p>Allocates <code>size</code> bytes of uninitialized storage.</p>
]]></summary>
        <parameters>
          <param id="p.malloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to allocate.</p>
]]></description>
            <constraints>
              <constraint id="c.malloc.zero" severity="info">
                <description><![CDATA[
<p>If <code>size</code> is 0, the return value may be NULL or a unique pointer that can be passed to <code>free</code>.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Pointer to allocated memory, or NULL if allocation fails.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.malloc.uninitialized" severity="important" topic="initialization">
            <description><![CDATA[
<p>The allocated bytes are uninitialized. Initialize before reading.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.malloc.allocate_array_checked" lang="c99">
            <title>Allocate an array with overflow check</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int* alloc_ints(size_t count) {
    if (count > (SIZE_MAX / sizeof(int))) {
        return NULL;
    }
    return (int*)malloc(count * sizeof(int));
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.calloc" name="calloc" kind="function">
        <signature>void* calloc(size_t nmemb, size_t size);</signature>
        <summary><![CDATA[
<p>Allocates space for <code>nmemb</code> objects of <code>size</code> bytes each and zero-initializes the result.</p>
]]></summary>
        <parameters>
          <param id="p.calloc.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements.</p>
]]></description>
          </param>
          <param id="p.calloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
            <constraints>
              <constraint id="c.calloc.overflow" severity="important">
                <description><![CDATA[
<p>Allocation size is <code>nmemb * size</code>. Guard against overflow before relying on the allocation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Pointer to zeroed storage, or NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.calloc.zeroed" severity="info" topic="zero_init">
            <description><![CDATA[
<p>The returned block is filled with zero bytes, which is suitable for zero-initializing many plain data types and pointers.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.realloc" name="realloc" kind="function">
        <signature>void* realloc(void* ptr, size_t size);</signature>
        <summary><![CDATA[
<p>Resizes the allocation pointed to by <code>ptr</code> to <code>size</code> bytes, possibly moving it.</p>
]]></summary>
        <parameters>
          <param id="p.realloc.ptr" name="ptr" direction="inout" type="void*">
            <description><![CDATA[
<p>Existing allocation from <code>malloc</code>/<code>calloc</code>/<code>realloc</code>, or NULL to behave like <code>malloc</code>.</p>
]]></description>
          </param>
          <param id="p.realloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>New size in bytes. If 0 and <code>ptr</code> is not NULL, behavior is implementation-defined (often frees and returns NULL).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Pointer to resized block (may differ from <code>ptr</code>), or NULL on failure (original block remains allocated and unchanged).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.realloc.pattern" severity="important" topic="safe_usage">
            <description><![CDATA[
<p>Use a temporary pointer: assign the result to a new variable before updating the original pointer to avoid losing the original on failure.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.realloc.safe_grow" lang="c99">
            <title>Grow a buffer safely</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int grow(void**p, size_t* cap, size_t new_cap) {
    void* tmp = realloc(*p, new_cap);
    if (!tmp && new_cap != 0) {
        return 0;
    }
    *p = tmp;
    *cap = new_cap;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.free" name="free" kind="function">
        <signature>void free(void* ptr);</signature>
        <summary><![CDATA[
<p>Frees memory allocated by <code>malloc</code>/<code>calloc</code>/<code>realloc</code>.</p>
]]></summary>
        <parameters>
          <param id="p.free.ptr" name="ptr" direction="in" type="void*">
            <description><![CDATA[
<p>Pointer to allocated memory, or NULL (a no-op).</p>
]]></description>
            <constraints>
              <constraint id="c.free.valid" severity="important">
                <description><![CDATA[
<p><code>ptr</code> must be NULL or a pointer previously returned by allocation functions and not already freed.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.free.use_after_free" severity="important" topic="lifetime">
            <description><![CDATA[
<p>After freeing, do not use the pointer value. A common defensive pattern is to set pointers to NULL after freeing.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.abort" name="abort" kind="function">
        <signature>void abort(void);</signature>
        <summary><![CDATA[
<p>Terminates the program abnormally, typically generating a diagnostic.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>Does not return.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.abort.flush" severity="info" topic="buffers">
            <description><![CDATA[
<p>Output buffers may or may not be flushed; do not rely on buffered output being written.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.exit" name="exit" kind="function">
        <signature>void exit(int status);</signature>
        <summary><![CDATA[
<p>Terminates the program normally, performing cleanup such as flushing streams and running exit handlers.</p>
]]></summary>
        <parameters>
          <param id="p.exit.status" name="status" direction="in" type="int">
            <description><![CDATA[
<p>Exit status, typically <code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>Does not return.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.exit.handlers" severity="important" topic="atexit">
            <description><![CDATA[
<p>Runs functions registered with <code>atexit</code> (in reverse registration order) and flushes/ closes standard I/O streams.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.atexit" name="atexit" kind="function">
        <signature>int atexit(void (*func)(void));</signature>
        <summary><![CDATA[
<p>Registers <code>func</code> to be called at normal program termination (via <code>exit</code> or returning from <code>main</code>).</p>
]]></summary>
        <parameters>
          <param id="p.atexit.func" name="func" direction="in" type="void (*)(void)">
            <description><![CDATA[
<p>Function pointer with signature <code>void func(void)</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.atexit.restrictions" severity="important">
                <description><![CDATA[
<p>Exit handlers should avoid complex I/O or reliance on other subsystems that may already be partially shut down.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero if registration fails (for example due to resource limits).</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.atexit.cleanup" lang="c99">
            <title>Register a simple cleanup hook</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

static void cleanup(void) {
    /* Keep cleanup small and robust. */
    fputs("cleanup\n", stderr);
}

int main(void) {
    if (atexit(cleanup) != 0) {
        fputs("atexit failed\n", stderr);
        return 1;
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.getenv" name="getenv" kind="function">
        <signature>char* getenv(const char* name);</signature>
        <summary><![CDATA[
<p>Returns the value of the environment variable <code>name</code>, or NULL if it is not set.</p>
]]></summary>
        <parameters>
          <param id="p.getenv.name" name="name" direction="in" type="const char*">
            <description><![CDATA[
<p>NUL-terminated environment variable name.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to the value string owned by the environment, or NULL if not found. The pointer may be invalidated by environment changes.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.getenv.copy" severity="important" topic="lifetime">
            <description><![CDATA[
<p>Copy the returned value if you need to keep it. Avoid modifying the returned string.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.getenv_optional" lang="c99">
            <title>Read an optional environment variable</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

const char* get_log_level(void) {
    const char* v = getenv("LOG_LEVEL");
    return v ? v : "info";
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.system" name="system" kind="function">
        <signature>int system(const char* string);</signature>
        <summary><![CDATA[
<p>Passes <code>string</code> to the host environment command processor. If <code>string</code> is NULL, tests for command processor availability.</p>
]]></summary>
        <parameters>
          <param id="p.system.string" name="string" direction="in" type="const char*">
            <description><![CDATA[
<p>Command string to execute, or NULL to query availability.</p>
]]></description>
            <constraints>
              <constraint id="c.system.untrusted" severity="warning">
                <description><![CDATA[
<p>Do not execute untrusted or partially trusted command strings. Avoid interpolating user input into commands.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>
If <code>string</code> is NULL, returns non-zero if a command processor is available, 0 otherwise.
If executed, returns an implementation-defined status code; -1 typically indicates a failure to invoke the processor.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rand" name="rand" kind="function">
        <signature>int rand(void);</signature>
        <summary><![CDATA[
<p>Returns a pseudo-random integer in the range 0 to <code>RAND_MAX</code> (inclusive).</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Pseudo-random value in [0, RAND_MAX].</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.rand.uniform" severity="warning" topic="distribution">
            <description><![CDATA[
<p>
Using <code>rand() % n</code> can introduce modulo bias unless <code>n</code> divides <code>RAND_MAX + 1</code>.
If you care about uniformity, use rejection sampling.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.srand" name="srand" kind="function">
        <signature>void srand(unsigned int seed);</signature>
        <summary><![CDATA[
<p>Seeds the pseudo-random generator used by <code>rand</code>.</p>
]]></summary>
        <parameters>
          <param id="p.srand.seed" name="seed" direction="in" type="unsigned int">
            <description><![CDATA[
<p>Seed value. The mapping from seed to sequence is implementation-defined.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.rand.uniform_range" lang="c99">
            <title>Uniform random in [0, n) using rejection sampling</title>
            <code><![CDATA[
#include <stdlib.h>
#include <limits.h>

int rand_below(int n) {
    if (n <= 0) return 0;

    /* Use unsigned arithmetic to avoid overflow. */
    unsigned int bound = (unsigned int)n;
    unsigned int rmax = (unsigned int)RAND_MAX;

    /* Largest multiple of bound within [0, RAND_MAX]. */
    unsigned int limit = (rmax / bound) * bound;

    unsigned int r;
    do {
        r = (unsigned int)rand();
    } while (r >= limit);

    return (int)(r % bound);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtol" name="strtol" kind="function">
        <signature>long strtol(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed long integer from <code>nptr</code> using the given <code>base</code>, with error detection and end-pointer reporting.</p>
]]></summary>
        <parameters>
          <param id="p.strtol.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped; an optional sign is accepted.</p>
]]></description>
          </param>
          <param id="p.strtol.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>
If non-NULL, <code>*endptr</code> is set to the first character after the parsed number.
If no conversion occurs, <code>*endptr</code> is set to <code>nptr</code>.
</p>
]]></description>
          </param>
          <param id="p.strtol.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>
Base for conversion: 0, or a value from 2 to 36. If 0, base is inferred from prefixes: "0x"/"0X" for hex, leading "0" for octal, otherwise decimal.
</p>
]]></description>
            <constraints>
              <constraint id="c.strtol.base_range" severity="important">
                <description><![CDATA[
<p><code>base</code> must be 0 or in [2, 36].</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Converted value on success. On overflow/underflow, returns <code>LONG_MAX</code>/<code>LONG_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strtol.parse_checked" lang="c99">
            <title>Parse an int with full validation</title>
            <code><![CDATA[
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int parse_int_strict(const char* s, int* out) {
    errno = 0;
    char* end = NULL;

    long v = strtol(s, &end, 10);

    if (end == s) return 0;               /* no digits */
    if (*end != '\0') return 0;           /* trailing junk */
    if (errno == ERANGE) return 0;        /* overflow/underflow */
    if (v < INT_MIN || v > INT_MAX) return 0;

    *out = (int)v;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtoll" name="strtoll" kind="function">
        <signature>long long strtoll(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed long long integer from <code>nptr</code> with the same semantics as <code>strtol</code>, but with a wider result type.</p>
]]></summary>
        <parameters>
          <param id="p.strtoll.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoll.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoll.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long long">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>LLONG_MAX</code>/<code>LLONG_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtoul" name="strtoul" kind="function">
        <signature>unsigned long strtoul(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned long integer from <code>nptr</code>, with error detection and end-pointer reporting.</p>
]]></summary>
        <parameters>
          <param id="p.strtoul.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped; an optional sign may be present (a leading '-' yields an implementation-defined converted value modulo the type).</p>
]]></description>
          </param>
          <param id="p.strtoul.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoul.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="unsigned long">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>ULONG_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtoul.negative" severity="warning" topic="sign">
            <description><![CDATA[
<p>
If you require strict non-negative input, reject a leading '-' explicitly before calling, and verify <code>endptr</code> and trailing text.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strtoull" name="strtoull" kind="function">
        <signature>unsigned long long strtoull(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned long long integer from <code>nptr</code>, with the same semantics as <code>strtoul</code> but a wider result type.</p>
]]></summary>
        <parameters>
          <param id="p.strtoull.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoull.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoull.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="unsigned long long">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>ULLONG_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtod" name="strtod" kind="function">
        <signature>double strtod(const char* nptr, char**endptr);</signature>
        <summary><![CDATA[
<p>Parses a double-precision floating-point value from <code>nptr</code>, with end-pointer reporting and range error signaling.</p>
]]></summary>
        <parameters>
          <param id="p.strtod.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped. Locale may affect decimal point interpretation.</p>
]]></description>
          </param>
          <param id="p.strtod.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>
Converted value. On overflow sets <code>errno</code> to <code>ERANGE</code> and returns +/-HUGE_VAL.
On underflow may set <code>errno</code> and return 0.0.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtod.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Decimal point may be locale-dependent. If you need locale-independent parsing, document assumptions or manage locale explicitly.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strtof" name="strtof" kind="function">
        <signature>float strtof(const char* nptr, char**endptr);</signature>
        <summary><![CDATA[
<p>Parses a single-precision float from <code>nptr</code>, analogous to <code>strtod</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtof.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtof.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="float">
            <description><![CDATA[
<p>Converted value; sets <code>errno</code> to <code>ERANGE</code> on overflow/underflow as applicable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtold" name="strtold" kind="function">
        <signature>long double strtold(const char* nptr, char**endptr);</signature>
        <summary><![CDATA[
<p>Parses a long double from <code>nptr</code>, analogous to <code>strtod</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtold.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtold.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long double">
            <description><![CDATA[
<p>Converted value; sets <code>errno</code> to <code>ERANGE</code> on overflow/underflow as applicable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.abs" name="abs" kind="function">
        <signature>int abs(int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of <code>j</code>.</p>
]]></summary>
        <parameters>
          <param id="p.abs.j" name="j" direction="in" type="int">
            <description><![CDATA[
<p>Input integer.</p>
]]></description>
            <constraints>
              <constraint id="c.abs.intmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>INT_MIN</code>, the absolute value may not be representable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Absolute value of <code>j</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.labs" name="labs" kind="function">
        <signature>long int labs(long int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of a long integer.</p>
]]></summary>
        <parameters>
          <param id="p.labs.j" name="j" direction="in" type="long int">
            <description><![CDATA[
<p>Input long integer.</p>
]]></description>
            <constraints>
              <constraint id="c.labs.longmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>LONG_MIN</code>, the absolute value may be unrepresentable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long int">
            <description><![CDATA[
<p>Absolute value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.llabs" name="llabs" kind="function">
        <signature>long long int llabs(long long int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of a long long integer.</p>
]]></summary>
        <parameters>
          <param id="p.llabs.j" name="j" direction="in" type="long long int">
            <description><![CDATA[
<p>Input long long integer.</p>
]]></description>
            <constraints>
              <constraint id="c.llabs.llongmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>LLONG_MIN</code>, the absolute value may be unrepresentable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long long int">
            <description><![CDATA[
<p>Absolute value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.div" name="div" kind="function">
        <signature>div_t div(int numer, int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder of integer division.</p>
]]></summary>
        <parameters>
          <param id="p.div.numer" name="numer" direction="in" type="int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.div.denom" name="denom" direction="in" type="int">
            <description><![CDATA[
<p>Denominator.</p>
]]></description>
            <constraints>
              <constraint id="c.div.zero" severity="important">
                <description><![CDATA[
<p><code>denom</code> must not be 0.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="div_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.div.signs" severity="info" topic="semantics">
            <description><![CDATA[
<p>The sign of the remainder follows the sign rules for C integer division. Use these helpers for clarity and consistency.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.div.qr" lang="c99">
            <title>Compute quotient and remainder explicitly</title>
            <code><![CDATA[
#include <stdlib.h>

int mod_positive(int x, int m) {
    div_t d = div(x, m);
    /* Example normalization to a non-negative remainder. */
    if (d.rem < 0) d.rem += (m > 0 ? m : -m);
    return d.rem;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ldiv" name="ldiv" kind="function">
        <signature>ldiv_t ldiv(long int numer, long int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder for long integer division.</p>
]]></summary>
        <parameters>
          <param id="p.ldiv.numer" name="numer" direction="in" type="long int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.ldiv.denom" name="denom" direction="in" type="long int">
            <description><![CDATA[
<p>Denominator (must not be 0).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="ldiv_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.lldiv" name="lldiv" kind="function">
        <signature>lldiv_t lldiv(long long int numer, long long int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder for long long integer division.</p>
]]></summary>
        <parameters>
          <param id="p.lldiv.numer" name="numer" direction="in" type="long long int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.lldiv.denom" name="denom" direction="in" type="long long int">
            <description><![CDATA[
<p>Denominator (must not be 0).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="lldiv_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.qsort" name="qsort" kind="function">
        <signature>void qsort(void* base, size_t nmemb, size_t size, int (*compar)(const void* , const void* ));</signature>
        <summary><![CDATA[
<p>Sorts an array of <code>nmemb</code> elements of size <code>size</code> using the provided comparator.</p>
]]></summary>
        <parameters>
          <param id="p.qsort.base" name="base" direction="inout" type="void*">
            <description><![CDATA[
<p>Pointer to the first element of the array to sort.</p>
]]></description>
          </param>
          <param id="p.qsort.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements in the array.</p>
]]></description>
          </param>
          <param id="p.qsort.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
          </param>
          <param id="p.qsort.compar" name="compar" direction="in" type="int (*)(const void*, const void*)">
            <description><![CDATA[
<p>
Comparator: returns &lt;0 if first element is "less", 0 if equal, &gt;0 if "greater".
Must be consistent and must impose a strict weak ordering.
</p>
]]></description>
            <constraints>
              <constraint id="c.qsort.compar_safe" severity="important">
                <description><![CDATA[
<p>Avoid subtraction-based comparisons that can overflow. Compare with relational operators.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.qsort.int_safe_cmp" lang="c99">
            <title>Sort integers with a safe comparator</title>
            <code><![CDATA[
#include <stdlib.h>

static int cmp_int(const void* a, const void* b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

void sort_ints(int* arr, size_t n) {
    qsort(arr, n, sizeof(arr[0]), cmp_int);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.bsearch" name="bsearch" kind="function">
        <signature>void* bsearch(const void* key, const void* base, size_t nmemb, size_t size, int (*compar)(const void* , const void* ));</signature>
        <summary><![CDATA[
<p>Searches a sorted array for <code>key</code> using binary search and the provided comparator.</p>
]]></summary>
        <parameters>
          <param id="p.bsearch.key" name="key" direction="in" type="const void*">
            <description><![CDATA[
<p>Pointer to the key to search for (as interpreted by the comparator).</p>
]]></description>
          </param>
          <param id="p.bsearch.base" name="base" direction="in" type="const void*">
            <description><![CDATA[
<p>Pointer to the first element of the sorted array.</p>
]]></description>
          </param>
          <param id="p.bsearch.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements in the array.</p>
]]></description>
          </param>
          <param id="p.bsearch.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
          </param>
          <param id="p.bsearch.compar" name="compar" direction="in" type="int (*)(const void*, const void*)">
            <description><![CDATA[
<p>Comparator with the same ordering as used for sorting.</p>
]]></description>
            <constraints>
              <constraint id="c.bsearch.sorted" severity="important">
                <description><![CDATA[
<p>The array must already be sorted according to <code>compar</code>. Otherwise, results are undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void*">
            <description><![CDATA[
<p>Pointer to a matching element, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.bsearch.find_int" lang="c99">
            <title>Binary search in a sorted int array</title>
            <code><![CDATA[
#include <stdlib.h>

static int cmp_int_key(const void* key, const void* elem) {
    int x = *(const int*)key;
    int y = *(const int*)elem;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

int contains_int(const int* arr, size_t n, int value) {
    return bsearch(&value, arr, n, sizeof(arr[0]), cmp_int_key) != NULL;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.stdlib.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes only the stdlib.h functions you listed: allocation, termination hooks, environment/system, rand/srand,
numeric parsing (strto*), abs/labs/llabs, div/ldiv/lldiv, qsort/bsearch. Other stdlib.h functions exist but are out of scope here.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.inttypes" name="inttypes.h">
      <summary><![CDATA[
<p>
Portable parsing helpers for maximum-width integers. These are useful when you want the widest standard integer types
(<code>intmax_t</code>, <code>uintmax_t</code>) without choosing a specific width.
Includes both byte string and wide string variants.
</p>
]]></summary>

      <function id="fn.strtoimax" name="strtoimax" kind="function">
        <signature>intmax_t strtoimax(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed maximum-width integer from a byte string, analogous to <code>strtoll</code> but returning <code>intmax_t</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtoimax.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoimax.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoimax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="intmax_t">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>INTMAX_MAX</code>/<code>INTMAX_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strtoimax.strict" lang="c99">
            <title>Strict parse to intmax_t with trailing text rejection</title>
            <code><![CDATA[
#include <inttypes.h>
#include <errno.h>

int parse_intmax_strict(const char* s, intmax_t *out) {
    errno = 0;
    char* end = NULL;

    intmax_t v = strtoimax(s, &end, 10);

    if (end == s) return 0;
    if (*end != '\0') return 0;
    if (errno == ERANGE) return 0;

    *out = v;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtoumax" name="strtoumax" kind="function">
        <signature>uintmax_t strtoumax(const char* nptr, char**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned maximum-width integer from a byte string, analogous to <code>strtoull</code> but returning <code>uintmax_t</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtoumax.nptr" name="nptr" direction="in" type="const char*">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoumax.endptr" name="endptr" direction="out" type="char**">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
          <param id="p.strtoumax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="uintmax_t">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>UINTMAX_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtoumax.negative" severity="warning" topic="sign">
            <description><![CDATA[
<p>If you require strictly unsigned syntax, reject a leading '-' before calling and enforce full-consumption via <code>endptr</code>.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wcstoimax" name="wcstoimax" kind="function">
        <signature>intmax_t wcstoimax(const wchar_t* nptr, wchar_t**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed maximum-width integer from a wide string, analogous to <code>strtoimax</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcstoimax.nptr" name="nptr" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Input wide string.</p>
]]></description>
          </param>
          <param id="p.wcstoimax.endptr" name="endptr" direction="out" type="wchar_t**">
            <description><![CDATA[
<p>End pointer reporting for wide strings.</p>
]]></description>
          </param>
          <param id="p.wcstoimax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="intmax_t">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>INTMAX_MAX</code>/<code>INTMAX_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcstoumax" name="wcstoumax" kind="function">
        <signature>uintmax_t wcstoumax(const wchar_t* nptr, wchar_t**endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned maximum-width integer from a wide string, analogous to <code>strtoumax</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcstoumax.nptr" name="nptr" direction="in" type="const wchar_t*">
            <description><![CDATA[
<p>Input wide string.</p>
]]></description>
          </param>
          <param id="p.wcstoumax.endptr" name="endptr" direction="out" type="wchar_t**">
            <description><![CDATA[
<p>End pointer reporting for wide strings.</p>
]]></description>
          </param>
          <param id="p.wcstoumax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="uintmax_t">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>UINTMAX_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.inttypes.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the inttypes.h parsing functions you listed: <code>strtoimax</code>, <code>strtoumax</code>, <code>wcstoimax</code>, <code>wcstoumax</code>.
Other inttypes.h facilities (format macros and printf/scanf support for fixed-width types) are out of scope here.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-20T16-15-38-6d2699d7-e5d4-4404-b205-cde029a06fae" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="localization.time_date" name="Localization and time/date">
    <summary><![CDATA[
<p>
Process-wide localization controls and calendar/clock utilities. The locale APIs control how the C library interprets and formats
culture-sensitive data (notably numeric formatting and time formatting via <code>strftime</code>). The time/date APIs provide timestamps,
calendar conversions, CPU time measurement, and formatting helpers.
</p>
<p>
These facilities are portable but have important pitfalls: locales are process-global and can affect unrelated code; many time formatting
and conversion routines return pointers to static storage and are not thread-safe; and "calendar time" semantics depend on the host
time zone and daylight saving rules. Prefer defensive usage: copy returned strings promptly, validate conversion results, and keep
examples explicit about UTC vs local time.
</p>
]]></summary>

    <keywords>
      <kw>locale</kw>
      <kw>setlocale</kw>
      <kw>localeconv</kw>
      <kw>time</kw>
      <kw>difftime</kw>
      <kw>clock</kw>
      <kw>mktime</kw>
      <kw>strftime</kw>
      <kw>gmtime</kw>
      <kw>localtime</kw>
      <kw>asctime</kw>
      <kw>ctime</kw>
      <kw>timezone</kw>
      <kw>DST</kw>
    </keywords>

    <notes>
      <note id="n.locale.global" severity="important" topic="global_state">
        <description><![CDATA[
<p>
The active locale is process-global. Calling <code>setlocale</code> can change behavior of formatting/parsing across the entire program,
including libraries you did not write. If you must change locale, do so in a controlled place and document it.
</p>
]]></description>
      </note>
      <note id="n.time.static_storage" severity="important" topic="thread_safety">
        <description><![CDATA[
<p>
Some time functions (<code>asctime</code>, <code>ctime</code>, and typically <code>gmtime</code>/<code>localtime</code>) may return pointers to static storage
that can be overwritten by subsequent calls. Copy results immediately if you need to keep them, and avoid concurrent use across threads
unless your platform provides safer alternatives outside the C standard.
</p>
]]></description>
      </note>
      <note id="n.time.utc_vs_local" severity="important" topic="utc_local">
        <description><![CDATA[
<p>
UTC and local time are different conversions. <code>gmtime</code> converts to UTC broken-down time, <code>localtime</code> converts using the current
time zone and daylight saving rules. Make the choice explicit in your code and documentation.
</p>
]]></description>
      </note>
      <note id="n.time.dst_mktime" severity="warning" topic="dst">
        <description><![CDATA[
<p>
<code>mktime</code> interprets <code>struct tm</code> as local time. Around DST transitions, some local times are ambiguous or nonexistent.
To let the library determine DST, set <code>tm_isdst = -1</code> before calling <code>mktime</code>.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.locale" name="locale.h">
      <summary><![CDATA[
<p>
Locale selection and locale-specific formatting conventions. Primarily used to control cultural conventions such as decimal separator
and date/time formatting for <code>strftime</code>. In C99, locale selection is process-wide.
</p>
]]></summary>

      <function id="fn.setlocale" name="setlocale" kind="function">
        <signature>char* setlocale(int category, const char* locale);</signature>
        <summary><![CDATA[
<p>Sets or queries the program's current locale.</p>
]]></summary>
        <parameters>
          <param id="p.setlocale.category" name="category" direction="in" type="int">
            <description><![CDATA[
<p>
Locale category to set or query: <code>LC_ALL</code>, <code>LC_CTYPE</code>, <code>LC_NUMERIC</code>, <code>LC_TIME</code>, <code>LC_COLLATE</code>,
<code>LC_MONETARY</code>, or <code>LC_MESSAGES</code> (if provided by the implementation).
</p>
]]></description>
          </param>
          <param id="p.setlocale.locale" name="locale" direction="in" type="const char*">
            <description><![CDATA[
<p>
Locale name string. If NULL, <code>setlocale</code> does not change the locale and returns the current setting for <code>category</code>.
An empty string "" typically means "use the environment's default locale".
</p>
]]></description>
            <constraints>
              <constraint id="c.setlocale.names" severity="info">
                <description><![CDATA[
<p>Supported locale names are implementation-defined and depend on the host environment.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>
On success returns a pointer to a string identifying the current locale setting for <code>category</code>. On failure returns NULL and leaves the locale unchanged.
The returned pointer may refer to internal static storage and can be invalidated by later <code>setlocale</code> calls.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.setlocale.copy" severity="important" topic="lifetime">
            <description><![CDATA[
<p>Copy the returned string if you need to retain it across future locale changes.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.setlocale.use_user_default" lang="c99">
            <title>Adopt the user's default locale for time formatting</title>
            <code><![CDATA[
#include <locale.h>

int enable_user_locale_for_time(void) {
    /* Use environment's default locale for LC_TIME only. */
    return setlocale(LC_TIME, "") != NULL;
}
]]></code>
          </example>
          <example id="ex.setlocale.query_current" lang="c99">
            <title>Query current numeric locale without changing it</title>
            <code><![CDATA[
#include <locale.h>

const char* current_numeric_locale(void) {
    /* Returns an internal pointer; copy it if you need long-term storage. */
    return setlocale(LC_NUMERIC, NULL);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.localeconv" name="localeconv" kind="function">
        <signature>struct lconv* localeconv(void);</signature>
        <summary><![CDATA[
<p>Returns locale-specific formatting information (notably numeric and monetary conventions).</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="struct lconv*">
            <description><![CDATA[
<p>
Pointer to a <code>struct lconv</code> describing current locale conventions. The object and its strings may be in static storage and can be overwritten
by subsequent calls or locale changes.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.localeconv.decimal" severity="important" topic="numeric_format">
            <description><![CDATA[
<p>
<code>lconv-&gt;decimal_point</code> and <code>lconv-&gt;thousands_sep</code> describe numeric formatting conventions. Do not assume "." as the decimal separator
when formatting for humans under non-"C" locales.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.localeconv_decimal_point" lang="c99">
            <title>Read the current decimal separator</title>
            <code><![CDATA[
#include <locale.h>

const char* decimal_point_string(void) {
    struct lconv* lc = localeconv();
    return lc ? lc->decimal_point : ".";
}
]]></code>
          </example>
        </examples>
      </function>
    </header>

    <header id="hdr.time" name="time.h">
      <summary><![CDATA[
<p>
Time and date utilities: current calendar time, elapsed time computations, CPU time measurement, conversions between timestamps and
broken-down time, and formatting into strings. Many operations depend on the host time zone and locale.
</p>
]]></summary>

      <function id="fn.time" name="time" kind="function">
        <signature>time_t time(time_t *tloc);</signature>
        <summary><![CDATA[
<p>Returns the current calendar time as a <code>time_t</code> value (typically seconds since an epoch), or (time_t)-1 on failure.</p>
]]></summary>
        <parameters>
          <param id="p.time.tloc" name="tloc" direction="out" type="time_t*">
            <description><![CDATA[
<p>If non-NULL, stores the returned time value into <code>*tloc</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="time_t">
            <description><![CDATA[
<p>Current calendar time, or (time_t)-1 if the time is not available.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.time_now" lang="c99">
            <title>Get current timestamp and validate</title>
            <code><![CDATA[
#include <time.h>

int get_now(time_t *out) {
    time_t t = time(NULL);
    if (t == (time_t)-1) return 0;
    *out = t;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.difftime" name="difftime" kind="function">
        <signature>double difftime(time_t time1, time_t time0);</signature>
        <summary><![CDATA[
<p>Computes the difference <code>time1 - time0</code> in seconds, returned as a <code>double</code>.</p>
]]></summary>
        <parameters>
          <param id="p.difftime.time1" name="time1" direction="in" type="time_t">
            <description><![CDATA[
<p>Later (or first) time value.</p>
]]></description>
          </param>
          <param id="p.difftime.time0" name="time0" direction="in" type="time_t">
            <description><![CDATA[
<p>Earlier (or second) time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Difference in seconds as a double. Use this rather than subtracting time_t directly for portability.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.difftime_elapsed" lang="c99">
            <title>Measure elapsed wall time between two timestamps</title>
            <code><![CDATA[
#include <time.h>

double elapsed_seconds(time_t start, time_t end) {
    return difftime(end, start);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.clock" name="clock" kind="function">
        <signature>clock_t clock(void);</signature>
        <summary><![CDATA[
<p>Returns processor time consumed by the program since start, measured in <code>CLOCKS_PER_SEC</code> ticks per second.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="clock_t">
            <description><![CDATA[
<p>CPU time ticks, or (clock_t)-1 if the processor time is not available.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.clock.wall_vs_cpu" severity="important" topic="measurement">
            <description><![CDATA[
<p>
<code>clock</code> measures CPU time, not wall-clock time. It is useful for CPU-bound benchmarking, not for measuring real elapsed time.
Resolution and meaning are implementation-defined.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.clock_benchmark" lang="c99">
            <title>CPU-time benchmark for a function</title>
            <code><![CDATA[
#include <time.h>

double cpu_seconds_for(void (*fn)(void)) {
    clock_t a = clock();
    if (a == (clock_t)-1) return -1.0;

    fn();

    clock_t b = clock();
    if (b == (clock_t)-1) return -1.0;

    return (double)(b - a) / (double)CLOCKS_PER_SEC;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.mktime" name="mktime" kind="function">
        <signature>time_t mktime(struct tm* timeptr);</signature>
        <summary><![CDATA[
<p>Converts broken-down local time in <code>*timeptr</code> to calendar time (<code>time_t</code>), normalizing fields as needed.</p>
]]></summary>
        <parameters>
          <param id="p.mktime.timeptr" name="timeptr" direction="inout" type="struct tm*">
            <description><![CDATA[
<p>
Broken-down local time input. Fields may be normalized by the function (for example if <code>tm_mday</code> is out of range).
Set <code>tm_isdst</code> to -1 to let the library determine daylight saving time.
</p>
]]></description>
            <constraints>
              <constraint id="c.mktime.localtime" severity="important">
                <description><![CDATA[
<p><code>mktime</code> interprets the input as local time, not UTC.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="time_t">
            <description><![CDATA[
<p>Calendar time equivalent, or (time_t)-1 if the conversion is not representable.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.mktime_add_days" lang="c99">
            <title>Add N days in local time using normalization</title>
            <code><![CDATA[
#include <time.h>

int add_days_local(time_t t, int days, time_t *out) {
    struct tm* lt = localtime(&t);
    if (!lt) return 0;

    struct tm tmp = *lt;     /* Copy because localtime may use static storage. */
    tmp.tm_isdst = -1;       /* Let library recompute DST. */
    tmp.tm_mday += days;     /* mktime will normalize month/year overflow. */

    time_t r = mktime(&tmp);
    if (r == (time_t)-1) return 0;

    *out = r;
    return 1;
}
]]></code>
          </example>
          <example id="ex.mktime_build_local_datetime" lang="c99">
            <title>Build a local datetime (YYYY-MM-DD HH:MM:SS) and convert to time_t</title>
            <code><![CDATA[
#include <time.h>

int make_local_time(int y, int mon, int d, int hh, int mm, int ss, time_t *out) {
    struct tm t;
    t.tm_year = y - 1900;    /* years since 1900 */
    t.tm_mon  = mon - 1;     /* months since January: 0..11 */
    t.tm_mday = d;
    t.tm_hour = hh;
    t.tm_min  = mm;
    t.tm_sec  = ss;
    t.tm_isdst = -1;

    time_t r = mktime(&t);
    if (r == (time_t)-1) return 0;

    *out = r;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strftime" name="strftime" kind="function">
        <signature>size_t strftime(char* s, size_t max, const char* format, const struct tm* timeptr);</signature>
        <summary><![CDATA[
<p>Formats broken-down time into a byte string according to <code>format</code> and the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.strftime.s" name="s" direction="out" type="char*">
            <description><![CDATA[
<p>Destination buffer for the formatted string.</p>
]]></description>
          </param>
          <param id="p.strftime.max" name="max" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in bytes, including the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.strftime.format" name="format" direction="in" type="const char*">
            <description><![CDATA[
<p>
Format string. Interpretation is specified by the C standard for common specifiers; output language and some details depend on the current locale.
</p>
]]></description>
          </param>
          <param id="p.strftime.timeptr" name="timeptr" direction="in" type="const struct tm*">
            <description><![CDATA[
<p>Broken-down time to format.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes written excluding the terminating NUL. Returns 0 if the result does not fit in the buffer.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strftime.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Month and weekday names and some representations are locale-dependent. Set <code>LC_TIME</code> appropriately if you need localized output.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strftime_iso_like_local" lang="c99">
            <title>Format local time into an ISO-like string</title>
            <code><![CDATA[
#include <time.h>

int format_local_iso(time_t t, char* buf, size_t cap) {
    struct tm* lt = localtime(&t);
    if (!lt) return 0;

    struct tm tmp = *lt;
    /* Example: 2026-01-20 14:03:05 */
    return strftime(buf, cap, "%Y-%m-%d %H:%M:%S", &tmp) != 0;
}
]]></code>
          </example>
          <example id="ex.strftime_rfcish_utc" lang="c99">
            <title>Format UTC time with an explicit UTC marker</title>
            <code><![CDATA[
#include <time.h>

int format_utc_rfcish(time_t t, char* buf, size_t cap) {
    struct tm* gt = gmtime(&t);
    if (!gt) return 0;

    struct tm tmp = *gt;
    /* Example: Tue, 20 Jan 2026 22:03:05 UTC */
    return strftime(buf, cap, "%a, %d %b %Y %H:%M:%S UTC", &tmp) != 0;
}
]]></code>
          </example>
          <example id="ex.strftime_buffer_growth" lang="c99">
            <title>Grow a buffer until strftime fits (malloc/realloc)</title>
            <code><![CDATA[
#include <time.h>
#include <stdlib.h>

char* format_time_alloc(const struct tm* t, const char* fmt) {
    size_t cap = 64;
    char* buf = (char*)malloc(cap);
    if (!buf) return NULL;

    for (;;) {
        size_t n = strftime(buf, cap, fmt, t);
        if (n != 0) {
            return buf;
        }
        if (cap > (SIZE_MAX / 2u)) {
            free(buf);
            return NULL;
        }
        cap *= 2u;
        char* tmp = (char*)realloc(buf, cap);
        if (!tmp) {
            free(buf);
            return NULL;
        }
        buf = tmp;
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.gmtime" name="gmtime" kind="function">
        <signature>struct tm* gmtime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Converts calendar time <code>*timer</code> to broken-down UTC time.</p>
]]></summary>
        <parameters>
          <param id="p.gmtime.timer" name="timer" direction="in" type="const time_t*">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="struct tm*">
            <description><![CDATA[
<p>Pointer to a <code>struct tm</code> result, or NULL on failure. The result may be stored in static storage.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.gmtime_copy" lang="c99">
            <title>Convert to UTC and copy out immediately</title>
            <code><![CDATA[
#include <time.h>

int to_utc_tm(time_t t, struct tm* out) {
    struct tm* p = gmtime(&t);
    if (!p) return 0;
    *out = *p;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.localtime" name="localtime" kind="function">
        <signature>struct tm* localtime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Converts calendar time <code>*timer</code> to broken-down local time using the host time zone rules.</p>
]]></summary>
        <parameters>
          <param id="p.localtime.timer" name="timer" direction="in" type="const time_t*">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="struct tm*">
            <description><![CDATA[
<p>Pointer to a <code>struct tm</code> result, or NULL on failure. The result may be stored in static storage.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.localtime_copy" lang="c99">
            <title>Convert to local time and copy out immediately</title>
            <code><![CDATA[
#include <time.h>

int to_local_tm(time_t t, struct tm* out) {
    struct tm* p = localtime(&t);
    if (!p) return 0;
    *out = *p;
    return 1;
}
]]></code>
          </example>
          <example id="ex.localtime_fields" lang="c99">
            <title>Extract calendar fields safely</title>
            <code><![CDATA[
#include <time.h>

int local_ymd(time_t t, int* y, int* m, int* d) {
    struct tm tmp;
    if (!to_local_tm(t, &tmp)) return 0;

    *y = tmp.tm_year + 1900;
    *m = tmp.tm_mon + 1;
    *d = tmp.tm_mday;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.asctime" name="asctime" kind="function">
        <signature>char* asctime(const struct tm* timeptr);</signature>
        <summary><![CDATA[
<p>Formats broken-down time into a fixed, implementation-defined string representation and returns a pointer to it.</p>
]]></summary>
        <parameters>
          <param id="p.asctime.timeptr" name="timeptr" direction="in" type="const struct tm*">
            <description><![CDATA[
<p>Broken-down time to format.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to an internal static string. The contents may be overwritten by subsequent calls. Typically ends with a newline.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.asctime.recommendation" severity="important" topic="best_practice">
            <description><![CDATA[
<p>
Prefer <code>strftime</code> for controlled formatting and buffer management. Use <code>asctime</code> mainly for quick debugging,
and copy the result immediately.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.asctime_copy" lang="c99">
            <title>Use asctime for debugging and copy the result</title>
            <code><![CDATA[
#include <time.h>
#include <string.h>

int asctime_copy(const struct tm* t, char* buf, size_t cap) {
    const char* s = asctime(t);
    if (!s) return 0;
    /* Copy with truncation; for logs/debug only. */
    if (cap == 0) return 0;
    strncpy(buf, s, cap - 1u);
    buf[cap - 1u] = '\0';
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ctime" name="ctime" kind="function">
        <signature>char* ctime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>asctime(localtime(timer))</code> in typical implementations: converts calendar time to a human-readable string.</p>
]]></summary>
        <parameters>
          <param id="p.ctime.timer" name="timer" direction="in" type="const time_t*">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char*">
            <description><![CDATA[
<p>Pointer to an internal static string (often ending with a newline). The contents may be overwritten by subsequent time calls.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ctime.recommendation" severity="important" topic="best_practice">
            <description><![CDATA[
<p>Prefer <code>strftime</code> for predictable output and explicit choice of UTC vs local time.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.ctime_quick" lang="c99">
            <title>Quick human-readable timestamp (debug only)</title>
            <code><![CDATA[
#include <time.h>
#include <stdio.h>

void print_now_debug(void) {
    time_t now = time(NULL);
    if (now == (time_t)-1) return;

    const char* s = ctime(&now);
    if (!s) return;

    /* ctime string often ends with newline already. */
    fputs(s, stdout);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.time.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry covers the full time.h function list you provided: <code>time</code>, <code>difftime</code>, <code>clock</code>, <code>mktime</code>,
<code>strftime</code>, <code>gmtime</code>, <code>localtime</code>, <code>asctime</code>, <code>ctime</code>. The tricky parts are UTC vs local time,
DST ambiguity, locale-dependent formatting, and static-storage return values; the examples emphasize defensive patterns for those.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-20T16-16-07-80d6c6aa-9e24-446e-bce5-8a5f149ef61f" type="application/xml"><?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="math.real.complex.fenv" name="Math (real, complex, and floating environment)">
    <summary><![CDATA[
<p>
Numerical computing primitives for real and complex arithmetic and for controlling/inspecting the floating-point environment.
This category covers three closely related modules:
(1) real math from <code>math.h</code>, including rounding, decomposition, transcendental functions, and robust helpers such as <code>fmin</code>/<code>fmax</code>;
(2) complex arithmetic from <code>complex.h</code>, mirroring many real functions for complex numbers plus accessors;
(3) floating-point environment control from <code>fenv.h</code>, used to query and manage exceptions (invalid, overflow, etc.) and rounding modes.
</p>
<p>
Portability guidance: prefer functions designed to handle NaNs and signed zero predictably (<code>fmin</code>, <code>fmax</code>, <code>copysign</code>);
avoid assuming a particular floating-point format; do not rely on <code>errno</code> alone for detecting floating exceptions; and use <code>fenv.h</code>
only when you have a clear numerical need because behavior may depend on compiler flags and runtime environment.
</p>
]]></summary>

    <keywords>
      <kw>math</kw>
      <kw>complex</kw>
      <kw>fenv</kw>
      <kw>rounding</kw>
      <kw>exceptions</kw>
      <kw>NaN</kw>
      <kw>infinity</kw>
      <kw>fmin</kw>
      <kw>fmax</kw>
      <kw>copysign</kw>
      <kw>nextafter</kw>
      <kw>sqrt</kw>
      <kw>pow</kw>
      <kw>log</kw>
      <kw>exp</kw>
      <kw>sin</kw>
      <kw>cos</kw>
      <kw>tan</kw>
      <kw>cabs</kw>
      <kw>csqrt</kw>
      <kw>feclearexcept</kw>
      <kw>fetestexcept</kw>
      <kw>fesetround</kw>
    </keywords>

    <notes>
      <note id="n.math.domain_range" severity="important" topic="domain_range">
        <description><![CDATA[
<p>
Many functions have domain restrictions (for example <code>sqrt(x)</code> for x &lt; 0, <code>log(x)</code> for x &lt;= 0).
Results and error signaling use a mix of special values (NaN, +/-inf), floating exceptions, and possibly <code>errno</code>.
If you need robust detection, prefer checking with <code>fenv.h</code> exceptions (and/or <code>isnan</code>/<code>isfinite</code> where available).
</p>
]]></description>
      </note>
      <note id="n.math.errno" severity="info" topic="errno">
        <description><![CDATA[
<p>
C99 permits but does not require setting <code>errno</code> for math errors. Do not depend on <code>errno</code> alone for correctness.
If you use <code>errno</code>, set it to 0 before the call and check after, and also consider floating exceptions.
</p>
]]></description>
      </note>
      <note id="n.math.rounding" severity="important" topic="rounding_modes">
        <description><![CDATA[
<p>
Rounding-related functions differ:
<code>floor</code>/<code>ceil</code> return floating results;
<code>round</code> rounds half away from zero (returns floating);
<code>rint</code>/<code>nearbyint</code> round according to the current rounding mode (returns floating);
<code>lround</code>/<code>llround</code> return integers and raise range issues if unrepresentable.
</p>
]]></description>
      </note>
      <note id="n.math.fenv.compiler" severity="warning" topic="fenv_compiler_flags">
        <description><![CDATA[
<p>
Floating environment behavior can be affected by compiler optimizations (for example fast-math) that assume no NaNs/infinities
or ignore exception semantics. If you rely on <code>fenv.h</code>, ensure your build settings preserve required semantics.
</p>
]]></description>
      </note>
      <note id="n.math.complex" severity="important" topic="complex_numbers">
        <description><![CDATA[
<p>
Complex functions operate on <code>double complex</code> (and related types) and may produce NaNs or infinities for some inputs.
Use accessors like <code>creal</code>/<code>cimag</code> for decomposition and <code>cabs</code> for magnitude.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.math" name="math.h">
      <summary><![CDATA[
<p>
Real-valued mathematical functions: classification helpers, decomposition, rounding, power/log/exp, trig and hyperbolic families,
and numeric utilities that handle NaNs and signed zero sensibly.
</p>
]]></summary>

      <function id="fn.fabs" name="fabs" kind="function">
        <signature>double fabs(double x);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of <code>x</code> as a double.</p>
]]></summary>
        <parameters>
          <param id="p.fabs.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Absolute value; preserves NaN as NaN.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fmod" name="fmod" kind="function">
        <signature>double fmod(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes the floating-point remainder of <code>x / y</code> with the same sign as <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fmod.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Dividend.</p>
]]></description>
          </param>
          <param id="p.fmod.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Divisor.</p>
]]></description>
            <constraints>
              <constraint id="c.fmod.y_nonzero" severity="important">
                <description><![CDATA[
<p>If <code>y</code> is 0, the result is domain error (typically NaN) and may raise FE_INVALID.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Remainder <code>r</code> such that <code>x = q * y + r</code> with integer-like <code>q</code>, and <code>|r| &lt; |y|</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fmod.wrap_angle" lang="c99">
            <title>Wrap an angle into (-pi, pi]</title>
            <code><![CDATA[
#include <math.h>

double wrap_pi(double a) {
    const double two_pi = 2.0 * acos(-1.0);
    a = fmod(a, two_pi);
    if (a <= -acos(-1.0)) a += two_pi;
    if (a >  acos(-1.0))  a -= two_pi;
    return a;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.remainder" name="remainder" kind="function">
        <signature>double remainder(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes the IEEE-style remainder of <code>x / y</code>, where the quotient is rounded to the nearest integer (ties to even).</p>
]]></summary>
        <parameters>
          <param id="p.remainder.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Dividend.</p>
]]></description>
          </param>
          <param id="p.remainder.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Divisor.</p>
]]></description>
            <constraints>
              <constraint id="c.remainder.y_nonzero" severity="important">
                <description><![CDATA[
<p>If <code>y</code> is 0, domain error (often NaN) and may raise FE_INVALID.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Remainder with magnitude at most <code>|y|/2</code>, using tie-to-even rounding of the quotient.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.modf" name="modf" kind="function">
        <signature>double modf(double x, double* iptr);</signature>
        <summary><![CDATA[
<p>Splits <code>x</code> into fractional and integral parts.</p>
]]></summary>
        <parameters>
          <param id="p.modf.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
          <param id="p.modf.iptr" name="iptr" direction="out" type="double*">
            <description><![CDATA[
<p>Receives the integral part of <code>x</code> (as a double).</p>
]]></description>
            <constraints>
              <constraint id="c.modf.iptr_nonnull" severity="important">
                <description><![CDATA[
<p><code>iptr</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Fractional part of <code>x</code>, with the same sign as <code>x</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.modf.split" lang="c99">
            <title>Split into integer and fraction</title>
            <code><![CDATA[
#include <math.h>

void split(double x, double* i, double* f) {
    *f = modf(x, i);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.frexp" name="frexp" kind="function">
        <signature>double frexp(double x, int* exp);</signature>
        <summary><![CDATA[
<p>Decomposes <code>x</code> into mantissa and exponent: <code>x = m * 2^e</code> with <code>m</code> in [0.5, 1) (or 0).</p>
]]></summary>
        <parameters>
          <param id="p.frexp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
          <param id="p.frexp.exp" name="exp" direction="out" type="int*">
            <description><![CDATA[
<p>Receives exponent value <code>e</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.frexp.exp_nonnull" severity="important">
                <description><![CDATA[
<p><code>exp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Mantissa <code>m</code>. If <code>x</code> is 0, returns 0 and stores 0 in <code>*exp</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ldexp" name="ldexp" kind="function">
        <signature>double ldexp(double x, int exp);</signature>
        <summary><![CDATA[
<p>Computes <code>x * 2^exp</code>, typically the inverse of <code>frexp</code> (modulo rounding).</p>
]]></summary>
        <parameters>
          <param id="p.ldexp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Mantissa-like input.</p>
]]></description>
          </param>
          <param id="p.ldexp.exp" name="exp" direction="in" type="int">
            <description><![CDATA[
<p>Exponent power of two.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Scaled value; may overflow to infinity or underflow toward 0, possibly raising exceptions.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fmin" name="fmin" kind="function">
        <signature>double fmin(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the smaller of <code>x</code> and <code>y</code>, with defined NaN handling (if one is NaN, returns the other).</p>
]]></summary>
        <parameters>
          <param id="p.fmin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First value.</p>
]]></description>
          </param>
          <param id="p.fmin.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Minimum, preferring the numeric argument if the other is NaN. Preserves signed zero semantics per specification.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fmin.vs_operator" severity="important" topic="nan_handling">
            <description><![CDATA[
<p>Prefer <code>fmin</code> over <code>(x &lt; y ? x : y)</code> when NaN behavior matters.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fmax" name="fmax" kind="function">
        <signature>double fmax(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the larger of <code>x</code> and <code>y</code>, with defined NaN handling.</p>
]]></summary>
        <parameters>
          <param id="p.fmax.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First value.</p>
]]></description>
          </param>
          <param id="p.fmax.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Maximum, preferring the numeric argument if the other is NaN.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.copysign" name="copysign" kind="function">
        <signature>double copysign(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns a value with the magnitude of <code>x</code> and the sign of <code>y</code> (including signed zero).</p>
]]></summary>
        <parameters>
          <param id="p.copysign.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Magnitude source.</p>
]]></description>
          </param>
          <param id="p.copysign.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Sign source.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Magnitude from <code>x</code> with sign bit from <code>y</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.copysign.force_sign" lang="c99">
            <title>Force a value to be negative or positive without branching</title>
            <code><![CDATA[
#include <math.h>

double force_positive(double x) { return copysign(x, 1.0); }
double force_negative(double x) { return copysign(x, -1.0); }
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.nextafter" name="nextafter" kind="function">
        <signature>double nextafter(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the next representable double after <code>x</code> in the direction of <code>y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.nextafter.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Starting value.</p>
]]></description>
          </param>
          <param id="p.nextafter.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Direction target. If <code>y</code> is greater than <code>x</code>, moves upward; if less, downward; if equal, returns <code>x</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Adjacent representable value, possibly raising overflow/underflow exceptions at the edges.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.nextafter_open_interval" lang="c99">
            <title>Create an open interval endpoint</title>
            <code><![CDATA[
#include <math.h>

/* Returns the largest representable value strictly less than x. */
double prev_double(double x) {
    return nextafter(x, -INFINITY);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.nexttoward" name="nexttoward" kind="function">
        <signature>double nexttoward(double x, long double y);</signature>
        <summary><![CDATA[
<p>Like <code>nextafter</code>, but the direction is specified as <code>long double</code> for better precision of the target.</p>
]]></summary>
        <parameters>
          <param id="p.nexttoward.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Starting value.</p>
]]></description>
          </param>
          <param id="p.nexttoward.y" name="y" direction="in" type="long double">
            <description><![CDATA[
<p>Direction target as long double.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Adjacent representable value after <code>x</code> toward <code>y</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.floor" name="floor" kind="function">
        <signature>double floor(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward negative infinity, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.floor.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Largest integral value not greater than <code>x</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ceil" name="ceil" kind="function">
        <signature>double ceil(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward positive infinity, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.ceil.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Smallest integral value not less than <code>x</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.trunc" name="trunc" kind="function">
        <signature>double trunc(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward zero, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.trunc.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral value by truncation toward zero.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.round" name="round" kind="function">
        <signature>double round(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> to the nearest integer value, with halfway cases rounded away from zero.</p>
]]></summary>
        <parameters>
          <param id="p.round.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Nearest integral-valued double.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.lround" name="lround" kind="function">
        <signature>long lround(double x);</signature>
        <summary><![CDATA[
<p>Rounds to the nearest integer, halfway away from zero, and returns as <code>long</code>.</p>
]]></summary>
        <parameters>
          <param id="p.lround.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
            <constraints>
              <constraint id="c.lround.range" severity="important">
                <description><![CDATA[
<p>If the rounded value is outside the range of <code>long</code>, the behavior is undefined or raises an invalid exception depending on implementation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Rounded integer result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.llround" name="llround" kind="function">
        <signature>long long llround(double x);</signature>
        <summary><![CDATA[
<p>Rounds to the nearest integer, halfway away from zero, and returns as <code>long long</code>.</p>
]]></summary>
        <parameters>
          <param id="p.llround.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long long">
            <description><![CDATA[
<p>Rounded integer result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.nearbyint" name="nearbyint" kind="function">
        <signature>double nearbyint(double x);</signature>
        <summary><![CDATA[
<p>Rounds according to the current rounding mode and returns an integral-valued double, typically without raising FE_INEXACT.</p>
]]></summary>
        <parameters>
          <param id="p.nearbyint.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral-valued double according to current rounding mode.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rint" name="rint" kind="function">
        <signature>double rint(double x);</signature>
        <summary><![CDATA[
<p>Rounds according to the current rounding mode and returns an integral-valued double (may raise FE_INEXACT).</p>
]]></summary>
        <parameters>
          <param id="p.rint.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral-valued double according to current rounding mode.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.sqrt" name="sqrt" kind="function">
        <signature>double sqrt(double x);</signature>
        <summary><![CDATA[
<p>Computes the square root of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.sqrt.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain is x &gt;= 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Square root. For x &lt; 0, typically returns NaN and may raise FE_INVALID.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.sqrt_hypot" lang="c99">
            <title>Prefer hypot for sqrt(x*x + y*y)</title>
            <code><![CDATA[
#include <math.h>

double length2d(double x, double y) {
    return hypot(x, y);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.cbrt" name="cbrt" kind="function">
        <signature>double cbrt(double x);</signature>
        <summary><![CDATA[
<p>Computes the real cube root of <code>x</code>, preserving the sign for negative inputs.</p>
]]></summary>
        <parameters>
          <param id="p.cbrt.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Cube root.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.hypot" name="hypot" kind="function">
        <signature>double hypot(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes <code>sqrt(x * x + y * y)</code> with reduced overflow/underflow risk.</p>
]]></summary>
        <parameters>
          <param id="p.hypot.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First component.</p>
]]></description>
          </param>
          <param id="p.hypot.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second component.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hypotenuse length.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.pow" name="pow" kind="function">
        <signature>double pow(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes <code>x</code> raised to the power <code>y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.pow.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Base.</p>
]]></description>
          </param>
          <param id="p.pow.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Power result; may overflow to infinity or underflow, and may return NaN for some domain combinations.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.pow_int_exp" lang="c99">
            <title>Integer exponent: consider a loop for exactness and speed</title>
            <code><![CDATA[
#include <math.h>

double powi(double x, int n) {
    double r = 1.0;
    int e = n;
    if (e < 0) { x = 1.0 / x; e = -e; }

    while (e) {
        if (e & 1) r *= x;
        x *= x;
        e >>= 1;
    }
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.exp" name="exp" kind="function">
        <signature>double exp(double x);</signature>
        <summary><![CDATA[
<p>Computes e raised to <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.exp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Exponential result; may overflow to infinity for large x or underflow toward 0 for very negative x.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.expm1" name="expm1" kind="function">
        <signature>double expm1(double x);</signature>
        <summary><![CDATA[
<p>Computes <code>exp(x) - 1</code> accurately for small <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.expm1.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Accurate <code>exp(x) - 1</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.expm1_small" lang="c99">
            <title>Stable computation for small x</title>
            <code><![CDATA[
#include <math.h>

double relative_growth(double x) {
    /* Better than exp(x) - 1 when x is near 0. */
    return expm1(x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.log" name="log" kind="function">
        <signature>double log(double x);</signature>
        <summary><![CDATA[
<p>Computes the natural logarithm of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Natural log; for x &lt; 0 returns NaN; for x == 0 returns -infinity, typically raising FE_DIVBYZERO.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.log10" name="log10" kind="function">
        <signature>double log10(double x);</signature>
        <summary><![CDATA[
<p>Computes base-10 logarithm of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log10.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Base-10 log.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.log1p" name="log1p" kind="function">
        <signature>double log1p(double x);</signature>
        <summary><![CDATA[
<p>Computes <code>log(1 + x)</code> accurately for small <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log1p.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; -1 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Accurate <code>log(1 + x)</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.log1p_small" lang="c99">
            <title>Stable log(1+x) for small x</title>
            <code><![CDATA[
#include <math.h>

double log_one_plus(double x) {
    return log1p(x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.sin" name="sin" kind="function">
        <signature>double sin(double x);</signature>
        <summary><![CDATA[
<p>Computes sine of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.sin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Sine value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cos" name="cos" kind="function">
        <signature>double cos(double x);</signature>
        <summary><![CDATA[
<p>Computes cosine of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.cos.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Cosine value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.tan" name="tan" kind="function">
        <signature>double tan(double x);</signature>
        <summary><![CDATA[
<p>Computes tangent of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.tan.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Tangent value; may overflow near odd multiples of pi/2.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.asin" name="asin" kind="function">
        <signature>double asin(double x);</signature>
        <summary><![CDATA[
<p>Computes arcsine of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.asin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: [-1, 1] for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arcsine in radians; outside domain typically returns NaN and may raise FE_INVALID.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.acos" name="acos" kind="function">
        <signature>double acos(double x);</signature>
        <summary><![CDATA[
<p>Computes arccosine of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.acos.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: [-1, 1] for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arccosine in radians.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.atan" name="atan" kind="function">
        <signature>double atan(double x);</signature>
        <summary><![CDATA[
<p>Computes arctangent of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.atan.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arctangent in radians.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.atan2" name="atan2" kind="function">
        <signature>double atan2(double y, double x);</signature>
        <summary><![CDATA[
<p>Computes arctangent of <code>y/x</code> using the signs of both to determine the correct quadrant.</p>
]]></summary>
        <parameters>
          <param id="p.atan2.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Y coordinate.</p>
]]></description>
          </param>
          <param id="p.atan2.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>X coordinate.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Angle in radians, typically in [-pi, pi].</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.atan2_angle" lang="c99">
            <title>Compute polar angle from x,y</title>
            <code><![CDATA[
#include <math.h>

double angle(double x, double y) {
    return atan2(y, x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.sinh" name="sinh" kind="function">
        <signature>double sinh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic sine of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.sinh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic sine; may overflow for large |x|.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cosh" name="cosh" kind="function">
        <signature>double cosh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic cosine of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cosh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic cosine; may overflow for large |x|.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.tanh" name="tanh" kind="function">
        <signature>double tanh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic tangent of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.tanh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.math.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the math.h functions you listed. Many of these have float/long double variants in the standard, but this
document focuses on the canonical double forms for cross-platform usage, mirroring the approach used in earlier categories.
</p>
]]></summary>
      </function>
    </header>

    <header id="hdr.complex" name="complex.h">
      <summary><![CDATA[
<p>
Complex arithmetic over <code>double complex</code>. Includes accessors (<code>creal</code>, <code>cimag</code>), magnitude/phase
(<code>cabs</code>, <code>carg</code>), and complex analogues of exp/log/pow/sqrt and trig/hyperbolic functions.
</p>
]]></summary>

      <function id="fn.creal" name="creal" kind="function">
        <signature>double creal(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the real part of complex number <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.creal.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Real component.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cimag" name="cimag" kind="function">
        <signature>double cimag(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the imaginary part of complex number <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cimag.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Imaginary component.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cabs" name="cabs" kind="function">
        <signature>double cabs(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the magnitude (modulus) of <code>z</code>, equivalent to <code>hypot(creal(z), cimag(z))</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cabs.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Magnitude.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.carg" name="carg" kind="function">
        <signature>double carg(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the phase angle (argument) of <code>z</code>, typically in radians.</p>
]]></summary>
        <parameters>
          <param id="p.carg.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Argument angle.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.conj" name="conj" kind="function">
        <signature>double complex conj(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the complex conjugate of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.conj.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Conjugate value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.conj_inner_product" lang="c99">
            <title>Complex inner product term</title>
            <code><![CDATA[
#include <complex.h>

double complex inner_term(double complex a, double complex b) {
    return conj(a) * b;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.cproj" name="cproj" kind="function">
        <signature>double complex cproj(double complex z);</signature>
        <summary><![CDATA[
<p>Projects <code>z</code> onto the Riemann sphere (useful for handling infinities consistently).</p>
]]></summary>
        <parameters>
          <param id="p.cproj.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Projected complex value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cexp" name="cexp" kind="function">
        <signature>double complex cexp(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex exponential of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cexp.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex exponential result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.clog" name="clog" kind="function">
        <signature>double complex clog(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex natural logarithm of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.clog.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex logarithm.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cpow" name="cpow" kind="function">
        <signature>double complex cpow(double complex x, double complex y);</signature>
        <summary><![CDATA[
<p>Computes complex power <code>x^y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cpow.x" name="x" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex base.</p>
]]></description>
          </param>
          <param id="p.cpow.y" name="y" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex power result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csqrt" name="csqrt" kind="function">
        <signature>double complex csqrt(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex square root of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csqrt.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex square root.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.csqrt_negative_real" lang="c99">
            <title>Square root of a negative real without NaN</title>
            <code><![CDATA[
#include <complex.h>

double complex sqrt_neg(double x) {
    /* If x is negative real, csqrt produces an imaginary result. */
    return csqrt(x + 0.0 * I);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ccos" name="ccos" kind="function">
        <signature>double complex ccos(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex cosine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ccos.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex cosine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csin" name="csin" kind="function">
        <signature>double complex csin(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex sine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csin.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex sine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ctan" name="ctan" kind="function">
        <signature>double complex ctan(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex tangent of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ctan.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ccosh" name="ccosh" kind="function">
        <signature>double complex ccosh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic cosine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ccosh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic cosine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csinh" name="csinh" kind="function">
        <signature>double complex csinh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic sine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csinh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic sine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ctanh" name="ctanh" kind="function">
        <signature>double complex ctanh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic tangent of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ctanh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.complex.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the complex.h functions you listed, documented in their double-complex forms for portability and consistency.
</p>
]]></summary>
      </function>
    </header>

    <header id="hdr.fenv" name="fenv.h">
      <summary><![CDATA[
<p>
Floating-point environment control: clear, raise, test, and save/restore floating exceptions and control rounding modes.
This is used in numerically sensitive code (validation, reproducibility, and error detection) and requires careful attention to compiler settings.
</p>
]]></summary>

      <function id="fn.feclearexcept" name="feclearexcept" kind="function">
        <signature>int feclearexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Clears the floating-point exception flags specified by <code>excepts</code>.</p>
]]></summary>
        <parameters>
          <param id="p.feclearexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>
Bitmask of exceptions, typically combining <code>FE_INVALID</code>, <code>FE_DIVBYZERO</code>, <code>FE_OVERFLOW</code>, <code>FE_UNDERFLOW</code>, <code>FE_INEXACT</code>.
You may also use <code>FE_ALL_EXCEPT</code>.
</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero if the operation is not supported for the requested flags.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fegetexceptflag" name="fegetexceptflag" kind="function">
        <signature>int fegetexceptflag(fexcept_t *flagp, int excepts);</signature>
        <summary><![CDATA[
<p>Stores the state of specified exception flags into <code>*flagp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fegetexceptflag.flagp" name="flagp" direction="out" type="fexcept_t*">
            <description><![CDATA[
<p>Receives an opaque snapshot of the requested exception flags.</p>
]]></description>
            <constraints>
              <constraint id="c.fegetexceptflag.nonnull" severity="important">
                <description><![CDATA[
<p><code>flagp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fegetexceptflag.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask selecting which exception flags to snapshot.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feraiseexcept" name="feraiseexcept" kind="function">
        <signature>int feraiseexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Raises the floating-point exceptions specified by <code>excepts</code>.</p>
]]></summary>
        <parameters>
          <param id="p.feraiseexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask of exceptions to raise.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure or if unsupported.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fesetexceptflag" name="fesetexceptflag" kind="function">
        <signature>int fesetexceptflag(const fexcept_t *flagp, int excepts);</signature>
        <summary><![CDATA[
<p>Sets the exception flags specified by <code>excepts</code> to the state stored in <code>*flagp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fesetexceptflag.flagp" name="flagp" direction="in" type="const fexcept_t*">
            <description><![CDATA[
<p>Pointer to a previously captured exception-flag snapshot.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetexceptflag.nonnull" severity="important">
                <description><![CDATA[
<p><code>flagp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fesetexceptflag.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask selecting which exception flags to update.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fetestexcept" name="fetestexcept" kind="function">
        <signature>int fetestexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Tests which of the specified floating-point exception flags are currently set.</p>
]]></summary>
        <parameters>
          <param id="p.fetestexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask of exceptions to test (or <code>FE_ALL_EXCEPT</code>).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Bitwise OR of the exceptions that are currently set among those requested.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fenv.detect_domain_error" lang="c99">
            <title>Detect invalid operation using fenv around a computation</title>
            <code><![CDATA[
#include <math.h>
#include <fenv.h>

int sqrt_checked(double x, double* out) {
    (void)feclearexcept(FE_ALL_EXCEPT);

    double r = sqrt(x);

    if (fetestexcept(FE_INVALID)) {
        return 0;
    }

    *out = r;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fegetround" name="fegetround" kind="function">
        <signature>int fegetround(void);</signature>
        <summary><![CDATA[
<p>Gets the current floating-point rounding mode.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>One of <code>FE_TONEAREST</code>, <code>FE_DOWNWARD</code>, <code>FE_UPWARD</code>, <code>FE_TOWARDZERO</code> (values are implementation-defined).</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fesetround" name="fesetround" kind="function">
        <signature>int fesetround(int round);</signature>
        <summary><![CDATA[
<p>Sets the floating-point rounding mode.</p>
]]></summary>
        <parameters>
          <param id="p.fesetround.round" name="round" direction="in" type="int">
            <description><![CDATA[
<p>Requested rounding mode, typically one of <code>FE_TONEAREST</code>, <code>FE_DOWNWARD</code>, <code>FE_UPWARD</code>, <code>FE_TOWARDZERO</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetround.valid" severity="important">
                <description><![CDATA[
<p>Pass a supported rounding mode. If unsupported, the function returns non-zero and the rounding mode may remain unchanged.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fesetround_scope" lang="c99">
            <title>Temporarily change rounding mode and restore it</title>
            <code><![CDATA[
#include <fenv.h>
#include <math.h>

double round_down_then_restore(double x) {
    fenv_t env;
    if (fegetenv(&env) != 0) {
        return floor(x);
    }

    if (fesetround(FE_DOWNWARD) != 0) {
        return floor(x);
    }

    double r = rint(x);

    (void)fesetenv(&env);
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fegetenv" name="fegetenv" kind="function">
        <signature>int fegetenv(fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Stores the current floating-point environment into <code>*envp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fegetenv.envp" name="envp" direction="out" type="fenv_t*">
            <description><![CDATA[
<p>Receives an opaque snapshot of the floating-point environment.</p>
]]></description>
            <constraints>
              <constraint id="c.fegetenv.nonnull" severity="important">
                <description><![CDATA[
<p><code>envp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feholdexcept" name="feholdexcept" kind="function">
        <signature>int feholdexcept(fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Saves the current environment to <code>*envp</code>, then clears exception flags and may install a non-stop mode.</p>
]]></summary>
        <parameters>
          <param id="p.feholdexcept.envp" name="envp" direction="out" type="fenv_t*">
            <description><![CDATA[
<p>Receives the saved environment.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.feholdexcept_isolate" lang="c99">
            <title>Isolate floating exceptions during a sensitive calculation</title>
            <code><![CDATA[
#include <math.h>
#include <fenv.h>

int compute_isolated(double x, double* out, int* excepts_out) {
    fenv_t env;
    if (feholdexcept(&env) != 0) return 0;

    double r = log(x);

    int ex = fetestexcept(FE_ALL_EXCEPT);

    (void)feupdateenv(&env); /* Restore and re-raise exceptions that occurred. */

    *out = r;
    *excepts_out = ex;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fesetenv" name="fesetenv" kind="function">
        <signature>int fesetenv(const fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Restores the floating-point environment from <code>*envp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fesetenv.envp" name="envp" direction="in" type="const fenv_t*">
            <description><![CDATA[
<p>Previously saved environment snapshot.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetenv.nonnull" severity="important">
                <description><![CDATA[
<p><code>envp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feupdateenv" name="feupdateenv" kind="function">
        <signature>int feupdateenv(const fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Restores the environment from <code>*envp</code> and then raises any exceptions that were set when the function was called.</p>
]]></summary>
        <parameters>
          <param id="p.feupdateenv.envp" name="envp" direction="in" type="const fenv_t*">
            <description><![CDATA[
<p>Previously saved environment snapshot.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fenv.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the fenv.h functions you listed. Exception and rounding behavior can be sensitive to compiler settings,
so document build constraints when these facilities are part of correctness.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

    <script id="library-xml-2026-01-23T17-29-14-b800cfeb-732b-4665-8987-5df0fd3aab5b" type="application/xml"><document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="pre" kind="block"/>
        <tag name="ul" kind="block"/>
        <tag name="ol" kind="block"/>
        <tag name="li" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;pre&gt;&lt;code&gt; blocks for code samples in text content.</r>
      </restrictions>
    </policy>
  </textFormatting>
  <category id="c99.idioms" name="C99 idioms and patterns">
    <summary><![CDATA[
<p>
Curated C99 programming idioms and reusable patterns. Each entry captures a portable, implementation-ready pattern
with a concise description and a focused code example.
</p>
<p>
Search for <code>idiom: &lt;name&gt;</code> to find a specific pattern, or use the idiom name directly to jump to its card.
</p>
]]></summary>

    <keywords>
      <kw>idiom</kw>
      <kw>idioms</kw>
      <kw>pattern</kw>
      <kw>patterns</kw>
      <kw>&quot;Advance before use&quot; scanning with assignment in the condition</kw>
      <kw>&quot;Append pointer&quot; pattern for building strings efficiently</kw>
      <kw>&quot;Close on success, free on failure&quot; with ownership transfer</kw>
      <kw>&quot;do while&quot; loop</kw>
      <kw>&quot;Flexible array member&quot; for variable-sized structs (C99 feature)</kw>
      <kw>&quot;Inline constant struct&quot; as a default value without macros</kw>
      <kw>&quot;Length-limited string scan&quot; without copying</kw>
      <kw>&quot;Loop that guarantees at least one iteration&quot; with `do { } while (0)` (not just for macros)</kw>
      <kw>&quot;One definition of a flag set&quot; via an enum and bit masks</kw>
      <kw>&quot;Optional output&quot; pointers with a simple guard</kw>
      <kw>&quot;Return value capture&quot; so you do not lose error information</kw>
      <kw>&quot;Sentinel at end&quot; arrays for tables of variable length</kw>
      <kw>&quot;Two-pointer&quot; walk for in-place filtering/compaction</kw>
      <kw>&quot;User data&quot; callbacks (poor man&apos;s closures)</kw>
      <kw>`enum` as compile-time integer constants</kw>
      <kw>`fgets` loop with newline trimming in one place</kw>
      <kw>`memchr` as a fast &quot;find delimiter in bytes&quot;</kw>
      <kw>`offsetof` from `&lt;stddef.h&gt;` for layout-aware code</kw>
      <kw>`realloc` with a temporary to avoid losing the original pointer on failure</kw>
      <kw>`snprintf` for bounded formatting and detecting truncation</kw>
      <kw>`sscanf` is tempting, but `strto*` with end pointers composes better</kw>
      <kw>`volatile` only for hardware/async boundaries, not for &quot;thread safety&quot;</kw>
      <kw>Abort program execution with error condition</kw>
      <kw>Add LSB-first digit arrays with carry</kw>
      <kw>Align up/down with power-of-two alignment (common, but easy to botch)</kw>
      <kw>Allocate 1M bytes</kw>
      <kw>Allocate using the pointed-to type, not repeating the type name</kw>
      <kw>Array difference using binary search lookup</kw>
      <kw>Assert condition</kw>
      <kw>Assign to string the japanese word </kw>
      <kw>Assignment in condition to express &quot;read then test&quot;</kw>
      <kw>Binary digits to byte array</kw>
      <kw>Binary search in sorted array</kw>
      <kw>Binomial coefficient &quot;n choose k&quot;</kw>
      <kw>Bitset membership with unsigned shifts (avoid UB on signed)</kw>
      <kw>Boolean normalization with `!!`</kw>
      <kw>Branchless &quot;is power of two&quot; (and exclude 0)</kw>
      <kw>Break outer loop</kw>
      <kw>Byte extraction with masks and shifts (portable endianness-agnostic logic)</kw>
      <kw>Bytes to hex string</kw>
      <kw>Calculate exponentiation of real numbers</kw>
      <kw>Call an external C function</kw>
      <kw>Character stack with flexible array member</kw>
      <kw>Check for overflow before multiply/add (portable pattern)</kw>
      <kw>Check if any value in a list is larger than a limit</kw>
      <kw>Check if file exists</kw>
      <kw>Check if integer addition will overflow</kw>
      <kw>Check if integer is even</kw>
      <kw>Check if list contains a value</kw>
      <kw>Check if point is inside rectangle</kw>
      <kw>Check if string contains a word</kw>
      <kw>Check if string contains only digits</kw>
      <kw>Check if string is blank</kw>
      <kw>Check palindrome in byte array</kw>
      <kw>Check string prefix</kw>
      <kw>Clamp a value to a range</kw>
      <kw>Comment out a single line</kw>
      <kw>Compile-time array length (ARRAY_LEN/ARRAY_SIZE)</kw>
      <kw>Compile-time assertion (typedef trick)</kw>
      <kw>Complex number</kw>
      <kw>Compound literals for &quot;temporary objects with an address&quot;</kw>
      <kw>Compute GCD</kw>
      <kw>Compute LCM</kw>
      <kw>Compute sum of integers</kw>
      <kw>Conditional assignment</kw>
      <kw>Container-of pattern (common, but not standard-library provided)</kw>
      <kw>Continue outer loop</kw>
      <kw>Convert integer to floating point number</kw>
      <kw>Convert integer to string</kw>
      <kw>Convert real number to string with 2 decimal places</kw>
      <kw>Convert string to camelCase</kw>
      <kw>Convert string to integer</kw>
      <kw>Convert string to integer, explicit base</kw>
      <kw>Copy string into buffer with capacity and null-terminate</kw>
      <kw>Count backwards</kw>
      <kw>Count decimal digits in integer</kw>
      <kw>Count set bits (popcount)</kw>
      <kw>Count substring occurrences</kw>
      <kw>Count trailing zero bits</kw>
      <kw>Counted push with post-increment (your pattern) plus the &quot;guard&quot; form</kw>
      <kw>Create a 2-dimensional array</kw>
      <kw>Create a 2D Point data structure</kw>
      <kw>Create a 3-dimensional array</kw>
      <kw>Create a Binary Tree data structure</kw>
      <kw>Create a function</kw>
      <kw>Create a map (associative array)</kw>
      <kw>Create a procedure</kw>
      <kw>Create a Tree data structure</kw>
      <kw>Create temp file</kw>
      <kw>ctype functions: cast to unsigned char, and do not pass pointers</kw>
      <kw>Current executable name</kw>
      <kw>Custom allocation hooks via macros (malloc/free/realloc)</kw>
      <kw>Date struct with year/month/day fields</kw>
      <kw>Days in month with leap-year adjustment</kw>
      <kw>Days since 1971-01-01 for date</kw>
      <kw>Debug logging macro (compiled out in release)</kw>
      <kw>Declare an enumeration</kw>
      <kw>Declare constant string</kw>
      <kw>Deduplicate sorted array in place</kw>
      <kw>Delete file</kw>
      <kw>Depth-first traversal in a graph</kw>
      <kw>Designated initializers to document intent and avoid field-order coupling</kw>
      <kw>Detect zero digit in base-10 representation</kw>
      <kw>Dynamic int array with capacity growth</kw>
      <kw>Echo program implementation</kw>
      <kw>Execute procedures depending on options</kw>
      <kw>Exit program cleanly (EXIT_SUCCESS)</kw>
      <kw>Extract a substring</kw>
      <kw>Extract file content to a string</kw>
      <kw>Find substring position</kw>
      <kw>Fixed-capacity positive decimal digit buffer (LSB-first)</kw>
      <kw>Flexible &quot;build up an initializer&quot; with trailing commas</kw>
      <kw>Format a number with grouped thousands</kw>
      <kw>Format decimal number</kw>
      <kw>Formula with arrays</kw>
      <kw>Free and null a pointer</kw>
      <kw>Get an environment variable</kw>
      <kw>Get current date</kw>
      <kw>Get file size</kw>
      <kw>Get folder containing current program</kw>
      <kw>Get program working directory</kw>
      <kw>Handle invalid argument</kw>
      <kw>Hex dump loop that is careful about signedness</kw>
      <kw>Hex string to byte array</kw>
      <kw>Hexadecimal digits of an integer</kw>
      <kw>Increment decimal digit array in place</kw>
      <kw>Integer exponentiation by squaring</kw>
      <kw>Interleave halves of array</kw>
      <kw>Iterate over list indexes and values</kw>
      <kw>Iterate over list values</kw>
      <kw>Join a list of strings</kw>
      <kw>Join integer from LSB-first digit array</kw>
      <kw>Last element of list</kw>
      <kw>Launch other program</kw>
      <kw>Leap year check (Gregorian 4/100/400 rule)</kw>
      <kw>List files in directory</kw>
      <kw>Local static for expensive one-time setup inside a function</kw>
      <kw>Make an infinite loop</kw>
      <kw>Measure elapsed CPU time</kw>
      <kw>Memset a struct via its address, not by casting</kw>
      <kw>Multi-line string literal</kw>
      <kw>Multiple return values</kw>
      <kw>Multiply all the elements of a list</kw>
      <kw>Number of bytes of a type</kw>
      <kw>Packed bitset with test/set/clear</kw>
      <kw>Parenthesis classification and matching</kw>
      <kw>Parse integer digits to LSB-first array</kw>
      <kw>Parse ISO date string YYYY-MM-DD with validation</kw>
      <kw>Parse uint32 from ASCII decimal string (validated)</kw>
      <kw>Parse with `strtol` and keep the end pointer in the loop header</kw>
      <kw>Pass a runnable procedure as parameter</kw>
      <kw>Pause execution for 5 seconds</kw>
      <kw>Pick a random element from a list</kw>
      <kw>Pick uniformly a random floating point number in [a..b)</kw>
      <kw>Pick uniformly a random integer in [a..b]</kw>
      <kw>Pointer iteration over array with end pointer</kw>
      <kw>Preserve `errno` across cleanup that might clobber it</kw>
      <kw>Print `size_t` and pointers correctly</kw>
      <kw>Print Hello 10 times</kw>
      <kw>Print Hello World</kw>
      <kw>Print integer array with brackets</kw>
      <kw>Print list elements by group of 2</kw>
      <kw>Public declaration macro for C/C++ linkage (extern/static)</kw>
      <kw>Quine program</kw>
      <kw>Read command line argument</kw>
      <kw>Read file line by line</kw>
      <kw>Read integer from stdin</kw>
      <kw>Recursive factorial (simple)</kw>
      <kw>Rename file</kw>
      <kw>Repeated string</kw>
      <kw>Resize dynamic array safely</kw>
      <kw>Result code enum for success/failure</kw>
      <kw>Return fraction and exponent of a real number</kw>
      <kw>Return static string literal</kw>
      <kw>Return status/error code with output parameters</kw>
      <kw>Reverse a string</kw>
      <kw>Reverse array/list in place</kw>
      <kw>Reverse loop without unsigned underflow traps</kw>
      <kw>Roman numeral conversion (char map + subtractive parse)</kw>
      <kw>Round floating point number to integer</kw>
      <kw>Safe memory allocation</kw>
      <kw>Safe string copy with truncation</kw>
      <kw>Seed random generator</kw>
      <kw>Set, clear, and test a bit</kw>
      <kw>Shuffle a list</kw>
      <kw>Simple stack using array</kw>
      <kw>Single-exit cleanup with `goto`</kw>
      <kw>Single-header library with implementation macro and feature toggles</kw>
      <kw>Size-in, size-out for buffers (and report required size)</kw>
      <kw>Sort by a comparator (qsort/bsearch)</kw>
      <kw>Source code inclusion</kw>
      <kw>Sparse array initialization with designated indices</kw>
      <kw>Split a space-separated string</kw>
      <kw>Strict aliasing safe type-punning: use `memcpy`, not pointer casts</kw>
      <kw>String interpolation</kw>
      <kw>Stringize and concatenate for generating names and messages</kw>
      <kw>Successive conditions</kw>
      <kw>Sum digits in array</kw>
      <kw>Swap values via temporary</kw>
      <kw>Switch-driven state machine with intentional fallthrough</kw>
      <kw>Test if string is empty</kw>
      <kw>The canonical &quot;walk a C string&quot; pointer loop</kw>
      <kw>The comma operator for tight loops (use sparingly)</kw>
      <kw>The do-while(0) macro wrapper so statements behave like statements</kw>
      <kw>Tokenize without `strtok` by using `strcspn` and manual slicing</kw>
      <kw>Trim prefix</kw>
      <kw>Trim whitespace in place (two pointers)</kw>
      <kw>Truncate floating point number to integer</kw>
      <kw>Turn a character into a string</kw>
      <kw>Use `__FILE__` and `__LINE__` for trace points</kw>
      <kw>Use `const` to document and enforce read-only inputs</kw>
      <kw>Use `restrict` (C99) when you can prove non-aliasing</kw>
      <kw>Use `sizeof (type){0}` to get a type size without naming an object</kw>
      <kw>Use clock as random generator seed</kw>
      <kw>Use scansets in `sscanf` when you really do want it (bounded)</kw>
      <kw>Write to standard error stream</kw>
      <kw>X-macro tables: one list, many derived artifacts</kw>
      <kw>Xor integers</kw>
      <kw>Zero-initialize heap allocation with calloc</kw>
      <kw>Zero-initialize scalars and aggregates with `{0}` (and know what it really does)</kw>
    </keywords>

    <header id="hdr.idioms" name="Idioms">
      <summary><![CDATA[
<p>
Idioms are small, reusable C patterns for correctness, clarity, and portability. The entries below are aggregated
from multiple sources and merged into a single consistent format.
</p>
]]></summary>

    <function id="fn.idiom.id-0001" name="idiom: &quot;Advance before use&quot; scanning with assignment in the condition" kind="idiom">
      <signature>const unsigned char* p;</signature>
      <summary><![CDATA[<p>This compresses scanning code, and ensures the increment is not accidentally duplicated. The pointer <code>p</code> must point to a valid null-terminated sequence. The loop advances <code>p</code> and reads the character in one expression, stopping at the null terminator (0).</p>]]></summary>
      <examples>
        <example id="ex.id-0001.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
/* Scan a null-terminated string */
const unsigned char* p = (const unsigned char*)buffer;  /* buffer is null-terminated */
int c;
while ((c = *p++) != 0) {
    /* use c - p has already advanced */
    process_char(c);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0002" name="idiom: &quot;Append pointer&quot; pattern for building strings efficiently" kind="idiom">
      <signature>char out[256];</signature>
      <summary><![CDATA[<p>This keeps the write position explicit and avoids repeated <code>strlen</code>. Always check <code>snprintf</code> return values to detect truncation and prevent advancing the write pointer past the end of the buffer.</p>]]></summary>
      <examples>
        <example id="ex.id-0002.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int x = 42;
int y = 100;
char out[256] = {0};  /* initialize buffer */
char* w = out;
char* e = out + sizeof out;

int n = snprintf(w, (size_t)(e - w), "x=%d ", x);
if (n > 0 && (size_t)n < (size_t)(e - w)) w += n;
else goto truncated;  /* stop on truncation */

n = snprintf(w, (size_t)(e - w), "y=%d", y);
if (n > 0 && (size_t)n < (size_t)(e - w)) w += n;
else goto truncated;

*w = '\0';  /* final null terminator ensured */
/* out now contains "x=42 y=100" */

truncated:
/* handle truncation */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0003" name="idiom: &quot;Close on success, free on failure&quot; with ownership transfer" kind="idiom">
      <signature>int allocate_and_transfer(size_t n, char** out);</signature>
      <summary><![CDATA[<p>Setting the local to 0 after transfer prevents double-free in a shared cleanup block. On success, transfer ownership to the caller; on failure, free locally allocated resources.</p>]]></summary>
      <examples>
        <example id="ex.id-0003.1" lang="c99">
          <title>Example - Memory transfer</title>
          <code><![CDATA[
#include <stdlib.h>

int allocate_and_transfer(size_t n, char** out) {
    char* buf = malloc(n);
    if (!buf) return -1;

    /* ... work with buf ... */

    *out = buf;   /* transfer ownership to caller */
    buf = NULL;   /* prevent accidental free in cleanup */
    return 0;
}
]]></code>
        </example>
        <example id="ex.id-0003.2" lang="c99">
          <title>Example - File handle transfer</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>

int open_and_transfer(const char* path, FILE** out) {
    FILE* f = NULL;
    char* buf = NULL;

    f = fopen(path, "r");
    if (!f) goto fail;

    buf = malloc(1024);
    if (!buf) goto fail;

    /* ... work with f and buf ... */

    *out = f;     /* transfer ownership to caller */
    f = NULL;     /* prevent close in cleanup */
    free(buf);    /* free local buffer */
    return 0;

fail:
    if (f) fclose(f);  /* close on failure */
    free(buf);         /* free on failure */
    return -1;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0004" name="idiom: &quot;do while&quot; loop" kind="idiom">
      <signature>void repeat_action(int* value) {</signature>
      <summary><![CDATA[<p>Execute a block of code at least once and repeat while a condition remains true.</p>]]></summary>
      <notes>
        <note id="note.id-0004.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/78/do-while-loop">https://programming-idioms.org/idiom/78/do-while-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0004.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void repeat_action(int* value) {
    do {
        (*value)++;
    } while (*value < 10);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0005" name="idiom: &quot;Flexible array member&quot; for variable-sized structs (C99 feature)" kind="idiom">
      <signature>typedef struct stack_char_fla {</signature>
      <summary><![CDATA[<p>Fixed-capacity character stack using flexible array member.<br>Provides a simple LIFO container for character data with allocation at creation time.</p><p>Compact bitset using uint8_t array with flexible array member.<br>Stores bits packed into bytes, providing efficient storage for boolean flags.<br>Bit indices are zero-based; bit i resides in items[i/8] at position (i%8).</p><p>This keeps header and payload contiguous and cache-friendly. Always calculate the total size as <code>sizeof(struct) + (element_count * sizeof(element))</code> and check for malloc failure.</p>]]></summary>
      <examples>
        <example id="ex.id-0005.1" lang="c99">
          <title>Example 1 - Stack with allocation and usage</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

typedef struct stack_char_fla {
    size_t capacity; /* maximum number of characters the stack can hold */
    size_t count; /* current number of characters in the stack */
    char items[]; /* flexible array member for character storage */
} stack_char_fla;

/* Allocate stack with given capacity */
stack_char_fla* create_stack(size_t capacity) {
    stack_char_fla* s = malloc(sizeof(*s) + capacity * sizeof(s->items[0]));
    if (!s) return NULL;
    s->capacity = capacity;
    s->count = 0;
    return s;
}

/* Usage */
void example_usage(void) {
    stack_char_fla* stack = create_stack(100);
    if (!stack) return;

    /* Use stack */
    if (stack->count < stack->capacity) {
        stack->items[stack->count++] = 'a';
    }

    free(stack);  /* Free when done */
}
]]></code>
        </example>
        <example id="ex.id-0005.2" lang="c99">
          <title>Example 2 - Bitset</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>

typedef struct bitset {
    size_t bytes_capacity; /* number of bytes allocated in items[] */
    size_t bits_capacity; /* maximum number of bits that can be stored */
    uint8_t items[]; /* flexible array member for bit storage */
} bitset;

bitset* create_bitset(size_t num_bits) {
    size_t bytes = (num_bits + 7) / 8;
    bitset* bs = malloc(sizeof(*bs) + bytes * sizeof(bs->items[0]));
    if (!bs) return NULL;
    bs->bytes_capacity = bytes;
    bs->bits_capacity = num_bits;
    for (size_t i = 0; i < bytes; i++) bs->items[i] = 0;
    return bs;
}
]]></code>
        </example>
        <example id="ex.id-0005.3" lang="c99">
          <title>Example 3 - Message buffer</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

struct Msg {
    uint32_t len;
    unsigned char data[];   /* flexible array */
};

struct Msg* create_message(const unsigned char* payload, uint32_t payload_len) {
    struct Msg* m = malloc(sizeof(*m) + payload_len);
    if (!m) return NULL;  /* check allocation */

    m->len = payload_len;
    memcpy(m->data, payload, payload_len);
    return m;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0006" name="idiom: &quot;Inline constant struct&quot; as a default value without macros" kind="idiom">
      <signature>static const struct Limits default_limits = { .min = 0, .max = 100 };</signature>
      <summary><![CDATA[<p>You get a single source of truth and avoid repeating the initializer.</p>]]></summary>
      <examples>
        <example id="ex.id-0006.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
struct Limits {
    int min;
    int max;
};

static const struct Limits default_limits = { .min = 0, .max = 100 };

void use_defaults(void) {
    struct Limits lim = default_limits;  /* copy default values */
    /* work with lim */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0007" name="idiom: &quot;Length-limited string scan&quot; without copying" kind="idiom">
      <signature>size_t i = 0;</signature>
      <summary><![CDATA[<p>This is the safe pattern for possibly unterminated data. The buffer <code>buf</code> may not be null-terminated, and <code>n</code> is the maximum valid length to scan.</p>]]></summary>
      <examples>
        <example id="ex.id-0007.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

/* buf may not be null-terminated; n is the buffer capacity */
const unsigned char* buf = get_unterminated_buffer();
size_t n = get_buffer_length();

size_t i = 0;
for (; i < n && buf[i] != '\0'; ++i) {
    /* process buf[i] */
}
/* i now holds the length found, or n if no null terminator */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0008" name="idiom: &quot;Loop that guarantees at least one iteration&quot; with `do { } while (0)` (not just for macros)" kind="idiom">
      <signature>do {</signature>
      <summary><![CDATA[<p>It reads like structured early-exit without introducing <code>goto</code> yet. The <code>do { } while (0)</code> pattern allows early exit via <code>break</code> while ensuring at least one attempt is made.</p>]]></summary>
      <examples>
        <example id="ex.id-0008.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

bool init(void);   /* returns true on success */
bool step(void);   /* returns true on success */
void finish(void); /* cleanup/finalization */

void process_with_early_exit(void) {
    do {
        if (!init()) break;   /* exit early on init failure */
        if (!step()) break;   /* exit early on step failure */
        finish();             /* only runs if both init and step succeed */
    } while (0);

    /* continue here regardless of break */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0009" name="idiom: &quot;One definition of a flag set&quot; via an enum and bit masks" kind="idiom">
      <signature>enum {</signature>
      <summary><![CDATA[<p>This is a clean, debugger-friendly alternative to raw <code>#define</code> flags.</p>]]></summary>
      <examples>
        <example id="ex.id-0009.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
enum {
    F_READ  = 1u << 0,
    F_WRITE = 1u << 1,
    F_EXEC  = 1u << 2,
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0010" name="idiom: &quot;Optional output&quot; pointers with a simple guard" kind="idiom">
      <signature>int compute(int* out_value);</signature>
      <summary><![CDATA[<p>This gives callers flexibility without multiplying function variants. Callers can pass NULL to skip optional outputs.</p>]]></summary>
      <examples>
        <example id="ex.id-0010.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int compute(int* out_value) {
    int v = 42;  /* computed value */

    /* Only write to output if caller provided a pointer */
    if (out_value) *out_value = v;

    return 0;  /* status */
}

void usage(void) {
    int result;
    compute(&result);  /* caller wants the value */
    compute(NULL);     /* caller doesn't need the value */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0011" name="idiom: &quot;Return value capture&quot; so you do not lose error information" kind="idiom">
      <signature>int rc = do_work();</signature>
      <summary><![CDATA[<p>Simple, but the important part is: never overwrite <code>rc</code> before you have consumed it. Convention: 0 indicates success, non-zero indicates error.</p>]]></summary>
      <examples>
        <example id="ex.id-0011.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int do_work(void);  /* returns 0 on success, non-zero on error */

int process(void) {
    int rc = do_work();
    if (rc) return rc;  /* propagate error */

    /* continue on success */
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0012" name="idiom: &quot;Sentinel at end&quot; arrays for tables of variable length" kind="idiom">
      <signature>struct KV { const char* k; int v; };</signature>
      <summary><![CDATA[<p>This avoids separately storing a count and is very readable for static tables. The sentinel (zero/NULL entry) marks the end.</p>]]></summary>
      <examples>
        <example id="ex.id-0012.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

struct KV { const char* k; int v; };

static const struct KV kvs[] = {
    { "alpha", 1 },
    { "beta", 2 },
    { "gamma", 3 },
    { NULL, 0 },    /* sentinel: k == NULL marks end */
};

int lookup(const char* key) {
    for (const struct KV* p = kvs; p->k; ++p) {
        if (strcmp(p->k, key) == 0) return p->v;
    }
    return -1;  /* not found */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0013" name="idiom: &quot;Two-pointer&quot; walk for in-place filtering/compaction" kind="idiom">
      <signature>size_t w = 0;</signature>
      <summary><![CDATA[<p>This is the simplest correct in-place filter pattern. The write pointer <code>w</code> trails the read pointer <code>r</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0013.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool keep(int x) {  /* predicate: returns true if element should be kept */
    return x > 0;   /* example: keep positive values */
}

void filter_array(int* xs, size_t* n) {  /* xs has capacity *n */
    size_t w = 0;
    for (size_t r = 0; r < *n; ++r) {
        if (keep(xs[r])) {
            xs[w++] = xs[r];
        }
    }
    *n = w;  /* update count to compacted size */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0014" name="idiom: &quot;User data&quot; callbacks (poor man&apos;s closures)" kind="idiom">
      <signature>typedef int (*visit_fn)(void* user, const struct Node* n);</signature>
      <summary><![CDATA[<p>This is the idiomatic C way to carry context into callbacks. The <code>void* user</code> parameter passes caller context through to the callback.</p>]]></summary>
      <examples>
        <example id="ex.id-0014.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

struct Node {
    int value;
    struct Node* left;
    struct Node* right;
};

typedef int (*visit_fn)(void* user, const struct Node* n);

int walk(const struct Node* root, visit_fn fn, void* user) {
    if (!root) return 0;
    int rc = fn(user, root);
    if (rc) return rc;
    if ((rc = walk(root->left, fn, user))) return rc;
    return walk(root->right, fn, user);
}

/* Example usage with context */
struct Counter { int count; };

int count_nodes(void* user, const struct Node* n) {
    struct Counter* ctx = (struct Counter*)user;
    ctx->count++;
    return 0;  /* continue */
}

void example(const struct Node* tree) {
    struct Counter ctx = {0};
    walk(tree, count_nodes, &ctx);
    /* ctx.count now holds node count */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0015" name="idiom: `enum` as compile-time integer constants" kind="idiom">
      <signature>enum { BUF_SZ = 4096, MAX_RETRIES = 5 };</signature>
      <summary><![CDATA[<p>Unlike macros, <code>enum</code> constants participate in the language and show up better in debuggers.</p>]]></summary>
      <examples>
        <example id="ex.id-0015.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
enum { BUF_SZ = 4096, MAX_RETRIES = 5 };
unsigned char buf[BUF_SZ];
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0016" name="idiom: `fgets` loop with newline trimming in one place" kind="idiom">
      <signature>while (fgets(line, sizeof line, fp)) {</signature>
      <summary><![CDATA[<p>This avoids repeated ad hoc newline logic. The <code>strcspn</code> idiom finds the newline and replaces it with null terminator.</p>]]></summary>
      <examples>
        <example id="ex.id-0016.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <string.h>

void process_file(const char* path) {
    FILE* fp = fopen(path, "r");
    if (!fp) return;

    char line[1024];
    while (fgets(line, sizeof line, fp)) {
        line[strcspn(line, "\n")] = '\0';  /* trim newline */
        /* use line */
        process_line(line);
    }
    fclose(fp);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0017" name="idiom: `memchr` as a fast &quot;find delimiter in bytes&quot;" kind="idiom">
      <signature>const unsigned char* q = memchr(p, &apos;\n&apos;, (size_t)(end - p));</signature>
      <summary><![CDATA[<p>Useful for scanning non-null-terminated buffers, unlike <code>strchr</code>. The <code>end</code> pointer marks one past the last valid byte.</p>]]></summary>
      <examples>
        <example id="ex.id-0017.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

void scan_buffer(const unsigned char* buffer, size_t len) {
    const unsigned char* p = buffer;
    const unsigned char* end = buffer + len;

    const unsigned char* q = memchr(p, '\n', (size_t)(end - p));
    if (q) {
        /* found newline at position q */
        size_t line_len = q - p;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0018" name="idiom: `offsetof` from `&lt;stddef.h&gt;` for layout-aware code" kind="idiom">
      <signature>size_t off = offsetof(struct S, member);</signature>
      <summary><![CDATA[<p>This is standard and safer than home-grown offset macros.</p>]]></summary>
      <examples>
        <example id="ex.id-0018.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

struct S {
    int a;
    char b;
    double c;
};

size_t off = offsetof(struct S, c);
/* off now contains the byte offset of member 'c' within struct S */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0019" name="idiom: `realloc` with a temporary to avoid losing the original pointer on failure" kind="idiom">
      <signature>void* tmp = realloc(p, n);</signature>
      <summary><![CDATA[<p>This is one of the highest-value C habits you can adopt. Always use a temporary to avoid losing the original pointer if realloc fails.</p>]]></summary>
      <examples>
        <example id="ex.id-0019.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int resize_buffer(void** p, size_t n) {
    void* tmp = realloc(*p, n);
    if (!tmp) {
        /* *p still valid, caller must free */
        return -1;
    }
    *p = tmp;  /* update pointer on success */
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0020" name="idiom: `snprintf` for bounded formatting and detecting truncation" kind="idiom">
      <signature>int m = snprintf(dst, dst_sz, &quot;%s/%s&quot;, a, b);</signature>
      <summary><![CDATA[<p>The return value is the size that would have been written (excluding null terminator), which makes it easy to detect truncation. <code>dst_sz</code> includes space for the null terminator.</p>]]></summary>
      <examples>
        <example id="ex.id-0020.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void build_path(char* dst, size_t dst_sz, const char* a, const char* b) {
    int m = snprintf(dst, dst_sz, "%s/%s", a, b);
    if (m < 0 || (size_t)m >= dst_sz) {
        /* truncated or error */
        handle_truncation();
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0021" name="idiom: `sscanf` is tempting, but `strto*` with end pointers composes better" kind="idiom">
      <signature>char* end;</signature>
      <summary><![CDATA[<p>This avoids format-string corner cases and gives you precise control. The end pointer lets you detect parse errors and continue parsing.</p>]]></summary>
      <examples>
        <example id="ex.id-0021.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <ctype.h>

void parse_numbers(const char* input) {
    char* p = (char*)input;
    char* end;

    while (*p) {
        long v = strtol(p, &end, 10);
        if (end == p) break;  /* not a number, stop */

        /* use v */
        process_value(v);

        p = end;
        /* skip whitespace/separators */
        while (*p && (isspace(*p) || *p == ',')) p++;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0022" name="idiom: `volatile` only for hardware/async boundaries, not for &quot;thread safety&quot;" kind="idiom">
      <signature>volatile uint32_t* reg = (volatile uint32_t*)0x40000000u;</signature>
      <summary><![CDATA[<p>This is a pattern you see in embedded C; the key is knowing that <code>volatile</code> is not a concurrency primitive. Use it only for memory-mapped hardware registers or signal handlers. The example address is platform-specific.</p>]]></summary>
      <examples>
        <example id="ex.id-0022.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdint.h>

/* Platform-specific address (example only) */
#define GPIO_BASE 0x40000000u

struct GPIO_Regs {
    volatile uint32_t DIR;     /* direction register */
    volatile uint32_t DATA;    /* data register */
    volatile uint32_t SET;     /* set bits */
    volatile uint32_t CLR;     /* clear bits */
};

void configure_gpio(void) {
    struct GPIO_Regs* gpio = (struct GPIO_Regs*)GPIO_BASE;
    gpio->DIR = 0xFF;   /* volatile ensures write is not optimized away */
    gpio->SET = 0x01;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0023" name="idiom: Abort program execution with error condition" kind="idiom">
      <signature>void abort_with_error(int code) {</signature>
      <summary><![CDATA[<p>Terminate the program immediately with a non-zero exit status.</p>]]></summary>
      <notes>
        <note id="note.id-0023.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/198/abort-program-execution-with-error-condition">https://programming-idioms.org/idiom/198/abort-program-execution-with-error-condition</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0023.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void abort_with_error(int code) {
    exit(code);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0024" name="idiom: Add LSB-first digit arrays with carry" kind="idiom">
      <signature>result digits_add_lsb_first(const unsigned char* a,</signature>
      <summary><![CDATA[<p>Adds two non-negative integers represented as base-10 digit arrays stored LSB-first.<br>Inputs:<br>a[0..a_size) and b[0..b_size) hold digits with a[0] the least significant digit.<br>Output:<br>Writes the sum into out[0..*out_size) also LSB-first.<br>On success returns RESULT_SUCCESS and sets *out_size to the number of digits<br>written (never exceeding out_cap).<br>Failure cases:<br>- Any required pointer is NULL (a/b/out/out_size) while its size is &gt; 0.<br>- out_cap is insufficient for max(a_size, b_size) + 1 potential carry digit.<br>- Any digit validation fails (digit not in [0,9]).<br>In these cases returns RESULT_FAILED. Note: *out_size is left unmodified on failure,<br>but out[] may contain partial writes if digit validation fails after some writes.<br>For guaranteed no-partial-writes, pre-validate all digits before calling.<br>Notes:<br>- Digits must each be in the range [0,9]; behavior is undefined otherwise.<br>- Accepts zero-length operands (treated as value 0).<br>- This helper is allocation-free and intended for small / medium sized numbers<br>typical in coding challenge contexts.</p>]]></summary>
      <examples>
        <example id="ex.id-0024.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FAILED = 1
} result;

static int digit_ok(unsigned char d) { return d <= 9; }

result digits_add_lsb_first(const unsigned char* a,
                            size_t a_size,
                            const unsigned char* b,
                            size_t b_size,
                            unsigned char* out,
                            size_t out_cap,
                            size_t* out_size) {
    if (!out_size) return RESULT_FAILED;
    if ((a_size && !a) || (b_size && !b) || !out) return RESULT_FAILED;

    size_t need = (a_size > b_size ? a_size : b_size) + 1;
    if (out_cap < need) return RESULT_FAILED;

    size_t i = 0;
    unsigned carry = 0;

    for (; i < a_size || i < b_size; ++i) {
        unsigned da = 0, db = 0;
        if (i < a_size) {
            if (!digit_ok(a[i])) return RESULT_FAILED;
            da = a[i];
        }
        if (i < b_size) {
            if (!digit_ok(b[i])) return RESULT_FAILED;
            db = b[i];
        }

        unsigned sum = da + db + carry;
        out[i] = (unsigned char)(sum % 10u);
        carry = sum / 10u;
    }

    if (carry) {
        out[i++] = (unsigned char)carry;
    } else if (i == 0) {
        out[i++] = 0;
    }

    *out_size = i;
    return RESULT_SUCCESS;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0025" name="idiom: Align up/down with power-of-two alignment (common, but easy to botch)" kind="idiom">
      <signature>size_t align_up(size_t x, size_t a) { return (x + (a - 1)) &amp; ~(a - 1); }</signature>
      <summary><![CDATA[<p>Only valid when <code>a</code> is a power of two and non-zero. Precondition: <code>a &amp;&amp; ((a &amp; (a - 1)) == 0)</code>. Add an assertion or document the requirement explicitly.</p>]]></summary>
      <examples>
        <example id="ex.id-0025.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <assert.h>

size_t align_up(size_t x, size_t a) {
    assert(a && ((a & (a - 1)) == 0));  /* a must be power of two */
    return (x + (a - 1)) & ~(a - 1);
}

size_t align_dn(size_t x, size_t a) {
    assert(a && ((a & (a - 1)) == 0));
    return x & ~(a - 1);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0026" name="idiom: Allocate 1M bytes" kind="idiom">
      <signature>void* allocate_one_megabyte(void) {</signature>
      <summary><![CDATA[<p>Allocate a buffer of one million bytes (1,000,000 bytes, not 1 MiB which is 1,048,576 bytes) from the heap. Caller must check for NULL to handle allocation failure.</p>]]></summary>
      <notes>
        <note id="note.id-0026.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/88/allocate-1m-bytes">https://programming-idioms.org/idiom/88/allocate-1m-bytes</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0026.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void* allocate_one_megabyte(void) {
    return malloc(1000000);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0027" name="idiom: Allocate using the pointed-to type, not repeating the type name" kind="idiom">
      <signature>struct Foo *p = malloc(sizeof *p);</signature>
      <summary><![CDATA[<p>This survives type changes and reduces mismatch errors. Always check for NULL to handle allocation failure.</p>]]></summary>
      <examples>
        <example id="ex.id-0027.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

struct Foo { int x; double y; };

void example(void) {
    struct Foo *p = malloc(sizeof *p);  /* type derived from p */
    if (!p) return;  /* handle allocation failure */

    /* ... use p ... */

    size_t new_count = 10;
    struct Foo *tmp = realloc(p, new_count * sizeof *p);
    if (!tmp) {
        free(p);  /* p still valid */
        return;
    }
    p = tmp;

    free(p);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0028" name="idiom: Array difference using binary search lookup" kind="idiom">
      <signature>size_t array_int_diff(</signature>
      <summary><![CDATA[<p>Finds elements in source that are not present in sorted_lookup array.<br>Inputs:<br>- source[0..source_size): Array to search in.<br>- sorted_lookup[0..lookup_size): Sorted array of values to exclude.<br>- out[0..source_size): Destination buffer for difference elements (caller must ensure capacity &gt;= source_size).<br>Output:<br>- Writes elements from source not found in sorted_lookup into out.<br>- Returns the count of elements written to out.<br>Behavior:<br>- Returns 0 if any required input is invalid (NULL pointers where size &gt; 0).<br>- sorted_lookup must be sorted in ascending order for correct results.<br>- Uses binary search for efficient lookup (O(log m) per element).<br>Example: source=[1,2,3,4], sorted_lookup=[2,4] -&gt; out=[1,3], returns 2.<br>Complexity: O(n log m) where n=source_size, m=lookup_size.</p>]]></summary>
      <examples>
        <example id="ex.id-0028.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

static int sorted_contains_int(const int* xs, size_t n, int v) {
    size_t lo = 0, hi = n;
    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;
        int x = xs[mid];
        if (x == v) return 1;
        if (x < v) lo = mid + 1;
        else hi = mid;
    }
    return 0;
}

size_t array_int_diff(const int* source,
                      size_t source_size,
                      const int* sorted_lookup,
                      size_t lookup_size,
                      int* out) {
    if (!out || !source || source_size == 0 || !sorted_lookup || lookup_size == 0) return 0;

    size_t w = 0;
    for (size_t i = 0; i < source_size; ++i) {
        int v = source[i];
        if (!sorted_contains_int(sorted_lookup, lookup_size, v)) {
            out[w++] = v;
        }
    }
    return w;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0029" name="idiom: Assert condition" kind="idiom">
      <signature>void check_consistency(int is_consistent) {</signature>
      <summary><![CDATA[<p>Verify that a condition holds true during program execution in debug builds.</p>]]></summary>
      <notes>
        <note id="note.id-0029.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/123/assert-condition">https://programming-idioms.org/idiom/123/assert-condition</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0029.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <assert.h>

void check_consistency(int is_consistent) {
    assert(is_consistent);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0030" name="idiom: Assign to string the japanese word " kind="idiom">
      <signature>const char* s = &quot;&quot;;</signature>
      <summary><![CDATA[<p>Initialize a UTF-8 string literal containing non-ASCII characters. String literals are encoded in the source file encoding (typically UTF-8). Console output depends on environment locale and terminal encoding.</p>]]></summary>
      <notes>
        <note id="note.id-0030.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/24/assign-to-string-the-japanese-word">https://programming-idioms.org/idiom/24/assign-to-string-the-japanese-word</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0030.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* s = "";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0031" name="idiom: Assignment in condition to express &quot;read then test&quot;" kind="idiom">
      <signature>while ((n = fread(buf, 1, sizeof buf, fp)) != 0) { /* ... */ }</signature>
      <summary><![CDATA[<p>This is one of the clearest uses of assignment-in-condition: it matches the control flow of I/O. Always check for I/O errors with <code>ferror</code> after the loop.</p>]]></summary>
      <examples>
        <example id="ex.id-0031.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void process_file(const char* path) {
    FILE* fp = fopen(path, "rb");
    if (!fp) return;

    unsigned char buf[4096];
    size_t n;

    while ((n = fread(buf, 1, sizeof buf, fp)) != 0) {
        /* process buf[0..n) */
        handle_data(buf, n);
    }

    if (ferror(fp)) {
        /* I/O error occurred */
        handle_error();
    }

    fclose(fp);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0032" name="idiom: Binary digits to byte array" kind="idiom">
      <signature>unsigned char* binary_to_bytes(const char* bits, size_t* out_count) {</signature>
      <summary><![CDATA[<p>Convert a string of binary digits into a byte array. Input must contain only '0' and '1' characters, and length should be a multiple of 8 for complete bytes. Returns NULL on error.</p>]]></summary>
      <notes>
        <note id="note.id-0032.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/275/binary-digits-to-byte-array">https://programming-idioms.org/idiom/275/binary-digits-to-byte-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0032.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

unsigned char* binary_to_bytes(const char* bits, size_t* out_count) {
    if (!bits || !out_count) return NULL;

    size_t len = strlen(bits);
    if (len % 8 != 0) return NULL;  /* require multiple of 8 */

    /* Validate bits contains only '0' and '1' */
    for (size_t i = 0; i < len; ++i) {
        if (bits[i] != '0' && bits[i] != '1') return NULL;
    }

    size_t count = len / 8;
    unsigned char* bytes = (unsigned char*)calloc(count, 1);
    if (!bytes) return NULL;

    for (size_t i = 0; i < len; ++i) {
        if (bits[i] == '1') {
            bytes[i / 8] |= 1U << (7 - (i % 8));
        }
    }

    *out_count = count;
    return bytes;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0033" name="idiom: Binary search in sorted array" kind="idiom">
      <signature>bool binary_search(const int* array, size_t count, int value) {</signature>
      <summary><![CDATA[<p>Search a sorted integer array using binary search.</p>]]></summary>
      <notes>
        <note id="note.id-0033.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/12/check-if-list-contains-a-value">https://programming-idioms.org/idiom/12/check-if-list-contains-a-value</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0033.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool binary_search(const int* array, size_t count, int value) {
    size_t left = 0;
    size_t right = count;

    while (left < right) {
        size_t mid = left + (right - left) / 2;
        if (array[mid] == value) {
            return true;
        }
        if (array[mid] < value) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0034" name="idiom: Binomial coefficient &quot;n choose k&quot;" kind="idiom">
      <signature>unsigned long long binomial(unsigned int n, unsigned int k) {</signature>
      <summary><![CDATA[<p>Compute the binomial coefficient using an iterative integer method. Warning: <code>unsigned long long</code> can overflow quickly for large n and k. For n &gt; 62, consider using checked arithmetic or multiprecision libraries.</p>]]></summary>
      <notes>
        <note id="note.id-0034.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/67/binomial-coefficient-n-choose-k">https://programming-idioms.org/idiom/67/binomial-coefficient-n-choose-k</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0034.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned long long binomial(unsigned int n, unsigned int k) {
    if (k > n) {
        return 0;
    }
    if (k > n - k) {
        k = n - k;
    }

    unsigned long long result = 1;
    for (unsigned int i = 1; i <= k; ++i) {
        result = result * (n - k + i) / i;  /* fixed spacing */
    }
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0035" name="idiom: Bitset membership with unsigned shifts (avoid UB on signed)" kind="idiom">
      <signature>unsigned mask = 1u &lt;&lt; bit;</signature>
      <summary><![CDATA[<p>Use unsigned types for bit operations; left shift on signed can be undefined. Ensure <code>bit &lt; (sizeof(unsigned) * CHAR_BIT)</code> to avoid undefined behavior.</p>]]></summary>
      <examples>
        <example id="ex.id-0035.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <limits.h>
#include <assert.h>

void check_bit(unsigned flags, unsigned bit) {
    assert(bit < sizeof(unsigned) * CHAR_BIT);  /* ensure bit in range */

    unsigned mask = 1u << bit;
    if (flags & mask) {
        /* bit is set */
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0036" name="idiom: Boolean normalization with `!!`" kind="idiom">
      <signature>int ok = !!ptr;</signature>
      <summary><![CDATA[<p>Forces a clean 0/1 value, useful when you need strict boolean-like integers. For C99 <code>bool</code> type semantics, consider using <code>&lt;stdbool.h&gt;</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0036.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

void* ptr = get_pointer();
int ok = !!ptr;  /* converts any non-zero to 1, zero to 0 */

/* Or with stdbool.h for proper bool type */
#include <stdbool.h>
bool valid = (ptr != NULL);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0037" name="idiom: Branchless &quot;is power of two&quot; (and exclude 0)" kind="idiom">
      <signature>int is_pow2(size_t x) { return x &amp;&amp; ((x &amp; (x - 1)) == 0); }</signature>
      <summary><![CDATA[<p>Tiny and used often in allocators and alignment code.</p>]]></summary>
      <examples>
        <example id="ex.id-0037.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

int is_pow2(size_t x) { return x && ((x & (x - 1)) == 0); }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0038" name="idiom: Break outer loop" kind="idiom">
      <signature>bool find_negative(</signature>
      <summary><![CDATA[<p>Search a 2D integer matrix and stop immediately when a negative value is found. Returns false if out_value is NULL (required parameter).</p>]]></summary>
      <notes>
        <note id="note.id-0038.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/43/break-outer-loop">https://programming-idioms.org/idiom/43/break-outer-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0038.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool find_negative(
    const int* matrix,
    size_t rows,
    size_t cols,
    int* out_value
) {
    if (!out_value) return false;  /* require non-NULL output */

    for (size_t r = 0; r < rows; ++r) {
        for (size_t c = 0; c < cols; ++c) {
            int value = matrix[r * cols + c];
            if (value < 0) {
                *out_value = value;
                return true;
            }
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0039" name="idiom: Byte extraction with masks and shifts (portable endianness-agnostic logic)" kind="idiom">
      <signature>unsigned byte0 = (x &gt;&gt; 0) &amp; 0xFFu;</signature>
      <summary><![CDATA[<p>This avoids aliasing and alignment pitfalls of pointer casts. Extract bytes from multi-byte integers portably.</p>]]></summary>
      <examples>
        <example id="ex.id-0039.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdint.h>

void extract_bytes(uint32_t x) {
    unsigned byte0 = (x >> 0) & 0xFFu;   /* LSB */
    unsigned byte1 = (x >> 8) & 0xFFu;
    unsigned byte2 = (x >> 16) & 0xFFu;
    unsigned byte3 = (x >> 24) & 0xFFu;  /* MSB */

    /* use bytes */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0040" name="idiom: Bytes to hex string" kind="idiom">
      <signature>char* bytes_to_hex(const unsigned char* bytes, size_t count) {</signature>
      <summary><![CDATA[<p>Convert a byte array into a hexadecimal string representation. Using <code>snprintf</code> instead of <code>sprintf</code> or a hex lookup table provides better safety and performance.</p>]]></summary>
      <notes>
        <note id="note.id-0040.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/175/bytes-to-hex-string">https://programming-idioms.org/idiom/175/bytes-to-hex-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0040.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

char* bytes_to_hex(const unsigned char* bytes, size_t count) {
    char* hex = (char*)malloc(count * 2 + 1);
    if (!hex) return NULL;

    for (size_t i = 0; i < count; ++i) {
        snprintf(hex + i * 2, 3, "%02x", bytes[i]);  /* safer than sprintf */
    }
    hex[count * 2] = '\0';  /* explicit null terminator */
    return hex;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0041" name="idiom: Calculate exponentiation of real numbers" kind="idiom">
      <signature>void print_powers(double a, double b, int n) {</signature>
      <summary><![CDATA[<p>Compute real-number exponentiation using the math library.</p>]]></summary>
      <notes>
        <note id="note.id-0041.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/305/calculate-exponentiation-of-real-numbers">https://programming-idioms.org/idiom/305/calculate-exponentiation-of-real-numbers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0041.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stdio.h>

void print_powers(double a, double b, int n) {
    printf("%f %f\n", pow(a, b), pow(a, n));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0042" name="idiom: Call an external C function" kind="idiom">
      <signature>void foo(double* values, int count);</signature>
      <summary><![CDATA[<p>Declare and call an external C function using a statically allocated array.</p>]]></summary>
      <notes>
        <note id="note.id-0042.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/190/call-an-external-c-function">https://programming-idioms.org/idiom/190/call-an-external-c-function</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0042.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void foo(double* values, int count);

void call_external(void) {
    double data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    foo(data, (int)(sizeof(data) / sizeof(data[0])));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0043" name="idiom: Character stack with flexible array member" kind="idiom">
      <signature>typedef struct stack_char_fla {</signature>
      <summary><![CDATA[<p>Fixed-capacity character stack using flexible array member.<br>Provides a simple LIFO container for character data with allocation at creation time.</p><p>Creates a character stack with specified capacity.<br>Returns NULL on allocation failure or if capacity is 0.</p><p>Destroys a character stack and frees its memory.<br>Safe to call with NULL pointer.</p><p>Returns the current number of characters in the stack.<br>Returns 0 if stack is NULL.</p><p>Pushes a character onto the stack.<br>Returns true on success, false if stack is NULL or at capacity.</p><p>Pops a character from the stack and stores it in *out.<br>Returns true on success, false if stack is NULL, empty, or out is NULL.</p>]]></summary>
      <examples>
        <example id="ex.id-0043.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct stack_char_fla {
    size_t capacity;
    size_t count;
    char items[];
} stack_char_fla;

stack_char_fla* stack_char_fla_create(size_t capacity) {
    if (capacity == 0) return NULL;
    stack_char_fla* s = (stack_char_fla*)malloc(sizeof(*s) + capacity * sizeof(s->items[0]));
    if (!s) return NULL;
    s->capacity = capacity;
    s->count = 0;
    return s;
}

void stack_char_fla_destroy(stack_char_fla* stack) {
    free(stack);
}

size_t stack_char_fla_count(const stack_char_fla* stack) {
    return stack ? stack->count : 0;
}

bool stack_char_fla_push(stack_char_fla* stack, char c) {
    if (!stack) return false;
    if (stack->count >= stack->capacity) return false;
    stack->items[stack->count++] = c;
    return true;
}

bool stack_char_fla_pop(stack_char_fla* stack, char* out) {
    if (!stack || !out) return false;
    if (stack->count == 0) return false;
    *out = stack->items[--stack->count];
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0044" name="idiom: Check for overflow before multiply/add (portable pattern)" kind="idiom">
      <signature>if (b != 0 &amp;&amp; a &gt; SIZE_MAX / b) return -1; /* a*b would overflow */</signature>
      <summary><![CDATA[<p>This is the reliable, standard way (no compiler builtins) for <code>size_t</code>-sized arithmetic. Not for general signed overflow detection.</p>]]></summary>
      <examples>
        <example id="ex.id-0044.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdint.h>

if (b != 0 && a > SIZE_MAX / b) return -1;   /* a * b would overflow size_t */

if (a > SIZE_MAX - b) return -1;            /* a + b would overflow size_t */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0045" name="idiom: Check if any value in a list is larger than a limit" kind="idiom">
      <signature>bool any_greater_than(const int* array, size_t count, int limit) {</signature>
      <summary><![CDATA[<p>Scan an array and execute a callback if any element exceeds a given threshold.</p>]]></summary>
      <notes>
        <note id="note.id-0045.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/191/check-if-any-value-in-a-list-is-larger-than-a-limit">https://programming-idioms.org/idiom/191/check-if-any-value-in-a-list-is-larger-than-a-limit</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0045.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool any_greater_than(const int* array, size_t count, int limit) {
    for (size_t i = 0; i < count; ++i) {
        if (array[i] > limit) {
            return true;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0046" name="idiom: Check if file exists" kind="idiom">
      <signature>bool file_exists(const char* path) {</signature>
      <summary><![CDATA[<p>Check whether a file exists by attempting to open it.</p>]]></summary>
      <notes>
        <note id="note.id-0046.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/144/check-if-file-exists">https://programming-idioms.org/idiom/144/check-if-file-exists</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0046.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdbool.h>

bool file_exists(const char* path) {
    FILE* file = fopen(path, "r");
    if (!file) {
        return false;
    }
    fclose(file);
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0047" name="idiom: Check if integer addition will overflow" kind="idiom">
      <signature>bool addition_overflows(int a, int b) {</signature>
      <summary><![CDATA[<p>Detect whether adding two signed integers would overflow.</p>]]></summary>
      <notes>
        <note id="note.id-0047.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/85/check-if-integer-addition-will-overflow">https://programming-idioms.org/idiom/85/check-if-integer-addition-will-overflow</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0047.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <limits.h>

bool addition_overflows(int a, int b) {
    if (a > 0 && b > INT_MAX - a) {
        return true;
    }
    if (a < 0 && b < INT_MIN - a) {
        return true;
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0048" name="idiom: Check if integer is even" kind="idiom">
      <signature>unsigned char integers_is_even(int num);</signature>
      <summary><![CDATA[<p>Returns 1 if num is even, otherwise 0.<br>Handles negative and positive values consistently. Note: Bitwise <code>(num &amp; 1)</code> is well-defined for two's complement but for maximum portability prefer <code>num % 2 == 0</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0048.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

unsigned char integers_is_even(int num) {
    return (unsigned char)((num & 1) == 0);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0049" name="idiom: Check if list contains a value" kind="idiom">
      <signature>bool contains_int(const int* array, size_t count, int value) {</signature>
      <summary><![CDATA[<p>Perform a linear search to determine whether an integer value exists in an array.</p>]]></summary>
      <notes>
        <note id="note.id-0049.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/12/check-if-list-contains-a-value">https://programming-idioms.org/idiom/12/check-if-list-contains-a-value</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0049.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <stddef.h>

bool contains_int(const int* array, size_t count, int value) {
    for (size_t i = 0; i < count; ++i) {
        if (array[i] == value) {
            return true;
        }
    }
    return false;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0050" name="idiom: Check if point is inside rectangle" kind="idiom">
      <signature>bool point_in_rect(</signature>
      <summary><![CDATA[<p>Determine whether a point lies inside or on the boundary of an axis-aligned rectangle. Assumes <code>x1 &lt;= x2</code> and <code>y1 &lt;= y2</code>; if coordinates may be unordered, normalize them first.</p>]]></summary>
      <notes>
        <note id="note.id-0050.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle">https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0050.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

bool point_in_rect(
    double x1,
    double y1,
    double x2,
    double y2,
    double px,
    double py
) {
    return px >= x1 && px <= x2 && py >= y1 && py <= y2;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0051" name="idiom: Check if string contains a word" kind="idiom">
      <signature>bool contains_substring(const char* s, const char* word) {</signature>
      <summary><![CDATA[<p>Check whether a string contains another string as a substring. Note: This finds substrings, not whole words with boundaries. For true word matching, add boundary checks using <code>isalnum</code> or similar.</p>]]></summary>
      <notes>
        <note id="note.id-0051.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/39/check-if-string-contains-a-word">https://programming-idioms.org/idiom/39/check-if-string-contains-a-word</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0051.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool contains_substring(const char* s, const char* word) {
    return strstr(s, word) != NULL;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0052" name="idiom: Check if string contains only digits" kind="idiom">
      <signature>bool is_numeric(const char* s) {</signature>
      <summary><![CDATA[<p>Determine whether a string consists exclusively of decimal digit characters.</p>]]></summary>
      <notes>
        <note id="note.id-0052.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/137/check-if-string-contains-only-digits">https://programming-idioms.org/idiom/137/check-if-string-contains-only-digits</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0052.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <ctype.h>

bool is_numeric(const char* s) {
    if (!*s) {
        return false;
    }

    while (*s) {
        if (!isdigit((unsigned char) * s)) {
            return false;
        }
        ++s;
    }
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0053" name="idiom: Check if string is blank" kind="idiom">
      <signature>bool is_blank(const char* s) {</signature>
      <summary><![CDATA[<p>Check whether a string is empty or contains only whitespace characters.</p>]]></summary>
      <notes>
        <note id="note.id-0053.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/110/check-if-string-is-blank">https://programming-idioms.org/idiom/110/check-if-string-is-blank</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0053.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <ctype.h>

bool is_blank(const char* s) {
    while (*s) {
        if (!isspace((unsigned char) * s)) {
            return false;
        }
        ++s;
    }
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0054" name="idiom: Check palindrome in byte array" kind="idiom">
      <signature>unsigned char array_u8_is_palindrome(const unsigned char* a,</signature>
      <summary><![CDATA[<p>Returns 1 if a[0..n) forms a palindrome when read from index 0 to n-1.<br>Behavior:<br>- Returns 1 for n == 0 or n == 1 (empty and single-element sequences are palindromes).<br>- Returns 0 if a is NULL and n &gt; 0.<br>Intended for digit arrays or general byte sequences.</p>]]></summary>
      <examples>
        <example id="ex.id-0054.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

unsigned char array_u8_is_palindrome(const unsigned char* a, size_t n) {
    if (!a && n) return 0;
    if (n <= 1) return 1;

    size_t i = 0;
    size_t j = n - 1;
    while (i < j) {
        if (a[i] != a[j]) return 0;
        ++i;
        --j;
    }
    return 1;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0055" name="idiom: Check string prefix" kind="idiom">
      <signature>bool starts_with(const char* s, const char* prefix) {</signature>
      <summary><![CDATA[<p>Check whether a string begins with a specified prefix.</p>]]></summary>
      <notes>
        <note id="note.id-0055.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/96/check-string-prefix">https://programming-idioms.org/idiom/96/check-string-prefix</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0055.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool starts_with(const char* s, const char* prefix) {
    size_t len = strlen(prefix);
    return strncmp(s, prefix, len) == 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0056" name="idiom: Clamp a value to a range" kind="idiom">
      <signature>int clamp_int(int value, int min, int max) {</signature>
      <summary><![CDATA[<p>Restrict an integer value to a minimum and maximum bound.</p>]]></summary>
      <notes>
        <note id="note.id-0056.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle">https://programming-idioms.org/idiom/178/check-if-point-is-inside-rectangle</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0056.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int clamp_int(int value, int min, int max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0057" name="idiom: Comment out a single line" kind="idiom">
      <signature>Comment out a single line</signature>
      <summary><![CDATA[<p>Add a comment line that is ignored by the compiler.</p>]]></summary>
      <notes>
        <note id="note.id-0057.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/299/comment-out-a-single-line">https://programming-idioms.org/idiom/299/comment-out-a-single-line</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0057.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
// This is a comment.
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0058" name="idiom: Compile-time array length (ARRAY_LEN/ARRAY_SIZE)" kind="idiom">
      <signature>Compile-time array length (ARRAY_LEN/ARRAY_SIZE)</signature>
      <summary><![CDATA[<p>Determine the number of elements in a statically allocated array.</p><p>Use it only when you truly have an array, not a pointer.</p>]]></summary>
      <notes>
        <note id="note.id-0058.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/117/get-list-size">https://programming-idioms.org/idiom/117/get-list-size</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0058.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
]]></code>
        </example>
        <example id="ex.id-0058.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#define ARRAY_LEN(a) (sizeof(a) / sizeof((a)[0]))
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0059" name="idiom: Compile-time assertion (typedef trick)" kind="idiom">
      <signature>STATIC_ASSERT(sizeof(int) &gt;= 4, int_must_be_32_bits);</signature>
      <summary><![CDATA[<p>Enforce invariants at compile time using C99 constructs.</p><p>C11 has <code>_Static_assert</code>, but this works in C99 and fails at compile time.</p>]]></summary>
      <notes>
        <note id="note.id-0059.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type">https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0059.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#define STATIC_ASSERT(cond, msg) typedef char static_assert_##msg[(cond) ? 1 : -1]

STATIC_ASSERT(sizeof(int) >= 4, int_must_be_32_bits);
]]></code>
        </example>
        <example id="ex.id-0059.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#define STATIC_ASSERT(expr) typedef char static_assertion[(expr) ? 1 : -1]
STATIC_ASSERT(sizeof(int) == 4);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0060" name="idiom: Complex number" kind="idiom">
      <signature>double complex compute_complex(void) {</signature>
      <summary><![CDATA[<p>Declare and manipulate a complex number using the C99 complex number support.</p>]]></summary>
      <notes>
        <note id="note.id-0060.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/77/complex-number">https://programming-idioms.org/idiom/77/complex-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0060.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <complex.h>

double complex compute_complex(void) {
    double complex z = -2.0 + 3.0 * I;
    return z * I;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0061" name="idiom: Compound literals for &quot;temporary objects with an address&quot;" kind="idiom">
      <signature>use_point(&amp;(struct Point){ .x = 1, .y = 2 });</signature>
      <summary><![CDATA[<p>Compound literals are standard C99. They are extremely handy for passing small structs/buffers without naming a variable.</p>]]></summary>
      <examples>
        <example id="ex.id-0061.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
use_point(&(struct Point){ .x = 1, .y = 2 });

memcpy(dst, (unsigned char[]){0xDE,0xAD,0xBE,0xEF}, 4);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0062" name="idiom: Compute GCD" kind="idiom">
      <signature>unsigned int gcd(unsigned int a, unsigned int b) {</signature>
      <summary><![CDATA[<p>Compute the greatest common divisor of two non-negative integers using the Euclidean algorithm.</p>]]></summary>
      <notes>
        <note id="note.id-0062.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/74/compute-gcd">https://programming-idioms.org/idiom/74/compute-gcd</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0062.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int gcd(unsigned int a, unsigned int b) {
    while (b != 0) {
        unsigned int r = a % b;
        a = b;
        b = r;
    }
    return a;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0063" name="idiom: Compute LCM" kind="idiom">
      <signature>unsigned int lcm(unsigned int a, unsigned int b) {</signature>
      <summary><![CDATA[<p>Compute the least common multiple of two non-negative integers using GCD.</p>]]></summary>
      <notes>
        <note id="note.id-0063.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/75/compute-lcm">https://programming-idioms.org/idiom/75/compute-lcm</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0063.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
/* GCD using Euclidean algorithm */
unsigned int gcd(unsigned int a, unsigned int b) {
    while (b != 0) {
        unsigned int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

unsigned int lcm(unsigned int a, unsigned int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    return (a / gcd(a, b)) * b;  /* avoid overflow by dividing first */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0064" name="idiom: Compute sum of integers" kind="idiom">
      <signature>int sum_ints(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Compute the sum of all elements in an integer array.</p>]]></summary>
      <notes>
        <note id="note.id-0064.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/54/compute-sum-of-integers">https://programming-idioms.org/idiom/54/compute-sum-of-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0064.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

int sum_ints(const int* array, size_t count) {
    int sum = 0;
    for (size_t i = 0; i < count; ++i) {
        sum += array[i];
    }
    return sum;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0065" name="idiom: Conditional assignment" kind="idiom">
      <signature>const char* choose_value(int condition) {</signature>
      <summary><![CDATA[<p>Assign one of two string values depending on a boolean condition.</p>]]></summary>
      <notes>
        <note id="note.id-0065.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/252/conditional-assignment">https://programming-idioms.org/idiom/252/conditional-assignment</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0065.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* choose_value(int condition) {
    return condition ? "a" : "b";
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0066" name="idiom: Container-of pattern (common, but not standard-library provided)" kind="idiom">
      <signature>Container-of pattern (common, but not standard-library provided)</signature>
      <summary><![CDATA[<p>Useful for intrusive data structures. It relies on well-known idioms, but it is also sharp: use only when you fully control types and lifetimes.</p>]]></summary>
      <examples>
        <example id="ex.id-0066.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define OFFSETOF(type, member) ((size_t)&(((type *)0)->member))
#define CONTAINER_OF(ptr, type, member) ((type *)((char*)(ptr) - OFFSETOF(type, member)))
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0067" name="idiom: Continue outer loop" kind="idiom">
      <signature>void print_unique(const int* a, size_t a_count, const int* b, size_t b_count) {</signature>
      <summary><![CDATA[<p>Iterate over one array and skip elements that appear in another array using a controlled loop structure.</p>]]></summary>
      <notes>
        <note id="note.id-0067.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/42/continue-outer-loop">https://programming-idioms.org/idiom/42/continue-outer-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0067.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdio.h>
#include <stdbool.h>

void print_unique(const int* a, size_t a_count, const int* b, size_t b_count) {
    for (size_t i = 0; i < a_count; ++i) {
        bool found = false;
        for (size_t j = 0; j < b_count; ++j) {
            if (a[i] == b[j]) {
                found = true;
                break;
            }
        }
        if (!found) {
            printf("%d\n", a[i]);
        }
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0068" name="idiom: Convert integer to floating point number" kind="idiom">
      <signature>double to_double(int value) {</signature>
      <summary><![CDATA[<p>Convert an integer value to a floating point value explicitly.</p>]]></summary>
      <notes>
        <note id="note.id-0068.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/79/convert-integer-to-floating-point-number">https://programming-idioms.org/idiom/79/convert-integer-to-floating-point-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0068.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
double to_double(int value) {
    return (double)value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0069" name="idiom: Convert integer to string" kind="idiom">
      <signature>void int_to_string(int value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert an integer value to its decimal string representation.</p>]]></summary>
      <notes>
        <note id="note.id-0069.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/55/convert-integer-to-string">https://programming-idioms.org/idiom/55/convert-integer-to-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0069.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void int_to_string(int value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%d", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0070" name="idiom: Convert real number to string with 2 decimal places" kind="idiom">
      <signature>void format_two_decimals(double value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Format a floating point value into a string with exactly two digits after the decimal point.</p>]]></summary>
      <notes>
        <note id="note.id-0070.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places">https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0070.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void format_two_decimals(double value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%.2f", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0071" name="idiom: Convert string to camelCase" kind="idiom">
      <signature>size_t string_to_camel_case(</signature>
      <summary><![CDATA[<p>Converts source string to camelCase by capitalizing letters after spaces and lowercasing others. Returns the number of characters written (excluding null terminator). The <code>buffer_capacity</code> parameter is the total buffer size including space for the null terminator.</p>]]></summary>
      <notes>
        <note id="note.id-0071.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/49/split-a-space-separated-string">https://programming-idioms.org/idiom/49/split-a-space-separated-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0071.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <ctype.h>

size_t string_to_camel_case(const char* source, char* buffer, size_t buffer_capacity) {
    if (!source || !buffer || buffer_capacity == 0) return 0;

    size_t w = 0;
    int cap_next = 0;

    for (const unsigned char* p = (const unsigned char*)source; *p; ++p) {
        if (isspace(*p)) {
            cap_next = 1;
            continue;
        }
        if (!isalpha(*p)) {
            continue;
        }

        if (w >= buffer_capacity - 1) break;  /* leave space for null */

        unsigned char ch = *p;
        if (w == 0) {
            ch = (unsigned char)tolower(ch);
        } else if (cap_next) {
            ch = (unsigned char)toupper(ch);
        } else {
            ch = (unsigned char)tolower(ch);
        }
        cap_next = 0;

        buffer[w++] = (char)ch;
    }

    buffer[w] = '\0';  /* null terminate at correct position */
    return w;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0072" name="idiom: Convert string to integer" kind="idiom">
      <signature>int string_to_int_checked(const char* s, int* out_value) {</signature>
      <summary><![CDATA[<p>Parse a decimal integer from a string with proper error handling. Check end pointer for complete consumption, validate errno for range errors, and check int bounds. Returns 0 on success, -1 on error.</p>]]></summary>
      <notes>
        <note id="note.id-0072.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/22/convert-string-to-integer">https://programming-idioms.org/idiom/22/convert-string-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0072.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>

int string_to_int_checked(const char* s, int* out_value) {
    if (!s || !out_value) return -1;

    /* Skip leading whitespace */
    while (isspace((unsigned char)*s)) s++;
    if (*s == '\0') return -1;  /* empty or whitespace-only */

    char* end;
    errno = 0;
    long val = strtol(s, &end, 10);

    /* Check for parsing errors */
    if (end == s) return -1;  /* no digits */
    if (errno == ERANGE) return -1;  /* overflow/underflow */
    if (val < INT_MIN || val > INT_MAX) return -1;  /* out of int range */

    /* Check for trailing garbage (optional: skip trailing whitespace) */
    while (isspace((unsigned char)*end)) end++;
    if (*end != '\0') return -1;  /* trailing non-whitespace */

    *out_value = (int)val;
    return 0;  /* success */
}

/* Simple wrapper for backwards compatibility */
int string_to_int(const char* s) {
    int result;
    return (string_to_int_checked(s, &result) == 0) ? result : 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0073" name="idiom: Convert string to integer, explicit base" kind="idiom">
      <signature>int string_to_int_base_checked(const char* s, int base, int* out_value) {</signature>
      <summary><![CDATA[<p>Parse an integer from a string in the specified base (2-36, or 0 for auto-detect). Validate base, check end pointer, and handle range errors. Returns 0 on success, -1 on error.</p>]]></summary>
      <notes>
        <note id="note.id-0073.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/337/convert-string-to-integer-explicit-base">https://programming-idioms.org/idiom/337/convert-string-to-integer-explicit-base</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0073.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>

int string_to_int_base_checked(const char* s, int base, int* out_value) {
    if (!s || !out_value) return -1;
    if ((base < 0 || base == 1 || base > 36) && base != 0) return -1;  /* invalid base */

    /* Skip leading whitespace */
    while (isspace((unsigned char)*s)) s++;
    if (*s == '\0') return -1;

    char* end;
    errno = 0;
    long val = strtol(s, &end, base);

    if (end == s) return -1;  /* no digits */
    if (errno == ERANGE) return -1;  /* overflow/underflow */
    if (val < INT_MIN || val > INT_MAX) return -1;  /* out of int range */

    /* Skip trailing whitespace */
    while (isspace((unsigned char)*end)) end++;
    if (*end != '\0') return -1;  /* trailing garbage */

    *out_value = (int)val;
    return 0;
}

/* Simple wrapper for backwards compatibility */
int string_to_int_base(const char* s, int base) {
    int result;
    return (string_to_int_base_checked(s, base, &result) == 0) ? result : 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0074" name="idiom: Copy string into buffer with capacity and null-terminate" kind="idiom">
      <signature>int helloworld_into(char* out, size_t out_cap);</signature>
      <summary><![CDATA[<p>Copies "Hello, World!" into out and null-terminates.<br>Returns bytes written excluding the terminator, or 0 if out is NULL or out_cap is 0.</p>]]></summary>
      <examples>
        <example id="ex.id-0074.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <string.h>

int helloworld_into(char* out, size_t out_cap) {
    static const char kMsg[] = "Hello, World!";
    if (!out || out_cap == 0) return 0;

    size_t n = sizeof(kMsg) - 1;
    if (n >= out_cap) n = out_cap - 1;

    memcpy(out, kMsg, n);
    out[n] = '\0';
    return (int)n;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0075" name="idiom: Count backwards" kind="idiom">
      <signature>void count_down(void) {</signature>
      <summary><![CDATA[<p>Print integers in descending order from a fixed starting value to zero.</p>]]></summary>
      <notes>
        <note id="note.id-0075.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/256/count-backwards">https://programming-idioms.org/idiom/256/count-backwards</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0075.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void count_down(void) {
    for (int i = 5; i >= 0; --i) {
        printf("%d\n", i);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0076" name="idiom: Count decimal digits in integer" kind="idiom">
      <signature>size_t integers_count_digits(int x);</signature>
      <summary><![CDATA[<p>Counts the number of decimal digits in x.<br>Example: 0 -&gt; 1, 90991 -&gt; 5; ignores the sign for negative inputs.</p>]]></summary>
      <examples>
        <example id="ex.id-0076.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

size_t integers_count_digits(int x) {
    long long v = (long long)x;
    if (v < 0) v = -v;
    if (v == 0) return 1;

    size_t n = 0;
    while (v) {
        v /= 10;
        ++n;
    }
    return n;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0077" name="idiom: Count set bits (popcount)" kind="idiom">
      <signature>unsigned int popcount(uint32_t value) {</signature>
      <summary><![CDATA[<p>Count the number of 1-bits in an unsigned 32-bit integer using bit manipulation. This implementation works for all <code>uint32_t</code> values.</p>]]></summary>
      <notes>
        <note id="note.id-0077.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation">https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0077.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdint.h>

unsigned int popcount(uint32_t value) {
    unsigned int count = 0;
    while (value) {
        value &= value - 1;  /* clear lowest set bit */
        ++count;
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0078" name="idiom: Count substring occurrences" kind="idiom">
      <signature>size_t count_substrings(const char* s, const char* sub) {</signature>
      <summary><![CDATA[<p>Count the number of non-overlapping occurrences of a substring within a string. Returns 0 if <code>sub</code> is empty to prevent infinite loop (strstr("", "") returns "").</p>]]></summary>
      <notes>
        <note id="note.id-0078.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/82/count-substring-occurrences">https://programming-idioms.org/idiom/82/count-substring-occurrences</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0078.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

size_t count_substrings(const char* s, const char* sub) {
    if (!s || !sub || *sub == '\0') return 0;  /* guard empty substring */

    size_t count = 0;
    size_t len = strlen(sub);

    while ((s = strstr(s, sub)) != NULL) {
        ++count;
        s += len;  /* advance past this occurrence */
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0079" name="idiom: Count trailing zero bits" kind="idiom">
      <signature>size_t count_trailing_zeros(unsigned int value) {</signature>
      <summary><![CDATA[<p>Count the number of consecutive zero bits starting from the least significant bit.</p>]]></summary>
      <notes>
        <note id="note.id-0079.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/262/count-trailing-zero-bits">https://programming-idioms.org/idiom/262/count-trailing-zero-bits</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0079.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

size_t count_trailing_zeros(unsigned int value) {
    if (value == 0) {
        return sizeof(value) * 8;
    }

    size_t count = 0;
    while ((value & 1U) == 0) {
        value >>= 1;
        ++count;
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0080" name="idiom: Counted push with post-increment (your pattern) plus the &quot;guard&quot; form" kind="idiom">
      <signature>if (array_count &lt; ARRAY_CAP) {</signature>
      <summary><![CDATA[<p>The idiom is best when paired with an explicit bounds guard close by.</p>]]></summary>
      <examples>
        <example id="ex.id-0080.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (array_count < ARRAY_CAP) {
    array[array_count++] = value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0081" name="idiom: Create a 2-dimensional array" kind="idiom">
      <signature>void example_matrix(size_t rows, size_t cols) {</signature>
      <summary><![CDATA[<p>Declare a two-dimensional array of double values using C99 variable length arrays.</p>]]></summary>
      <notes>
        <note id="note.id-0081.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/26/create-a-2-dimensional-array">https://programming-idioms.org/idiom/26/create-a-2-dimensional-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0081.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void example_matrix(size_t rows, size_t cols) {
    double matrix[rows][cols];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0082" name="idiom: Create a 2D Point data structure" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Declare a lightweight structure representing a two-dimensional point using double-precision coordinates.</p>]]></summary>
      <notes>
        <note id="note.id-0082.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/5/create-a-2d-point-data-structure">https://programming-idioms.org/idiom/5/create-a-2d-point-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0082.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct {
    double x;
    double y;
} Point2D;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0083" name="idiom: Create a 3-dimensional array" kind="idiom">
      <signature>void example_tensor(size_t x, size_t y, size_t z) {</signature>
      <summary><![CDATA[<p>Declare a three-dimensional array of double values using C99 variable length arrays.</p>]]></summary>
      <notes>
        <note id="note.id-0083.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/27/create-a-3-dimensional-array">https://programming-idioms.org/idiom/27/create-a-3-dimensional-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0083.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void example_tensor(size_t x, size_t y, size_t z) {
    double tensor[x][y][z];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0084" name="idiom: Create a Binary Tree data structure" kind="idiom">
      <signature>typedef struct TreeNode {</signature>
      <summary><![CDATA[<p>Define a recursive structure for a binary tree node with left and right children.</p>]]></summary>
      <notes>
        <note id="note.id-0084.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/9/create-a-binary-tree-data-structure">https://programming-idioms.org/idiom/9/create-a-binary-tree-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0084.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct TreeNode {
    int value;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0085" name="idiom: Create a function" kind="idiom">
      <signature>int square_int(int value) {</signature>
      <summary><![CDATA[<p>Define a function that computes and returns the square of an integer value.</p>]]></summary>
      <notes>
        <note id="note.id-0085.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/4/create-a-function">https://programming-idioms.org/idiom/4/create-a-function</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0085.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int square_int(int value) {
    return value * value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0086" name="idiom: Create a map (associative array)" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Represent an associative mapping using an array of key-value structures, which is portable and explicit in C.</p>]]></summary>
      <notes>
        <note id="note.id-0086.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/8/create-a-map-associative-array">https://programming-idioms.org/idiom/8/create-a-map-associative-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0086.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct {
    const char* key;
    const char* value;
} KeyValue;

KeyValue map[] = {
    { "foo", "twenty" },
    { "bar", "three" }
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0087" name="idiom: Create a procedure" kind="idiom">
      <signature>void finish(void) {</signature>
      <summary><![CDATA[<p>Define a function that returns no value and performs side effects only.</p>]]></summary>
      <notes>
        <note id="note.id-0087.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/3/create-a-procedure">https://programming-idioms.org/idiom/3/create-a-procedure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0087.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void finish(void) {
    printf("My job here is done.\n");
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0088" name="idiom: Create a Tree data structure" kind="idiom">
      <signature>typedef struct TreeNode {</signature>
      <summary><![CDATA[<p>Define a recursive tree node structure where each node may have zero or more children and access to its siblings.</p>]]></summary>
      <notes>
        <note id="note.id-0088.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/17/create-a-tree-data-structure">https://programming-idioms.org/idiom/17/create-a-tree-data-structure</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0088.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct TreeNode {
    int value;
    struct TreeNode* first_child;
    struct TreeNode* next_sibling;
} TreeNode;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0089" name="idiom: Create temp file" kind="idiom">
      <signature>FILE* create_temp_file(void) {</signature>
      <summary><![CDATA[<p>Create a temporary file using a secure, system-provided mechanism.</p>]]></summary>
      <notes>
        <note id="note.id-0089.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/138/create-temp-file">https://programming-idioms.org/idiom/138/create-temp-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0089.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

FILE* create_temp_file(void) {
    return tmpfile();
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0090" name="idiom: ctype functions: cast to unsigned char, and do not pass pointers" kind="idiom">
      <signature>if (isalpha((unsigned char)c)) { /* ... */ }</signature>
      <summary><![CDATA[<p><code>isalpha(0)</code> is defined to be false in the C locale, so <code>isalpha('\0')</code> is fine. Passing <code>NULL</code> is not "special"; it is just <code>0</code> as an integer constant, but treating it as a pointer concept is misleading. The real pitfall is <code>isalpha((signed char)0xE9)</code> which can be negative and is undefined unless you cast to <code>unsigned char</code> (or pass EOF).</p>]]></summary>
      <examples>
        <example id="ex.id-0090.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
if (isalpha((unsigned char)c)) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0091" name="idiom: Current executable name" kind="idiom">
      <signature>const char* executable_name(const char* argv0) {</signature>
      <summary><![CDATA[<p>Extract the executable name from the program invocation path.</p>]]></summary>
      <notes>
        <note id="note.id-0091.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/105/current-executable-name">https://programming-idioms.org/idiom/105/current-executable-name</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0091.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

const char* executable_name(const char* argv0) {
    const char* slash = strrchr(argv0, '/');
    return slash ? slash + 1 : argv0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0092" name="idiom: Custom allocation hooks via macros (malloc/free/realloc)" kind="idiom">
      <signature>Custom allocation hooks via macros (malloc/free/realloc)</signature>
      <summary><![CDATA[<p>Define allocator macros that can be redirected at compile time for custom memory management. The <code>ctx</code> parameter allows passing a custom allocator context but is ignored in the default implementation. To override, define the macros before including headers that use them.</p>]]></summary>
      <examples>
        <example id="ex.id-0092.1" lang="c99">
          <title>Default implementation</title>
          <code><![CDATA[
#include <stdlib.h>

#ifndef MY_MALLOC
#define MY_MALLOC(ctx, size) ((void)(ctx), malloc(size))
#endif

#ifndef MY_FREE
#define MY_FREE(ctx, ptr) ((void)(ctx), free(ptr))
#endif

#ifndef MY_REALLOC
#define MY_REALLOC(ctx, ptr, size) ((void)(ctx), realloc(ptr, size))
#endif

/* Example usage */
void* allocate_buffer(void* ctx, size_t size) {
    return MY_MALLOC(ctx, size);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0093" name="idiom: Date struct with year/month/day fields" kind="idiom">
      <signature>typedef struct reasonable_date {</signature>
      <summary><![CDATA[<p>Date helpers</p>]]></summary>
      <examples>
        <example id="ex.id-0093.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef struct reasonable_date {
    uint32_t year;
    uint32_t month;
    uint32_t day;
} reasonable_date;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0094" name="idiom: Days in month with leap-year adjustment" kind="idiom">
      <signature>uint32_t date_days_in_month(uint32_t year, uint32_t month);</signature>
      <summary><![CDATA[<p>Returns the number of days in the given month of year.<br>Returns 0 if month is out of range 1..12.</p>]]></summary>
      <examples>
        <example id="ex.id-0094.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stdint.h>

static int date_is_leap_year(uint32_t year) {
    return (year % 4u == 0u) && ((year % 100u != 0u) || (year % 400u == 0u));
}

uint32_t date_days_in_month(uint32_t year, uint32_t month) {
    static const uint8_t days[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
    if (month < 1u || month > 12u) return 0;

    uint32_t d = (uint32_t)days[month - 1u];
    if (month == 2u && date_is_leap_year(year)) d = 29;
    return d;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0095" name="idiom: Days since 1971-01-01 for date" kind="idiom">
      <signature>uint32_t date_days_since_1971(const reasonable_date* d);</signature>
      <summary><![CDATA[<p>Counts days since 1971-01-01 for date d.<br>Returns 0 if d is NULL; assumes d contains a valid date.</p>]]></summary>
      <examples>
        <example id="ex.id-0095.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stdint.h>

typedef struct reasonable_date {
    uint32_t year;
    uint32_t month;
    uint32_t day;
} reasonable_date;

static int date_is_leap_year(uint32_t year) {
    return (year % 4u == 0u) && ((year % 100u != 0u) || (year % 400u == 0u));
}

static uint32_t date_days_in_month(uint32_t year, uint32_t month) {
    static const uint8_t days[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
    uint32_t d = (uint32_t)days[month - 1u];
    if (month == 2u && date_is_leap_year(year)) d = 29;
    return d;
}

uint32_t date_days_since_1971(const reasonable_date* d) {
    if (!d) return 0;

    uint32_t days = 0;

    for (uint32_t y = 1971u; y < d->year; ++y) {
        days += (uint32_t)(date_is_leap_year(y) ? 366u : 365u);
    }

    for (uint32_t m = 1u; m < d->month; ++m) {
        days += date_days_in_month(d->year, m);
    }

    days += (d->day > 0u ? (d->day - 1u) : 0u);
    return days;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0096" name="idiom: Debug logging macro (compiled out in release)" kind="idiom">
      <signature>Debug logging macro (compiled out in release)</signature>
      <summary><![CDATA[<p>Emit debug-only log messages using conditional compilation. The <code>((void)0)</code> idiom keeps expression contexts well-typed when DEBUG is not defined.</p>]]></summary>
      <notes>
        <note id="note.id-0096.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/109/compile-time-assertions">https://programming-idioms.org/idiom/109/compile-time-assertions</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0096.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdio.h>

#ifdef DEBUG
#define DEBUG_LOG(fmt, ...) fprintf(stderr, fmt "\n", __VA_ARGS__)
#else
#define DEBUG_LOG(fmt, ...) ((void)0)
#endif
]]></code>
        </example>
        <example id="ex.id-0096.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#ifdef DEBUG
#define LOG(...) fprintf(stderr, __VA_ARGS__)
#else
#define LOG(...) ((void)0)
#endif
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0097" name="idiom: Declare an enumeration" kind="idiom">
      <signature>typedef enum {</signature>
      <summary><![CDATA[<p>Define an enumeration type with a fixed set of named integer constants.</p>]]></summary>
      <notes>
        <note id="note.id-0097.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/122/declare-an-enumeration">https://programming-idioms.org/idiom/122/declare-an-enumeration</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0097.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
typedef enum {
    SPADES,
    HEARTS,
    DIAMONDS,
    CLUBS
} Suit;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0098" name="idiom: Declare constant string" kind="idiom">
      <signature>const char* planet = &quot;Earth&quot;;</signature>
      <summary><![CDATA[<p>Declare a constant string literal.</p>]]></summary>
      <notes>
        <note id="note.id-0098.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/157/declare-constant-string">https://programming-idioms.org/idiom/157/declare-constant-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0098.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* planet = "Earth";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0099" name="idiom: Deduplicate sorted array in place" kind="idiom">
      <signature>size_t array_int_dedup_sorted(int* array, size_t size);</signature>
      <summary><![CDATA[<p>Removes consecutive duplicate elements from a sorted int array in place.<br>Input: array[0..size) must be sorted in ascending order.<br>Output: Unique elements are compacted at the beginning of array.<br>Returns: The new size (count of distinct elements).<br>Behavior:<br>- Returns 0 if array is NULL or size is 0.<br>- Returns 1 if size is 1.<br>- Does not modify elements beyond the returned size.<br>Example: [1,1,2,3,3,3,4] becomes [1,2,3,4] and returns 4.<br>Complexity: O(n) where n is size.</p>]]></summary>
      <examples>
        <example id="ex.id-0099.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

size_t array_int_dedup_sorted(int* array, size_t size) {
    if (!array || size == 0) return 0;
    if (size == 1) return 1;

    size_t w = 1;
    for (size_t r = 1; r < size; ++r) {
        if (array[r] != array[w - 1]) {
            array[w++] = array[r];
        }
    }
    return w;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0100" name="idiom: Delete file" kind="idiom">
      <signature>int delete_file(const char* path) {</signature>
      <summary><![CDATA[<p>Remove a file from the filesystem.</p>]]></summary>
      <notes>
        <note id="note.id-0100.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/155/delete-file">https://programming-idioms.org/idiom/155/delete-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0100.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int delete_file(const char* path) {
    return remove(path);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0101" name="idiom: Depth-first traversal in a graph" kind="idiom">
      <signature>typedef struct Node {</signature>
      <summary><![CDATA[<p>Perform a depth-first traversal over a graph represented by adjacency lists.</p>]]></summary>
      <notes>
        <note id="note.id-0101.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/130/depth-first-traversal-in-a-graph">https://programming-idioms.org/idiom/130/depth-first-traversal-in-a-graph</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0101.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

typedef struct Node {
    size_t index;
    struct Node** neighbors;
    size_t neighbor_count;
} Node;

void dfs(Node* node, int* visited) {
    if (visited[node->index]) {
        return;
    }

    visited[node->index] = 1;
    for (size_t i = 0; i < node->neighbor_count; ++i) {
        dfs(node->neighbors[i], visited);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0102" name="idiom: Designated initializers to document intent and avoid field-order coupling" kind="idiom">
      <signature>struct Config cfg = {</signature>
      <summary><![CDATA[<p>This makes changes to <code>struct Config</code> safer because you are not relying on declaration order.</p>]]></summary>
      <examples>
        <example id="ex.id-0102.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
struct Config cfg = {
    .timeout_ms = 250,
    .retries = 3,
    .path = "/tmp/app.sock",
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0103" name="idiom: Detect zero digit in base-10 representation" kind="idiom">
      <signature>unsigned char integers_has_zero_digit(int num);</signature>
      <summary><![CDATA[<p>Returns 1 if the base-10 representation of num contains at least one '0' digit, else 0.<br>Behavior:<br>- 0 returns 1 (its only digit is zero).<br>- Negative values are examined by their absolute value.<br>Examples: 101 -&gt; 1, 123 -&gt; 0, 909 -&gt; 1.<br>Complexity: O(d) where d is the number of decimal digits.</p>]]></summary>
      <examples>
        <example id="ex.id-0103.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

unsigned char integers_has_zero_digit(int num) {
    long long v = (long long)num;
    if (v < 0) v = -v;
    if (v == 0) return 1;

    while (v) {
        if ((v % 10) == 0) return 1;
        v /= 10;
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0104" name="idiom: Dynamic int array with capacity growth" kind="idiom">
      <signature>typedef struct leaf_values {</signature>
      <summary><![CDATA[<p>Lightweight dynamic array for ints. Returns status codes to enable error checking.</p>]]></summary>
      <examples>
        <example id="ex.id-0104.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct leaf_values {
    size_t size;
    size_t capacity;
    int* items;
} leaf_values;

/* Allocates a growable array of int with initial_capacity (1 if 0).
 * Returns NULL on allocation failure. */
leaf_values* leaf_values_create(size_t initial_capacity) {
    if (initial_capacity == 0) initial_capacity = 1;

    leaf_values* lv = (leaf_values*)malloc(sizeof(*lv));
    if (!lv) return NULL;

    lv->items = (int*)malloc(initial_capacity * sizeof(*lv->items));
    if (!lv->items) {
        free(lv);
        return NULL;
    }

    lv->size = 0;
    lv->capacity = initial_capacity;
    return lv;
}

/* Appends item to the end of the vector, growing capacity as needed.
 * Returns false on realloc failure (vector unchanged), true on success. */
bool leaf_values_push(leaf_values* lv, int item) {
    if (!lv) return false;

    if (lv->size == lv->capacity) {
        size_t new_cap = lv->capacity ? (lv->capacity * 2) : 1;
        int* tmp = (int*)realloc(lv->items, new_cap * sizeof(*lv->items));
        if (!tmp) return false;  /* signal failure to caller */
        lv->items = tmp;
        lv->capacity = new_cap;
    }

    lv->items[lv->size++] = item;
    return true;
}

/* Frees the vector and its storage. Safe to call with NULL. */
void leaf_values_destroy(leaf_values* lv) {
    if (!lv) return;
    free(lv->items);
    free(lv);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0105" name="idiom: Echo program implementation" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Print all command-line arguments except the program name, separated by spaces.</p>]]></summary>
      <notes>
        <note id="note.id-0105.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/71/echo-program-implementation">https://programming-idioms.org/idiom/71/echo-program-implementation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0105.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(int argc, char* argv[]) {
    for (int i = 1; i < argc; ++i) {
        printf("%s", argv[i]);
        if (i + 1 < argc) {
            printf(" ");
        }
    }
    printf("\n");
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0106" name="idiom: Execute procedures depending on options" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Execute different procedures based on parsed command-line options using getopt.</p>]]></summary>
      <notes>
        <note id="note.id-0106.1" severity="warning" topic="portability">
          <description><![CDATA[<p>getopt is POSIX, not C99 standard. For portable C99, parse argv manually.</p>]]></description>
        </note>
        <note id="note.id-0106.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/162/execute-procedures-depending-on-options">https://programming-idioms.org/idiom/162/execute-procedures-depending-on-options</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0106.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>

void bat(void);  /* forward declarations */
void fox(void);

int main(int argc, char* argv[]) {
    int opt;
    while ((opt = getopt(argc, argv, "bf")) != -1) {
        if (opt == 'b') {
            bat();
        } else if (opt == 'f') {
            fox();
        }
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0107" name="idiom: Exit program cleanly (EXIT_SUCCESS)" kind="idiom">
      <signature>void exit_success(void) {</signature>
      <summary><![CDATA[<p>Terminate the program and indicate successful completion to the operating system.</p><p>Terminate program execution immediately and report successful completion.</p>]]></summary>
      <notes>
        <note id="note.id-0107.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/186/exit-program-cleanly">https://programming-idioms.org/idiom/186/exit-program-cleanly</a></p>]]></description>
        </note>
        <note id="note.id-0107.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/87/stop-program">https://programming-idioms.org/idiom/87/stop-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0107.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

void exit_success(void) {
    exit(EXIT_SUCCESS);
}
]]></code>
        </example>
        <example id="ex.id-0107.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stdlib.h>

void stop_program(void) {
    exit(EXIT_SUCCESS);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0108" name="idiom: Extract a substring" kind="idiom">
      <signature>char* substring(const char* s, size_t start, size_t end) {</signature>
      <summary><![CDATA[<p>Extract a substring from a string using byte indices, allocating a new null-terminated string.</p>]]></summary>
      <notes>
        <note id="note.id-0108.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/38/extract-a-substring">https://programming-idioms.org/idiom/38/extract-a-substring</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0108.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* substring(const char* s, size_t start, size_t end) {
    if (end <= start) {
        return NULL;
    }

    size_t len = end - start;
    char* result = (char*)malloc(len + 1);
    if (!result) {
        return NULL;
    }

    memcpy(result, s + start, len);
    result[len] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0109" name="idiom: Extract file content to a string" kind="idiom">
      <signature>char* read_file_to_string(const char* path) {</signature>
      <summary><![CDATA[<p>Read the entire contents of a file into a dynamically allocated string using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0109.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/58/extract-file-content-to-a-string">https://programming-idioms.org/idiom/58/extract-file-content-to-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0109.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>

char* read_file_to_string(const char* path) {
    FILE* file = fopen(path, "rb");
    if (!file) {
        return NULL;
    }

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);

    char* buffer = (char*)malloc((size_t)size + 1);
    if (!buffer) {
        fclose(file);
        return NULL;
    }

    fread(buffer, 1, (size_t)size, file);
    buffer[size] = '\0';

    fclose(file);
    return buffer;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0110" name="idiom: Find substring position" kind="idiom">
      <signature>int find_substring_index(const char* s, const char* sub) {</signature>
      <summary><![CDATA[<p>Find the byte index of the first occurrence of a substring within a string.</p>]]></summary>
      <notes>
        <note id="note.id-0110.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/62/find-substring-position">https://programming-idioms.org/idiom/62/find-substring-position</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0110.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

int find_substring_index(const char* s, const char* sub) {
    const char* pos = strstr(s, sub);
    if (!pos) {
        return -1;
    }
    return (int)(pos - s);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0111" name="idiom: Fixed-capacity positive decimal digit buffer (LSB-first)" kind="idiom">
      <signature>typedef struct digits_positive_int_buffer {</signature>
      <summary><![CDATA[<p>Fixed-capacity positive decimal digit buffer.<br>Represents a non-negative integer in base-10 with digits stored least-significant first.<br>Intended for problems like LeetCode 989 (Add to Array-Form of Integer) to avoid dynamic<br>allocation in intermediate steps.<br>Invariants:<br>- size in [1, capacity] when representing a value.<br>- digits[i] in [0,9].</p><p>Initializes buf with external storage digits[0..capacity).<br>After init the represented value is 0 (size==1, digits[0]==0).<br>Returns C99LC_RESULT_FAILED if arguments invalid (buf==NULL, digits==NULL, capacity==0).</p><p>Parses non-negative integer k into buf (overwriting previous contents).<br>Requires k&gt;=0 and buf previously initialized. Returns C99LC_RESULT_FAILED on NULL buf or<br>if capacity insufficient (when k has more digits than capacity).</p><p>Loads digits from a big-endian array src[0..n) (as typically provided by LeetCode where<br>the first element is the most significant digit). Fails if n==0, buf NULL, or n&gt;capacity.</p><p>Adds two buffers a and b storing LSB-first digits and writes result into out.<br>Fails if out capacity &lt; max(a.size,b.size)+1 or any pointer NULL. Out may alias neither a nor b.</p><p>Writes big-endian int array of the number in buf into dst[0..dst_cap). On success sets *out_size.<br>Fails if dst_cap &lt; buf-&gt;size. dst and buf must be non-null.</p>]]></summary>
      <examples>
        <example id="ex.id-0111.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdint.h>

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FAILED = 1
} result;

typedef struct digits_positive_int_buffer {
    size_t size;
    size_t capacity;
    unsigned char* digits;
} digits_positive_int_buffer;

result digits_positive_int_init(digits_positive_int_buffer* buf,
                                unsigned char* digits_mem,
                                size_t capacity) {
    if (!buf || !digits_mem || capacity == 0) return RESULT_FAILED;
    buf->size = 1;
    buf->capacity = capacity;
    buf->digits = digits_mem;
    buf->digits[0] = 0;
    return RESULT_SUCCESS;
}

result digits_positive_int_from_int(digits_positive_int_buffer* buf, int k) {
    if (!buf || !buf->digits || buf->capacity == 0) return RESULT_FAILED;
    if (k < 0) return RESULT_FAILED;

    unsigned int v = (unsigned int)k;
    if (v == 0) {
        buf->digits[0] = 0;
        buf->size = 1;
        return RESULT_SUCCESS;
    }

    size_t i = 0;
    while (v && i < buf->capacity) {
        buf->digits[i++] = (unsigned char)(v % 10u);
        v /= 10u;
    }

    if (v != 0) return RESULT_FAILED;
    buf->size = i;
    return RESULT_SUCCESS;
}

result digits_positive_int_from_big_endian_array(digits_positive_int_buffer* buf,
                                                 const int* src,
                                                 size_t n) {
    if (!buf || !buf->digits || !src || n == 0 || n > buf->capacity) return RESULT_FAILED;

    for (size_t i = 0; i < n; ++i) {
        int d = src[n - 1 - i];
        if (d < 0 || d > 9) return RESULT_FAILED;
        buf->digits[i] = (unsigned char)d;
    }

    buf->size = n;
    while (buf->size > 1 && buf->digits[buf->size - 1] == 0) buf->size--;
    return RESULT_SUCCESS;
}

result digits_positive_int_add(const digits_positive_int_buffer* a,
                               const digits_positive_int_buffer* b,
                               digits_positive_int_buffer* out) {
    if (!a || !b || !out || !out->digits) return RESULT_FAILED;
    if (a->size == 0 || b->size == 0) return RESULT_FAILED;
    if (out == a || out == b) return RESULT_FAILED;

    size_t need = (a->size > b->size ? a->size : b->size) + 1;
    if (out->capacity < need) return RESULT_FAILED;

    size_t i = 0;
    unsigned carry = 0;

    for (; i < a->size || i < b->size; ++i) {
        unsigned da = 0, db = 0;
        if (i < a->size) {
            unsigned char d = a->digits[i];
            if (d > 9) return RESULT_FAILED;
            da = d;
        }
        if (i < b->size) {
            unsigned char d = b->digits[i];
            if (d > 9) return RESULT_FAILED;
            db = d;
        }

        unsigned sum = da + db + carry;
        out->digits[i] = (unsigned char)(sum % 10u);
        carry = sum / 10u;
    }

    if (carry) {
        out->digits[i++] = (unsigned char)carry;
    }
    if (i == 0) {
        out->digits[i++] = 0;
    }

    out->size = i;
    return RESULT_SUCCESS;
}

result digits_positive_int_to_big_endian_int_array(const digits_positive_int_buffer* buf,
                                                   int* dst,
                                                   size_t dst_cap,
                                                   size_t* out_size) {
    if (!buf || !buf->digits || !dst || !out_size) return RESULT_FAILED;
    if (buf->size == 0 || dst_cap < buf->size) return RESULT_FAILED;

    for (size_t i = 0; i < buf->size; ++i) {
        unsigned char d = buf->digits[buf->size - 1 - i];
        if (d > 9) return RESULT_FAILED;
        dst[i] = (int)d;
    }

    *out_size = buf->size;
    return RESULT_SUCCESS;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0112" name="idiom: Flexible &quot;build up an initializer&quot; with trailing commas" kind="idiom">
      <signature>int xs[] = {</signature>
      <summary><![CDATA[<p>C allows the trailing comma. It reduces diffs when adding and removing entries.</p>]]></summary>
      <examples>
        <example id="ex.id-0112.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int xs[] = {
    1,
    2,
    3,
};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0113" name="idiom: Format a number with grouped thousands" kind="idiom">
      <signature>void print_grouped(int value) {</signature>
      <summary><![CDATA[<p>Format an integer with thousands separators using the current locale.</p>]]></summary>
      <notes>
        <note id="note.id-0113.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/173/format-a-number-with-grouped-thousands">https://programming-idioms.org/idiom/173/format-a-number-with-grouped-thousands</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0113.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <locale.h>

void print_grouped(int value) {
    setlocale(LC_ALL, "");
    printf("%'d\n", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0114" name="idiom: Format decimal number" kind="idiom">
      <signature>void format_percentage(double value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert a fractional value in the range [0,1] into a percentage string with one decimal digit.</p>]]></summary>
      <notes>
        <note id="note.id-0114.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/65/format-decimal-number">https://programming-idioms.org/idiom/65/format-decimal-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0114.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void format_percentage(double value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%.1f%%", value * 100.0);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0115" name="idiom: Formula with arrays" kind="idiom">
      <signature>void compute_formula(</signature>
      <summary><![CDATA[<p>Apply an element-wise mathematical formula to multiple arrays of equal length.</p>]]></summary>
      <notes>
        <note id="note.id-0115.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/208/formula-with-arrays">https://programming-idioms.org/idiom/208/formula-with-arrays</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0115.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stddef.h>

void compute_formula(
    double* a,
    const double* b,
    const double* c,
    const double* d,
    size_t count,
    double e
) {
    for (size_t i = 0; i < count; ++i) {
        a[i] = e * (a[i] + b[i] * c[i] + cos(d[i]));
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0116" name="idiom: Free and null a pointer" kind="idiom">
      <signature>void free_and_null(void** ptr) {</signature>
      <summary><![CDATA[<p>Release heap memory and clear the pointer to avoid accidental reuse (defense against double-free and use-after-free).</p>]]></summary>
      <notes>
        <note id="note.id-0116.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/40/delete-an-element-from-array">https://programming-idioms.org/idiom/40/delete-an-element-from-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0116.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void free_and_null(void** ptr) {
    if (ptr && *ptr) {
        free(*ptr);
        *ptr = NULL;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0117" name="idiom: Get an environment variable" kind="idiom">
      <signature>const char* get_env_or_default(const char* name, const char* fallback) {</signature>
      <summary><![CDATA[<p>Read an environment variable and fall back to a default value if it is not set.</p>]]></summary>
      <notes>
        <note id="note.id-0117.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/205/get-an-environment-variable">https://programming-idioms.org/idiom/205/get-an-environment-variable</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0117.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

const char* get_env_or_default(const char* name, const char* fallback) {
    const char* value = getenv(name);
    return value ? value : fallback;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0118" name="idiom: Get current date" kind="idiom">
      <signature>time_t now(void) {</signature>
      <summary><![CDATA[<p>Retrieve the current date and time using the standard C time type.</p>]]></summary>
      <notes>
        <note id="note.id-0118.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/61/get-current-date">https://programming-idioms.org/idiom/61/get-current-date</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0118.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

time_t now(void) {
    return time(NULL);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0119" name="idiom: Get file size" kind="idiom">
      <signature>long file_size(const char* path) {</signature>
      <summary><![CDATA[<p>Determine the size of a file in bytes using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0119.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/95/get-file-size">https://programming-idioms.org/idiom/95/get-file-size</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0119.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

long file_size(const char* path) {
    FILE* file = fopen(path, "rb");
    if (!file) {
        return -1;
    }

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fclose(file);
    return size;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0120" name="idiom: Get folder containing current program" kind="idiom">
      <signature>char* executable_directory(void) {</signature>
      <summary><![CDATA[<p>Determine the directory containing the currently executing program on Unix-like systems. Returns a dynamically allocated string that must be freed by caller, or NULL on error.</p>]]></summary>
      <notes>
        <note id="note.id-0120.1" severity="warning" topic="portability">
          <description><![CDATA[<p>This implementation is POSIX-specific (readlink with /proc/self/exe works on Linux). Not portable to C99 standard alone.</p>]]></description>
        </note>
        <note id="note.id-0120.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/107/get-folder-containing-current-program">https://programming-idioms.org/idiom/107/get-folder-containing-current-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0120.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>

char* executable_directory(void) {
    char path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (len < 0) {
        return NULL;
    }
    path[len] = '\0';

    /* Find last slash */
    char* last_slash = strrchr(path, '/');
    if (!last_slash) {
        return NULL;  /* no directory component */
    }

    /* Truncate at last slash to get directory */
    *last_slash = '\0';

    /* Return allocated copy */
    return strdup(path);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0121" name="idiom: Get program working directory" kind="idiom">
      <signature>char* working_directory(void) {</signature>
      <summary><![CDATA[<p>Retrieve the current working directory path. Returns a dynamically allocated string that must be freed by caller, or NULL on error.</p>]]></summary>
      <notes>
        <note id="note.id-0121.1" severity="warning" topic="portability">
          <description><![CDATA[<p>getcwd is POSIX, not C99 standard. The NULL argument for automatic allocation is a GNU extension.</p>]]></description>
        </note>
        <note id="note.id-0121.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/106/get-program-working-directory">https://programming-idioms.org/idiom/106/get-program-working-directory</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0121.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <unistd.h>

char* working_directory(void) {
    return getcwd(NULL, 0);  /* GNU extension: auto-allocate */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0122" name="idiom: Handle invalid argument" kind="idiom">
      <signature>bool square_checked(int value, int* result) {</signature>
      <summary><![CDATA[<p>Validate a function argument and report failure using an explicit status code.</p>]]></summary>
      <notes>
        <note id="note.id-0122.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/89/handle-invalid-argument">https://programming-idioms.org/idiom/89/handle-invalid-argument</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0122.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

bool square_checked(int value, int* result) {
    if (value > 46340 || value < -46340) {
        return false;
    }
    *result = value * value;
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0123" name="idiom: Hex dump loop that is careful about signedness" kind="idiom">
      <signature>const unsigned char* b = buf;</signature>
      <summary><![CDATA[<p>Casting avoids <code>char</code> sign surprises.</p>]]></summary>
      <examples>
        <example id="ex.id-0123.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const unsigned char* b = buf;
for (size_t i = 0; i < n; ++i) printf("%02X", (unsigned)b[i]);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0124" name="idiom: Hex string to byte array" kind="idiom">
      <signature>unsigned char* hex_to_bytes(const char* hex, size_t* out_count) {</signature>
      <summary><![CDATA[<p>Convert a hexadecimal string into a byte array.</p>]]></summary>
      <notes>
        <note id="note.id-0124.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/176/hex-string-to-byte-array">https://programming-idioms.org/idiom/176/hex-string-to-byte-array</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0124.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <ctype.h>

unsigned char* hex_to_bytes(const char* hex, size_t* out_count) {
    size_t len = strlen(hex) / 2;
    unsigned char* bytes = (unsigned char*)malloc(len);
    if (!bytes) {
        return NULL;
    }

    for (size_t i = 0; i < len; ++i) {
        unsigned int value;
        sscanf(hex + i * 2, "%2x", &value);
        bytes[i] = (unsigned char)value;
    }

    *out_count = len;
    return bytes;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0125" name="idiom: Hexadecimal digits of an integer" kind="idiom">
      <signature>void int_to_hex(unsigned int value, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Convert an integer value to its hexadecimal string representation.</p>]]></summary>
      <notes>
        <note id="note.id-0125.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/142/hexadecimal-digits-of-an-integer">https://programming-idioms.org/idiom/142/hexadecimal-digits-of-an-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0125.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void int_to_hex(unsigned int value, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "%x", value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0126" name="idiom: Increment decimal digit array in place" kind="idiom">
      <signature>void digits_increment(unsigned char* digits, size_t digits_size);</signature>
      <summary><![CDATA[<p>Increments a big-endian decimal digit array in place by 1.<br>Digits must be in [0,9]; carry ripples from the least significant end.</p>]]></summary>
      <examples>
        <example id="ex.id-0126.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

void digits_increment(unsigned char* digits, size_t digits_size) {
    if (!digits || digits_size == 0) return;

    for (size_t i = digits_size; i-- > 0;) {
        if (digits[i] < 9) {
            digits[i] = (unsigned char)(digits[i] + 1);
            return;
        }
        digits[i] = 0;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0127" name="idiom: Integer exponentiation by squaring" kind="idiom">
      <signature>unsigned int int_pow(unsigned int base, unsigned int exp) {</signature>
      <summary><![CDATA[<p>Compute the power of a non-negative integer base raised to a non-negative integer exponent using exponentiation by squaring.</p>]]></summary>
      <notes>
        <note id="note.id-0127.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/32/integer-exponentiation-by-squaring">https://programming-idioms.org/idiom/32/integer-exponentiation-by-squaring</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0127.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int int_pow(unsigned int base, unsigned int exp) {
    if (exp == 0) {
        return 1;
    }
    if ((exp & 1U) == 0) {
        return int_pow(base *base, exp / 2);
    }
    return base * int_pow(base * base, (exp - 1) / 2);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0128" name="idiom: Interleave halves of array" kind="idiom">
      <signature>void array_int_interleave_halves(int* dst, const int* src, size_t n);</signature>
      <summary><![CDATA[<p>Interleave halves of an int array.<br>Input:  src holds 2*n ints as [x1, x2, ..., xn, y1, y2, ..., yn].<br>Output: dst becomes [x1, y1, x2, y2, ..., xn, yn].<br>No allocation; no-op if pointers are NULL or n==0.</p>]]></summary>
      <examples>
        <example id="ex.id-0128.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

void array_int_interleave_halves(int* dst, const int* src, size_t n) {
    if (!dst || !src || n == 0) return;

    for (size_t i = 0; i < n; ++i) {
        dst[2 * i] = src[i];
        dst[2 * i + 1] = src[n + i];
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0129" name="idiom: Iterate over list indexes and values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Iterate over an array while accessing both index and value in a type-safe and explicit manner.</p>]]></summary>
      <notes>
        <note id="note.id-0129.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values">https://programming-idioms.org/idiom/7/iterate-over-list-indexes-and-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0129.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

typedef struct {
    const char* name;
} Item;

const char* item_to_string(Item item) {
    return item.name;
}

void print_items(const Item* items, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        printf("Item %zu = %s\n", i, item_to_string(items[i]));
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0130" name="idiom: Iterate over list values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Iterate over each element of an array and apply a processing function to each element, with all required context explicitly defined.</p>]]></summary>
      <notes>
        <note id="note.id-0130.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/6/iterate-over-list-values">https://programming-idioms.org/idiom/6/iterate-over-list-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0130.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

typedef struct {
    int id;
} Item;

void process_item(Item* item) {
    item->id += 1;
}

void process_items(Item* items, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        process_item(&items[i]);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0131" name="idiom: Join a list of strings" kind="idiom">
      <signature>void join_strings(</signature>
      <summary><![CDATA[<p>Concatenate an array of strings into a single buffer using a fixed separator.</p>]]></summary>
      <notes>
        <note id="note.id-0131.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/53/join-a-list-of-strings">https://programming-idioms.org/idiom/53/join-a-list-of-strings</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0131.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

void join_strings(
    const char** parts,
    size_t count,
    const char* separator,
    char* output,
    size_t output_size
) {
    output[0] = '\0';

    for (size_t i = 0; i < count; ++i) {
        if (i > 0) {
            strncat(output, separator, output_size - strlen(output) - 1);
        }
        strncat(output, parts[i], output_size - strlen(output) - 1);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0132" name="idiom: Join integer from LSB-first digit array" kind="idiom">
      <signature>int integers_join_digits_from_array(const unsigned char* src_array,</signature>
      <summary><![CDATA[<p>Reconstructs an integer from digits stored LSB-first in src_array. Returns 0 if src_array is NULL or src_array_size is 0. <strong>Warning:</strong> Does not check for integer overflow. For values exceeding INT_MAX, use long or add overflow detection.</p>]]></summary>
      <examples>
        <example id="ex.id-0132.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

int integers_join_digits_from_array(const unsigned char* src_array, size_t src_array_size) {
    if (!src_array || src_array_size == 0) return 0;

    int value = 0;
    int place = 1;

    for (size_t i = 0; i < src_array_size; ++i) {
        unsigned char d = src_array[i];
        if (d > 9) return 0;  /* invalid digit */

        /* Warning: no overflow check - caller must ensure result fits in int */
        value += (int)d * place;
        place *= 10;
    }
    return value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0133" name="idiom: Last element of list" kind="idiom">
      <signature>int last_element(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Retrieve the last element of a non-empty array.</p>]]></summary>
      <notes>
        <note id="note.id-0133.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/165/last-element-of-list">https://programming-idioms.org/idiom/165/last-element-of-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0133.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int last_element(const int* array, size_t count) {
    return array[count - 1];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0134" name="idiom: Launch other program" kind="idiom">
      <signature>int launch_program(const char* command) {</signature>
      <summary><![CDATA[<p>Execute another program using the system shell. <strong>Security warning:</strong> Never pass unsanitized user input to system() - vulnerable to shell injection attacks. Returns the command's exit status.</p>]]></summary>
      <notes>
        <note id="note.id-0134.1" severity="warning" topic="security">
          <description><![CDATA[<p>system() invokes a shell and is vulnerable to command injection. Validate/sanitize all inputs or use safer alternatives like POSIX execvp().</p>]]></description>
        </note>
        <note id="note.id-0134.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/111/launch-other-program">https://programming-idioms.org/idiom/111/launch-other-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0134.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int launch_program(const char* command) {
    return system(command);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0135" name="idiom: Leap year check (Gregorian 4/100/400 rule)" kind="idiom">
      <signature>bool date_is_leap_year(uint32_t year);</signature>
      <summary><![CDATA[<p>Returns true if year is a Gregorian leap year.<br>Applies the 4, 100, 400 rule.</p>]]></summary>
      <examples>
        <example id="ex.id-0135.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stdint.h>
#include <stdbool.h>

bool date_is_leap_year(uint32_t year) {
    return (year % 4u == 0u) && ((year % 100u != 0u) || (year % 400u == 0u));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0136" name="idiom: List files in directory" kind="idiom">
      <signature>int list_directory(const char* path) {</signature>
      <summary><![CDATA[<p>List entries in a directory without recursion. Returns 0 on success, -1 on error.</p>]]></summary>
      <notes>
        <note id="note.id-0136.1" severity="warning" topic="portability">
          <description><![CDATA[<p>opendir/readdir/closedir are POSIX, not C99 standard. No portable directory listing in C99 alone.</p>]]></description>
        </note>
        <note id="note.id-0136.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/180/list-files-in-directory">https://programming-idioms.org/idiom/180/list-files-in-directory</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0136.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <dirent.h>
#include <stdio.h>

int list_directory(const char* path) {
    DIR *dir = opendir(path);
    if (!dir) {
        return -1;
    }

    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
    }

    closedir(dir);
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0137" name="idiom: Local static for expensive one-time setup inside a function" kind="idiom">
      <signature>const char* lookup(int k) {</signature>
      <summary><![CDATA[<p>This avoids repeated initialization and keeps the table close to the code that uses it.</p>]]></summary>
      <examples>
        <example id="ex.id-0137.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* lookup(int k) {
    static const char* tbl[] = { "zero", "one", "two" };
    return (k >= 0 && k < (int)(sizeof tbl / sizeof tbl[0])) ? tbl[k] : "unknown";
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0138" name="idiom: Make an infinite loop" kind="idiom">
      <signature>for (;;) {</signature>
      <summary><![CDATA[<p>Execute a loop without a termination condition.</p>]]></summary>
      <notes>
        <note id="note.id-0138.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/50/make-an-infinite-loop">https://programming-idioms.org/idiom/50/make-an-infinite-loop</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0138.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (;;) {
    /* loop forever */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0139" name="idiom: Measure elapsed CPU time" kind="idiom">
      <signature>double elapsed_seconds(clock_t start, clock_t end) {</signature>
      <summary><![CDATA[<p>Measure elapsed processor time using the standard C clock. Returns time in seconds.</p>]]></summary>
      <notes>
        <note id="note.id-0139.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/104/measure-time">https://programming-idioms.org/idiom/104/measure-time</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0139.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

double elapsed_seconds(clock_t start, clock_t end) {
    return (double)(end - start) / CLOCKS_PER_SEC;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0140" name="idiom: Memset a struct via its address, not by casting" kind="idiom">
      <signature>memset(&amp;s, 0, sizeof s);</signature>
      <summary><![CDATA[<p>Straightforward, but still the correct idiom when <code>{0}</code> is not possible.</p>]]></summary>
      <examples>
        <example id="ex.id-0140.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
memset(&s, 0, sizeof s);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0141" name="idiom: Multi-line string literal" kind="idiom">
      <signature>const char* s =</signature>
      <summary><![CDATA[<p>Assign a string literal composed of multiple lines using implicit string literal concatenation.</p>]]></summary>
      <notes>
        <note id="note.id-0141.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/48/multi-line-string-literal">https://programming-idioms.org/idiom/48/multi-line-string-literal</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0141.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
const char* s =
    "Huey\n"
    "Dewey\n"
    "Louie\n";
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0142" name="idiom: Multiple return values" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Return multiple values from a function by grouping them in a structure.</p>]]></summary>
      <notes>
        <note id="note.id-0142.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/126/multiple-return-values">https://programming-idioms.org/idiom/126/multiple-return-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0142.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

typedef struct {
    const char* text;
    bool ok;
} Result;

Result make_result(void) {
    Result r = { "Hello", true };
    return r;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0143" name="idiom: Multiply all the elements of a list" kind="idiom">
      <signature>void scale_ints(int* array, size_t count, int factor) {</signature>
      <summary><![CDATA[<p>Multiply each element of an integer array by a constant factor.</p>]]></summary>
      <notes>
        <note id="note.id-0143.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list">https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0143.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

void scale_ints(int* array, size_t count, int factor) {
    for (size_t i = 0; i < count; ++i) {
        array[i] *= factor;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0144" name="idiom: Number of bytes of a type" kind="idiom">
      <signature>size_t bytes_of(int value) {</signature>
      <summary><![CDATA[<p>Determine the number of bytes occupied by a variable.</p>]]></summary>
      <notes>
        <note id="note.id-0144.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type">https://programming-idioms.org/idiom/109/number-of-bytes-of-a-type</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0144.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stddef.h>

size_t bytes_of(int value) {
    return sizeof(value);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0145" name="idiom: Packed bitset with test/set/clear" kind="idiom">
      <signature>typedef struct bitset {</signature>
      <summary><![CDATA[<p>Compact bitset using uint8_t array with flexible array member.<br>Stores bits packed into bytes, providing efficient storage for boolean flags.<br>Bit indices are zero-based; bit i resides in items[i/8] at position (i%8).</p><p>Creates a bitset capable of storing up to bits_capacity bits.<br>All bits are initialized to 0.<br>Returns NULL on allocation failure or if bits_capacity is 0.<br>Complexity: O(n) where n = (bits_capacity + 7) / 8.</p><p>Destroys a bitset and frees its memory.<br>Safe to call with NULL pointer.</p><p>Tests whether the bit at bit_index is set (1) or clear (0).<br>Returns true if the bit is set, false otherwise.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p><p>Sets the bit at bit_index to 1.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p><p>Clears the bit at bit_index to 0.<br>Behavior is undefined if bit_index &gt;= bitset-&gt;bits_capacity or bitset is NULL.<br>Complexity: O(1).</p>]]></summary>
      <examples>
        <example id="ex.id-0145.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

typedef struct bitset {
    size_t bytes_capacity;
    size_t bits_capacity;
    uint8_t items[];
} bitset;

static size_t bitset_bytes_for_bits(size_t bits_capacity) {
    return (bits_capacity + 7u) / 8u;
}

bitset* bitset_create(size_t bits_capacity) {
    if (bits_capacity == 0) return NULL;

    size_t bytes = bitset_bytes_for_bits(bits_capacity);
    bitset* bs = (bitset*)malloc(sizeof(*bs) + bytes * sizeof(bs->items[0]));
    if (!bs) return NULL;

    bs->bytes_capacity = bytes;
    bs->bits_capacity = bits_capacity;
    memset(bs->items, 0, bytes);
    return bs;
}

void bitset_destroy(bitset* bs) {
    free(bs);
}

bool bitset_test(const bitset* bs, size_t bit_index) {
    if (!bs || bit_index >= bs->bits_capacity) return false;
    size_t byte_i = bit_index / 8u;
    unsigned shift = (unsigned)(bit_index % 8u);
    return (bs->items[byte_i] & (uint8_t)(1u << shift)) != 0;
}

void bitset_set(bitset* bs, size_t bit_index) {
    if (!bs || bit_index >= bs->bits_capacity) return;
    size_t byte_i = bit_index / 8u;
    unsigned shift = (unsigned)(bit_index % 8u);
    bs->items[byte_i] |= (uint8_t)(1u << shift);
}

void bitset_clear(bitset* bs, size_t bit_index) {
    if (!bs || bit_index >= bs->bits_capacity) return;
    size_t byte_i = bit_index / 8u;
    unsigned shift = (unsigned)(bit_index % 8u);
    bs->items[byte_i] &= (uint8_t)~(uint8_t)(1u << shift);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0146" name="idiom: Parenthesis classification and matching" kind="idiom">
      <signature>bool char_is_open_paren(char ch);</signature>
      <summary><![CDATA[<p>Returns true if the character is an opening parenthesis: '(', '{', or '['.<br>Returns false for any other character.</p><p>Returns true if the character is a closing parenthesis: ')', '}', or ']'.<br>Returns false for any other character.</p><p>Returns the matching parenthesis for the given character.<br>Maps '(' to ')', '{' to '}', '[' to ']' and vice versa.<br>Returns '\0' if the character is not a recognized parenthesis.</p>]]></summary>
      <examples>
        <example id="ex.id-0146.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stdbool.h>

bool char_is_open_paren(char ch) {
    return ch == '(' || ch == '{' || ch == '[';
}

bool char_is_close_paren(char ch) {
    return ch == ')' || ch == '}' || ch == ']';
}

char char_paren_reverse(char ch) {
    switch (ch) {
        case '(': return ')';
        case ')': return '(';
        case '{': return '}';
        case '}': return '{';
        case '[': return ']';
        case ']': return '[';
        default: return '\0';
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0147" name="idiom: Parse integer digits to LSB-first array" kind="idiom">
      <signature>void integers_parse_digits_to_array(</signature>
      <summary><![CDATA[<p>Decomposes source into decimal digits written LSB-first into dest_array.<br>Writes up to dest_array_size digits; negative numbers produce absolute digits.</p>]]></summary>
      <examples>
        <example id="ex.id-0147.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

void integers_parse_digits_to_array(int source, unsigned char* dest_array, size_t dest_array_size) {
    if (!dest_array || dest_array_size == 0) return;

    long long v = (long long)source;
    if (v < 0) v = -v;

    for (size_t i = 0; i < dest_array_size; ++i) {
        dest_array[i] = (unsigned char)(v % 10);
        v /= 10;
        if (v == 0) {
            for (size_t j = i + 1; j < dest_array_size; ++j) dest_array[j] = 0;
            return;
        }
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0148" name="idiom: Parse ISO date string YYYY-MM-DD with validation" kind="idiom">
      <signature>result reasonable_date_parse_from_string(</signature>
      <summary><![CDATA[<p>Parses "YYYY-MM-DD" into out and validates month and day ranges.<br>Returns C99LC_RESULT_SUCCESS on success, otherwise C99LC_RESULT_FAILED.</p>]]></summary>
      <examples>
        <example id="ex.id-0148.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdint.h>
#include <ctype.h>

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FAILED = 1
} result;

typedef struct reasonable_date {
    uint32_t year;
    uint32_t month;
    uint32_t day;
} reasonable_date;

static int date_is_leap_year(uint32_t year) {
    return (year % 4u == 0u) && ((year % 100u != 0u) || (year % 400u == 0u));
}

static uint32_t date_days_in_month(uint32_t year, uint32_t month) {
    static const uint8_t days[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
    if (month < 1u || month > 12u) return 0;
    uint32_t d = (uint32_t)days[month - 1u];
    if (month == 2u && date_is_leap_year(year)) d = 29;
    return d;
}

static int parse_2(const char* s, uint32_t* out) {
    if (!isdigit((unsigned char)s[0]) || !isdigit((unsigned char)s[1])) return 0;
    *out = (uint32_t)((s[0] - '0') * 10 + (s[1] - '0'));
    return 1;
}

static int parse_4(const char* s, uint32_t* out) {
    uint32_t v = 0;
    for (int i = 0; i < 4; ++i) {
        if (!isdigit((unsigned char)s[i])) return 0;
        v = v * 10u + (uint32_t)(s[i] - '0');
    }
    *out = v;
    return 1;
}

result reasonable_date_parse_from_string(const char* date_string, reasonable_date* out) {
    if (!date_string || !out) return RESULT_FAILED;

    if (!(date_string[0] && date_string[1] && date_string[2] && date_string[3] &&
          date_string[4] == '-' &&
          date_string[5] && date_string[6] &&
          date_string[7] == '-' &&
          date_string[8] && date_string[9] &&
          date_string[10] == '\0')) {
        return RESULT_FAILED;
    }

    uint32_t y = 0, m = 0, d = 0;
    if (!parse_4(date_string + 0, &y)) return RESULT_FAILED;
    if (!parse_2(date_string + 5, &m)) return RESULT_FAILED;
    if (!parse_2(date_string + 8, &d)) return RESULT_FAILED;

    uint32_t dim = date_days_in_month(y, m);
    if (dim == 0 || d < 1u || d > dim) return RESULT_FAILED;

    out->year = y;
    out->month = m;
    out->day = d;
    return RESULT_SUCCESS;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0149" name="idiom: Parse uint32 from ASCII decimal string (validated)" kind="idiom">
      <signature>result integer_parse_uint32_from_string(</signature>
      <summary><![CDATA[<p>Parses ASCII decimal digits from input[0..input_size) into *out.<br>Fails on non-digits or empty input; returns a C99LC_RESULT_* code.</p>]]></summary>
      <examples>
        <example id="ex.id-0149.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdint.h>

typedef enum {
    RESULT_SUCCESS = 0,
    RESULT_FAILED = 1
} result;

result integer_parse_uint32_from_string(const char* input, size_t input_size, uint32_t* out) {
    if (!out) return RESULT_FAILED;
    if (!input || input_size == 0) return RESULT_FAILED;

    uint32_t v = 0;
    for (size_t i = 0; i < input_size; ++i) {
        unsigned char c = (unsigned char)input[i];
        if (c < (unsigned char)'0' || c > (unsigned char)'9') return RESULT_FAILED;
        uint32_t digit = (uint32_t)(c - (unsigned char)'0');

        if (v > (UINT32_MAX - digit) / 10u) return RESULT_FAILED;
        v = v * 10u + digit;
    }

    *out = v;
    return RESULT_SUCCESS;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0150" name="idiom: Parse with `strtol` and keep the end pointer in the loop header" kind="idiom">
      <signature>for (char* p = s; *p; ) {</signature>
      <summary><![CDATA[<p>This is a robust skeleton for numeric tokenization.</p>]]></summary>
      <examples>
        <example id="ex.id-0150.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (char* p = s; *p; ) {
    char* end;
    long v = strtol(p, &end, 10);
    if (end == p) break;     /* no progress */
    /* use v */
    p = end;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0151" name="idiom: Pass a runnable procedure as parameter" kind="idiom">
      <signature>void run(void (*fn)(void)) {</signature>
      <summary><![CDATA[<p>Accept a function pointer as an argument and invoke it.</p>]]></summary>
      <notes>
        <note id="note.id-0151.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/93/pass-a-runnable-procedure-as-parameter">https://programming-idioms.org/idiom/93/pass-a-runnable-procedure-as-parameter</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0151.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void run(void (*fn)(void)) {
    fn();
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0152" name="idiom: Pause execution for 5 seconds" kind="idiom">
      <signature>void sleep_seconds(unsigned int seconds) {</signature>
      <summary><![CDATA[<p>Pause program execution for approximately five seconds using only standard C time facilities.</p>]]></summary>
      <notes>
        <note id="note.id-0152.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/45/pause-execution-for-5-seconds">https://programming-idioms.org/idiom/45/pause-execution-for-5-seconds</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0152.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <time.h>

void sleep_seconds(unsigned int seconds) {
    time_t start = time(NULL);
    while (difftime(time(NULL), start) < seconds) {
        /* busy wait */
    }
}

void pause_five_seconds(void) {
    sleep_seconds(5);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0153" name="idiom: Pick a random element from a list" kind="idiom">
      <signature>int pick_random_int(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Select one element uniformly at random from a non-empty integer array.</p>]]></summary>
      <notes>
        <note id="note.id-0153.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/11/pick-a-random-element-from-a-list">https://programming-idioms.org/idiom/11/pick-a-random-element-from-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0153.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int pick_random_int(const int* array, size_t count) {
    return array[rand() % count];
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0154" name="idiom: Pick uniformly a random floating point number in [a..b)" kind="idiom">
      <signature>double random_double_range(double a, double b) {</signature>
      <summary><![CDATA[<p>Generate a floating point value greater than or equal to a and strictly less than b.</p>]]></summary>
      <notes>
        <note id="note.id-0154.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/14/pick-uniformly-a-random-floating-point-number-in-a-b">https://programming-idioms.org/idiom/14/pick-uniformly-a-random-floating-point-number-in-a-b</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0154.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

double random_double_range(double a, double b) {
    return a + (b - a) * ((double)rand() / (double)RAND_MAX);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0155" name="idiom: Pick uniformly a random integer in [a..b]" kind="idiom">
      <signature>int random_int_range(int a, int b) {</signature>
      <summary><![CDATA[<p>Generate a uniformly distributed integer in a closed interval while avoiding modulo bias.</p>]]></summary>
      <notes>
        <note id="note.id-0155.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/15/pick-uniformly-a-random-integer-in-a-b">https://programming-idioms.org/idiom/15/pick-uniformly-a-random-integer-in-a-b</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0155.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

int random_int_range(int a, int b) {
    const int range = b - a + 1;
    const int limit = RAND_MAX - (RAND_MAX % range);
    int r;

    do {
        r = rand();
    } while (r >= limit);

    return a + (r % range);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0156" name="idiom: Pointer iteration over array with end pointer" kind="idiom">
      <signature>void increment_all(int* data, size_t count) {</signature>
      <summary><![CDATA[<p>Process a contiguous buffer using pointer arithmetic and an explicit length.</p><p>You avoid repeated indexing arithmetic and it composes well with subranges.</p>]]></summary>
      <notes>
        <note id="note.id-0156.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/6/iterate-over-list-values">https://programming-idioms.org/idiom/6/iterate-over-list-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0156.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stddef.h>

void increment_all(int* data, size_t count) {
    int* end = data + count;
    while (data < end) {
        (*data)++;
        data++;
    }
}
]]></code>
        </example>
        <example id="ex.id-0156.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
for (int* p = a, *e = a + n; p != e; ++p) {
    *p += 1;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0157" name="idiom: Preserve `errno` across cleanup that might clobber it" kind="idiom">
      <signature>int saved = errno;</signature>
      <summary><![CDATA[<p>This matters when callers use <code>errno</code> to diagnose the original failure.</p>]]></summary>
      <examples>
        <example id="ex.id-0157.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int saved = errno;
/* cleanup that might call functions touching errno */
errno = saved;
return -1;
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0158" name="idiom: Print `size_t` and pointers correctly" kind="idiom">
      <signature>printf(&quot;n=%zu\n&quot;, n);</signature>
      <summary><![CDATA[<p>These format specifiers prevent subtle UB and portability bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0158.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
printf("n=%zu\n", n);
printf("p=%p\n", (void*)p);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0159" name="idiom: Print Hello 10 times" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Execute the same output operation a fixed number of times using a deterministic loop.</p>]]></summary>
      <notes>
        <note id="note.id-0159.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/2/print-hello-10-times">https://programming-idioms.org/idiom/2/print-hello-10-times</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0159.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    for (int i = 0; i < 10; ++i) {
        printf("Hello\n");
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0160" name="idiom: Print Hello World" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Print a literal string followed by a newline to the standard output stream using a generic formatted output function.</p>]]></summary>
      <notes>
        <note id="note.id-0160.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/1/print-hello-world">https://programming-idioms.org/idiom/1/print-hello-world</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0160.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0161" name="idiom: Print integer array with brackets" kind="idiom">
      <signature>void print_integer_array(const unsigned char* a, size_t n);</signature>
      <summary><![CDATA[<p>Prints digits as "[d0, d1, ...]\n" to stdout.<br>Safe to call with NULL pointer (prints an empty list).</p>]]></summary>
      <examples>
        <example id="ex.id-0161.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>
#include <stdio.h>

void print_integer_array(const unsigned char* a, size_t n) {
    putchar('[');
    if (a && n) {
        for (size_t i = 0; i < n; ++i) {
            if (i) printf(", ");
            printf("%u", (unsigned)a[i]);
        }
    }
    putchar(']');
    putchar('
');
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0162" name="idiom: Print list elements by group of 2" kind="idiom">
      <signature>void print_pairs(const int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Print elements of an integer array two at a time.</p>]]></summary>
      <notes>
        <note id="note.id-0162.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/163/print-list-elements-by-group-of-2">https://programming-idioms.org/idiom/163/print-list-elements-by-group-of-2</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0162.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void print_pairs(const int* array, size_t count) {
    for (size_t i = 0; i + 1 < count; i += 2) {
        printf("%d, %d\n", array[i], array[i + 1]);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0163" name="idiom: Public declaration macro for C/C++ linkage (extern/static)" kind="idiom">
      <signature>Public declaration macro for C/C++ linkage (extern/static)</signature>
      <summary><![CDATA[]]></summary>
      <examples>
        <example id="ex.id-0163.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define extern
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0164" name="idiom: Quine program" kind="idiom">
      <signature>int main(void) {</signature>
      <summary><![CDATA[<p>Output the program source code itself without reading from external files.</p>]]></summary>
      <notes>
        <note id="note.id-0164.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/182/quine-program">https://programming-idioms.org/idiom/182/quine-program</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0164.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int main(void) {
    const char* s =
        "#include <stdio.h>\n\n"
        "int main(void) {\n"
        "    const char* s = \"%s\";\n"
        "    printf(s, s);\n"
        "    return 0;\n"
        "}\n";
    printf(s, s);
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0165" name="idiom: Read command line argument" kind="idiom">
      <signature>int main(int argc, char* argv[]) {</signature>
      <summary><![CDATA[<p>Read the first command-line argument after the program name.</p>]]></summary>
      <notes>
        <note id="note.id-0165.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/60/read-command-line-argument">https://programming-idioms.org/idiom/60/read-command-line-argument</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0165.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int main(int argc, char* argv[]) {
    if (argc > 1) {
        const char* arg = argv[1];
        (void)arg;
    }
    return 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0166" name="idiom: Read file line by line" kind="idiom">
      <signature>void read_lines(FILE* file) {</signature>
      <summary><![CDATA[<p>Read a text file line by line using standard C I/O.</p>]]></summary>
      <notes>
        <note id="note.id-0166.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/120/read-integer-from-stdin">https://programming-idioms.org/idiom/120/read-integer-from-stdin</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0166.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void read_lines(FILE* file) {
    char buffer[256];
    while (fgets(buffer, sizeof(buffer), file)) {
        printf("%s", buffer);
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0167" name="idiom: Read integer from stdin" kind="idiom">
      <signature>int read_int(void) {</signature>
      <summary><![CDATA[<p>Read an integer value from standard input.</p>]]></summary>
      <notes>
        <note id="note.id-0167.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/120/read-integer-from-stdin">https://programming-idioms.org/idiom/120/read-integer-from-stdin</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0167.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int read_int(void) {
    int value = 0;
    scanf("%d", &value);
    return value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0168" name="idiom: Recursive factorial (simple)" kind="idiom">
      <signature>unsigned int factorial(unsigned int n) {</signature>
      <summary><![CDATA[<p>Compute the factorial of a non-negative integer using a simple recursive definition.</p>]]></summary>
      <notes>
        <note id="note.id-0168.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/31/recursive-factorial-simple">https://programming-idioms.org/idiom/31/recursive-factorial-simple</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0168.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
unsigned int factorial(unsigned int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0169" name="idiom: Rename file" kind="idiom">
      <signature>int rename_file(const char* from, const char* to) {</signature>
      <summary><![CDATA[<p>Rename a file on the filesystem.</p>]]></summary>
      <notes>
        <note id="note.id-0169.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/343/rename-file">https://programming-idioms.org/idiom/343/rename-file</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0169.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

int rename_file(const char* from, const char* to) {
    return rename(from, to);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0170" name="idiom: Repeated string" kind="idiom">
      <signature>char* repeat_string(const char* value, size_t times) {</signature>
      <summary><![CDATA[<p>Create a new string consisting of a base string repeated a fixed number of times.</p>]]></summary>
      <notes>
        <note id="note.id-0170.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/266/repeated-string">https://programming-idioms.org/idiom/266/repeated-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0170.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* repeat_string(const char* value, size_t times) {
    size_t len = strlen(value);
    char* result = (char*)malloc(len * times + 1);
    if (!result) {
        return NULL;
    }

    char* p = result;
    for (size_t i = 0; i < times; ++i) {
        memcpy(p, value, len);
        p += len;
    }
    result[len * times] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0171" name="idiom: Resize dynamic array safely" kind="idiom">
      <signature>void* xrealloc(void* ptr, size_t size) {</signature>
      <summary><![CDATA[<p>Grow or shrink a dynamic allocation while preserving existing data.</p>]]></summary>
      <notes>
        <note id="note.id-0171.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/58/extract-file-content-to-a-string">https://programming-idioms.org/idiom/58/extract-file-content-to-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0171.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void* xrealloc(void* ptr, size_t size) {
    void* new_ptr = realloc(ptr, size);
    if (!new_ptr) {
        free(ptr);
        return NULL;
    }
    return new_ptr;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0172" name="idiom: Result code enum for success/failure" kind="idiom">
      <signature>typedef int result;</signature>
      <summary><![CDATA[]]></summary>
      <examples>
        <example id="ex.id-0172.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

typedef int result;
enum { RESULT_SUCCESS = 0, RESULT_FAILED = 1 };
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0173" name="idiom: Return fraction and exponent of a real number" kind="idiom">
      <signature>void print_fraction_exponent(double value) {</signature>
      <summary><![CDATA[<p>Decompose a floating point value into its normalized fraction and exponent.</p>]]></summary>
      <notes>
        <note id="note.id-0173.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/204/return-fraction-and-exponent-of-a-real-number">https://programming-idioms.org/idiom/204/return-fraction-and-exponent-of-a-real-number</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0173.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>
#include <stdio.h>

void print_fraction_exponent(double value) {
    int exponent;
    double fraction = frexp(value, &exponent);
    printf("%f %d\n", fraction, exponent);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0174" name="idiom: Return static string literal" kind="idiom">
      <signature>const char* helloworld(void);</signature>
      <summary><![CDATA[<p>Returns a pointer to a constant, null-terminated "Hello, World!" string.<br>Storage duration is static; caller must not free the returned pointer.</p><p>Returns the library version string such as "0.1".<br>String has static storage duration; caller must not free it.</p>]]></summary>
      <examples>
        <example id="ex.id-0174.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

const char* helloworld(void) {
    return "Hello, World!";
}

const char* version(void) {
    return "1.0.0";
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0175" name="idiom: Return status/error code with output parameters" kind="idiom">
      <signature>bool parse_positive_int(const char* s, int* out_value) {</signature>
      <summary><![CDATA[<p>Return a success flag while writing the result through an output parameter.</p><p>Search a 2D integer matrix for a value and return its coordinates using output parameters.</p><p>Callers can stack-allocate <code>struct Result</code> and you avoid heap ownership questions.</p>]]></summary>
      <notes>
        <note id="note.id-0175.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/89/handle-invalid-argument">https://programming-idioms.org/idiom/89/handle-invalid-argument</a></p>]]></description>
        </note>
        <note id="note.id-0175.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/20/return-two-values">https://programming-idioms.org/idiom/20/return-two-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0175.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdbool.h>

bool parse_positive_int(const char* s, int* out_value) {
    int value = atoi(s);
    if (value <= 0) {
        return false;
    }
    *out_value = value;
    return true;
}
]]></code>
        </example>
        <example id="ex.id-0175.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stddef.h>
#include <stdbool.h>

bool find_in_matrix(
    const int* matrix,
    size_t rows,
    size_t cols,
    int target,
    size_t* out_row,
    size_t* out_col
) {
    for (size_t r = 0; r < rows; ++r) {
        for (size_t c = 0; c < cols; ++c) {
            if (matrix[r * cols + c] == target) {
                *out_row = r;
                *out_col = c;
                return true;
            }
        }
    }
    return false;
}
]]></code>
        </example>
        <example id="ex.id-0175.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
int parse(const char* s, struct Result* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0176" name="idiom: Reverse a string" kind="idiom">
      <signature>char* reverse_string(const char* s) {</signature>
      <summary><![CDATA[<p>Create a new string containing the characters of the input string in reverse byte order. Multibyte encodings are not preserved.</p>]]></summary>
      <notes>
        <note id="note.id-0176.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/41/reverse-a-string">https://programming-idioms.org/idiom/41/reverse-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0176.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <string.h>

char* reverse_string(const char* s) {
    size_t len = strlen(s);
    char* result = (char*)malloc(len + 1);
    if (!result) {
        return NULL;
    }

    for (size_t i = 0; i < len; ++i) {
        result[i] = s[len - 1 - i];
    }
    result[len] = '\0';
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0177" name="idiom: Reverse array/list in place" kind="idiom">
      <signature>void reverse_ints(int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Reverse the elements of an integer array in place.</p><p>Reverses array[0..array_size) in place.<br>No-op if array is NULL or array_size is 0.</p>]]></summary>
      <notes>
        <note id="note.id-0177.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/19/reverse-a-list">https://programming-idioms.org/idiom/19/reverse-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
<example id="ex.id-0177.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stddef.h>

void reverse_ints(int* array, size_t count) {
    size_t left = 0;
    size_t right = count ? count - 1 : 0;

    while (left < right) {
        int tmp = array[left];
        array[left] = array[right];
        array[right] = tmp;
        ++left;
        --right;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0178" name="idiom: Reverse loop without unsigned underflow traps" kind="idiom">
      <signature>for (size_t i = n; i-- &gt; 0; ) {</signature>
      <summary><![CDATA[<p>This avoids <code>i &gt;= 0</code> (which is always true for <code>size_t</code>) and avoids underflow bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0178.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (size_t i = n; i-- > 0; ) {
    /* uses i = n-1 down to 0 */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0179" name="idiom: Roman numeral conversion (char map + subtractive parse)" kind="idiom">
      <signature>int roman_char_to_int(char ch);</signature>
      <summary><![CDATA[<p>Maps a single Roman numeral character to its integer value.<br>Returns 0 for unsupported characters.</p><p>Converts a Roman numeral string using standard subtractive notation.<br>Returns 0 for NULL or for a string that contributes no valid symbols.</p>]]></summary>
      <examples>
        <example id="ex.id-0179.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

int roman_char_to_int(char ch) {
    switch (ch) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int roman_to_int(const char* s) {
    if (!s) return 0;

    int total = 0;
    int prev = 0;
    int seen = 0;

    for (const char* p = s; *p; ++p) {
        int v = roman_char_to_int(*p);
        if (v == 0) continue;
        seen = 1;
        if (v > prev && prev > 0) {
            total += v - 2 * prev;
        } else {
            total += v;
        }
        prev = v;
    }

    return seen ? total : 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0180" name="idiom: Round floating point number to integer" kind="idiom">
      <signature>int round_to_int(double value) {</signature>
      <summary><![CDATA[<p>Round a floating point value to the nearest integer, with ties rounded upward.</p>]]></summary>
      <notes>
        <note id="note.id-0180.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/81/round-floating-point-number-to-integer">https://programming-idioms.org/idiom/81/round-floating-point-number-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0180.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <math.h>

int round_to_int(double value) {
    return (int)floor(value + 0.5);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0181" name="idiom: Safe memory allocation" kind="idiom">
      <signature>void* xmalloc(size_t size) {</signature>
      <summary><![CDATA[<p>Allocate memory and fail fast if allocation is unsuccessful.</p>]]></summary>
      <notes>
        <note id="note.id-0181.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/88/allocate-1m-bytes">https://programming-idioms.org/idiom/88/allocate-1m-bytes</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0181.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

void* xmalloc(size_t size) {
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0182" name="idiom: Safe string copy with truncation" kind="idiom">
      <signature>void safe_strcpy(char* dst, size_t dst_size, const char* src) {</signature>
      <summary><![CDATA[<p>Copy a string into a fixed buffer while guaranteeing null termination.</p>]]></summary>
      <notes>
        <note id="note.id-0182.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places">https://programming-idioms.org/idiom/23/convert-real-number-to-string-with-2-decimal-places</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0182.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

void safe_strcpy(char* dst, size_t dst_size, const char* src) {
    if (dst_size == 0) {
        return;
    }
    strncpy(dst, src, dst_size - 1);
    dst[dst_size - 1] = '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0183" name="idiom: Seed random generator" kind="idiom">
      <signature>void seed_random(unsigned int seed) {</signature>
      <summary><![CDATA[<p>Initialize the pseudo-random number generator with a fixed seed.</p>]]></summary>
      <notes>
        <note id="note.id-0183.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/69/seed-random-generator">https://programming-idioms.org/idiom/69/seed-random-generator</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0183.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>

void seed_random(unsigned int seed) {
    srand(seed);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0184" name="idiom: Set, clear, and test a bit" kind="idiom">
      <signature>void set_bit(unsigned int* value, unsigned int bit) {</signature>
      <summary><![CDATA[<p>Manipulate individual bits using bit masks.</p>]]></summary>
      <notes>
        <note id="note.id-0184.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation">https://programming-idioms.org/idiom/84/count-bits-set-in-integer-binary-representation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0184.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

void set_bit(unsigned int* value, unsigned int bit) {
    *value |= (1U << bit);
}

void clear_bit(unsigned int* value, unsigned int bit) {
    *value &= ~(1U << bit);
}

bool test_bit(unsigned int value, unsigned int bit) {
    return (value & (1U << bit)) != 0;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0185" name="idiom: Shuffle a list" kind="idiom">
      <signature>void shuffle_ints(int* array, size_t count) {</signature>
      <summary><![CDATA[<p>Randomly permute the elements of an integer array using the Fisher-Yates algorithm.</p>]]></summary>
      <notes>
        <note id="note.id-0185.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/10/shuffle-a-list">https://programming-idioms.org/idiom/10/shuffle-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0185.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

void shuffle_ints(int* array, size_t count) {
    if (count < 2) {
        return;
    }

    for (size_t i = count - 1; i > 0; --i) {
        size_t j = (size_t)(rand() % (i + 1));
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0186" name="idiom: Simple stack using array" kind="idiom">
      <signature>typedef struct {</signature>
      <summary><![CDATA[<p>Implement a fixed-size stack using an array and an index.</p>]]></summary>
      <notes>
        <note id="note.id-0186.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list">https://programming-idioms.org/idiom/161/multiply-all-the-elements-of-a-list</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0186.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>

#define STACK_CAPACITY 32

typedef struct {
    int data[STACK_CAPACITY];
    int top;
} Stack;

void stack_init(Stack* s) {
    s->top = 0;
}

bool stack_push(Stack* s, int value) {
    if (s->top >= STACK_CAPACITY) {
        return false;
    }
    s->data[s->top++] = value;
    return true;
}

bool stack_pop(Stack* s, int* out_value) {
    if (s->top == 0) {
        return false;
    }
    *out_value = s->data[--s->top];
    return true;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0187" name="idiom: Single-exit cleanup with `goto`" kind="idiom">
      <signature>int f(void) {</signature>
      <summary><![CDATA[<p>This scales when you add resources; you do not multiply cleanup code.</p>]]></summary>
      <examples>
        <example id="ex.id-0187.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int f(void) {
    int rc = -1;
    FILE* fp = 0;
    void* buf = 0;

    fp = fopen("x", "rb");
    if (!fp) goto out;

    buf = malloc(4096);
    if (!buf) goto out;

    rc = 0;
out:
    free(buf);
    if (fp) fclose(fp);
    return rc;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0188" name="idiom: Single-header library with implementation macro and feature toggles" kind="idiom">
      <signature>Single-header library with implementation macro and feature toggles</signature>
      <summary><![CDATA[<p>mylib.h - v0.1 - single-header C99 utilities<br>Public Domain or MIT, your choice, see end of file.</p><p>Overview<br>Tiny stb-style header providing small, dependency-free helpers commonly<br>needed in coding challenge style problems (inspired by LeetCode): integer digit routines,<br>bit counting and parity, array reversal, Roman numeral conversion,<br>ASCII decimal parsing, a minimal int vector, and simple date helpers.</p><p>Design<br>- Single-header; include this file everywhere.<br>- In one translation unit: #define MYLIB_IMPLEMENTATION before include.<br>- Optional MYLIB_STATIC makes definitions 'static' in that TU.<br>- Optional MYLIB_NO_STDIO omits printf-based helpers.<br>- No hidden global state. Allocation hooks are provided but optional.</p><p>Build<br>In one source file:<br>#define MYLIB_IMPLEMENTATION<br>#include "mylib.h"<br>In all other files:<br>#include "mylib.h"</p>]]></summary>
      <examples>
        <example id="ex.id-0188.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
/* mylib.h - single-header library */
#ifndef MYLIB_H
#define MYLIB_H

/* Public API declaration */
#ifdef MYLIB_STATIC
#define MYLIB_API static
#else
#define MYLIB_API extern
#endif

MYLIB_API int mylib_add(int a, int b);

/* Implementation */
#ifdef MYLIB_IMPLEMENTATION

MYLIB_API int mylib_add(int a, int b) {
    return a + b;
}

#endif /* MYLIB_IMPLEMENTATION */
#endif /* MYLIB_H */

/* Usage in one .c file: */
/* #define MYLIB_IMPLEMENTATION */
/* #include "mylib.h" */
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0189" name="idiom: Size-in, size-out for buffers (and report required size)" kind="idiom">
      <signature>int encode(char* dst, size_t dst_sz, size_t* out_sz);</signature>
      <summary><![CDATA[<p>On overflow, set <code>*out_sz</code> to the needed size and return an error.</p>]]></summary>
      <examples>
        <example id="ex.id-0189.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int encode(char* dst, size_t dst_sz, size_t* out_sz);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0190" name="idiom: Sort by a comparator (qsort/bsearch)" kind="idiom">
      <signature>int compare_ints(const void* a, const void* b) {</signature>
      <summary><![CDATA[<p>Sort an array of integers using qsort with a custom comparator.</p><p>Sort an array of structures by an integer field using qsort and a comparator.</p><p>Comparison function for int arrays compatible with qsort and bsearch.<br>Returns negative if *a &lt; *b, zero if *a == *b, positive if *a &gt; *b.<br>Avoids overflow by using subtraction comparison idiom.<br>Example: qsort(array, size, sizeof(int), array_int_compare);<br>Complexity: O(1).</p>]]></summary>
      <notes>
        <note id="note.id-0190.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/100/sort-by-a-comparator">https://programming-idioms.org/idiom/100/sort-by-a-comparator</a></p>]]></description>
        </note>
        <note id="note.id-0190.2" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/28/sort-by-a-property">https://programming-idioms.org/idiom/28/sort-by-a-property</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0190.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

int compare_ints(const void* a, const void* b) {
    int x = *(const int*)a;
    int y = *(const int*)b;

    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
}

void sort_ints(int* values, size_t count) {
    qsort(values, count, sizeof(int), compare_ints);
}
]]></code>
        </example>
        <example id="ex.id-0190.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
#include <stdlib.h>

typedef struct {
    int priority;
} Item;

int compare_item_priority(const void* a, const void* b) {
    const Item* ia = (const Item*)a;
    const Item* ib = (const Item*)b;

    if (ia->priority < ib->priority) {
        return -1;
    }
    if (ia->priority > ib->priority) {
        return 1;
    }
    return 0;
}

void sort_items(Item* items, size_t count) {
    qsort(items, count, sizeof(Item), compare_item_priority);
}
]]></code>
        </example>
        <example id="ex.id-0190.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
#include <stddef.h>

int array_int_compare(const void* a, const void* b) {
    int x = *(const int*)a;
    int y = *(const int*)b;
    return (x > y) - (x < y);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0191" name="idiom: Source code inclusion" kind="idiom">
      <signature>void foo(void) {</signature>
      <summary><![CDATA[<p>Include source code from another file directly into a function body.</p>]]></summary>
      <notes>
        <note id="note.id-0191.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/127/source-code-inclusion">https://programming-idioms.org/idiom/127/source-code-inclusion</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0191.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void foo(void) {
#include "foobody.txt"

}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0192" name="idiom: Sparse array initialization with designated indices" kind="idiom">
      <signature>int map[256] = { [0 ... 255] = -1, [&apos;A&apos;] = 0, [&apos;B&apos;] = 1 };</signature>
      <summary><![CDATA[<p>Range designators (<code>[0 ... 255]</code>) are a GCC/Clang extension, not C99. The strictly C99 part is designated indices like <code>['A']</code>. If you need strict portability, stick to explicit indices.</p>]]></summary>
      <examples>
        <example id="ex.id-0192.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int map[256] = { [0 ... 255] = -1, ['A'] = 0, ['B'] = 1 };
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0193" name="idiom: Split a space-separated string" kind="idiom">
      <signature>size_t split_spaces(char* s, char** tokens, size_t max_tokens) {</signature>
      <summary><![CDATA[<p>Split a mutable string into space-separated tokens using the standard C tokenizer.</p>]]></summary>
      <notes>
        <note id="note.id-0193.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/49/split-a-space-separated-string">https://programming-idioms.org/idiom/49/split-a-space-separated-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0193.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>
#include <stddef.h>

size_t split_spaces(char* s, char** tokens, size_t max_tokens) {
    size_t count = 0;
    char* token = strtok(s, " ");

    while (token && count < max_tokens) {
        tokens[count++] = token;
        token = strtok(NULL, " ");
    }
    return count;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0194" name="idiom: Strict aliasing safe type-punning: use `memcpy`, not pointer casts" kind="idiom">
      <signature>float f;</signature>
      <summary><![CDATA[<p>Pointer-cast punning can break under optimization; <code>memcpy</code> is the portable way.</p>]]></summary>
      <examples>
        <example id="ex.id-0194.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
float f;
uint32_t u;
memcpy(&u, &f, sizeof u);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0195" name="idiom: String interpolation" kind="idiom">
      <signature>void format_planets(int count, char* buffer, size_t buffer_size) {</signature>
      <summary><![CDATA[<p>Format a string by inserting an integer value into a text template.</p>]]></summary>
      <notes>
        <note id="note.id-0195.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/302/string-interpolation">https://programming-idioms.org/idiom/302/string-interpolation</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0195.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

void format_planets(int count, char* buffer, size_t buffer_size) {
    snprintf(buffer, buffer_size, "Our sun has %d planets", count);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0196" name="idiom: Stringize and concatenate for generating names and messages" kind="idiom">
      <signature>int CAT(tmp_, __LINE__);</signature>
      <summary><![CDATA[<p>These are building blocks for debugging macros and generated identifiers.</p>]]></summary>
      <examples>
        <example id="ex.id-0196.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define STR_(x) #x
#define STR(x) STR_(x)

#define CAT_(a,b) a##b
#define CAT(a,b) CAT_(a,b)

int CAT(tmp_, __LINE__);
const char* msg = "line " STR(__LINE__);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0197" name="idiom: Successive conditions" kind="idiom">
      <signature>void dispatch(int c1, int c2, int c3) {</signature>
      <summary><![CDATA[<p>Execute the first matching branch among several mutually exclusive conditions.</p>]]></summary>
      <notes>
        <note id="note.id-0197.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/131/successive-conditions">https://programming-idioms.org/idiom/131/successive-conditions</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0197.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void dispatch(int c1, int c2, int c3) {
    if (c1) {
        f1();
    } else if (c2) {
        f2();
    } else if (c3) {
        f3();
    }
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0198" name="idiom: Sum digits in array" kind="idiom">
      <signature>unsigned char digits_sum(const unsigned char* digits,</signature>
      <summary><![CDATA[<p>Sums the decimal digits in digits[0..digits_size).<br>Returns 0 if digits is NULL or digits_size is 0.</p>]]></summary>
      <examples>
        <example id="ex.id-0198.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[

#include <stddef.h>

unsigned char digits_sum(const unsigned char* digits, size_t digits_size) {
    if (!digits || digits_size == 0) return 0;

    unsigned sum = 0;
    for (size_t i = 0; i < digits_size; ++i) {
        sum += digits[i];
    }
    return (unsigned char)sum;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0199" name="idiom: Swap values via temporary" kind="idiom">
      <signature>void swap_ints(int* a, int* b) {</signature>
      <summary><![CDATA[<p>Swap the values of two integers using a temporary variable.</p><p>Swaps two 32-bit unsigned integers pointed to by a and b.<br>No-op if either pointer is NULL.</p><p>The macro version above uses <code>__typeof__</code>, which is a GNU extension, not C99. In strict C99, you typically hand-write swaps or use a function specialized per type.</p>]]></summary>
      <notes>
        <note id="note.id-0199.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/21/swap-values">https://programming-idioms.org/idiom/21/swap-values</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0199.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
void swap_ints(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
]]></code>
        </example>
        <example id="ex.id-0199.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
 void util_swap_u32(uint32_t* a, uint32_t* b);
]]></code>
        </example>
        <example id="ex.id-0199.3" lang="c99">
          <title>Example 3</title>
          <code><![CDATA[
#define SWAP(a,b) do { __typeof__(a) _t = (a); (a) = (b); (b) = _t; } while (0)
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0200" name="idiom: Switch-driven state machine with intentional fallthrough" kind="idiom">
      <signature>switch (state) {</signature>
      <summary><![CDATA[<p>The convenience is real, but comment intentional fallthrough because compilers warn and humans misread.</p>]]></summary>
      <examples>
        <example id="ex.id-0200.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
switch (state) {
case S_START:
    /* ... */
    state = S_BODY;
    /* fall through */
case S_BODY:
    /* ... */
    break;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0201" name="idiom: Test if string is empty" kind="idiom">
      <signature>bool is_empty(const char* s) {</signature>
      <summary><![CDATA[<p>Check whether a string has zero length.</p>]]></summary>
      <notes>
        <note id="note.id-0201.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/320/test-if-string-is-empty">https://programming-idioms.org/idiom/320/test-if-string-is-empty</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0201.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <string.h>

bool is_empty(const char* s) {
    return s[0] == '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0202" name="idiom: The canonical &quot;walk a C string&quot; pointer loop" kind="idiom">
      <signature>for (const unsigned char* p = (const unsigned char*)s; *p; ++p) {</signature>
      <summary><![CDATA[<p>Using <code>unsigned char</code> avoids undefined behavior with the ctype family when chars are negative.</p>]]></summary>
      <examples>
        <example id="ex.id-0202.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (const unsigned char* p = (const unsigned char*)s; *p; ++p) {
    /* ... */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0203" name="idiom: The comma operator for tight loops (use sparingly)" kind="idiom">
      <signature>for (i = 0, p = a; i &lt; n; ++i, ++p) { /* ... */ }</signature>
      <summary><![CDATA[<p>It is idiomatic in C, but readability drops if you overpack logic into the header.</p>]]></summary>
      <examples>
        <example id="ex.id-0203.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (i = 0, p = a; i < n; ++i, ++p) { /* ... */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0204" name="idiom: The do-while(0) macro wrapper so statements behave like statements" kind="idiom">
      <signature>The do-while(0) macro wrapper so statements behave like statements</signature>
      <summary><![CDATA[<p>This prevents surprises with <code>if (cond) CHECK(...); else ...</code>.</p>]]></summary>
      <examples>
        <example id="ex.id-0204.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define CHECK(x) do { if (!(x)) return -1; } while (0)
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0205" name="idiom: Tokenize without `strtok` by using `strcspn` and manual slicing" kind="idiom">
      <signature>for (char* p = s; *p; ) {</signature>
      <summary><![CDATA[<p>No global state, re-entrant, and it works with custom delimiters.</p>]]></summary>
      <examples>
        <example id="ex.id-0205.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
for (char* p = s; *p; ) {
    p += strspn(p, " \t");
    size_t len = strcspn(p, " \t");
    if (len == 0) break;
    /* token is p..p+len */
    p += len;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0206" name="idiom: Trim prefix" kind="idiom">
      <signature>const char* trim_prefix(const char* s, const char* prefix) {</signature>
      <summary><![CDATA[<p>Remove a prefix from a string if it is present.</p>]]></summary>
      <notes>
        <note id="note.id-0206.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/167/trim-prefix">https://programming-idioms.org/idiom/167/trim-prefix</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0206.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <string.h>

const char* trim_prefix(const char* s, const char* prefix) {
    size_t len = strlen(prefix);
    return strncmp(s, prefix, len) == 0 ? s + len : s;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0207" name="idiom: Trim whitespace in place (two pointers)" kind="idiom">
      <signature>char* trim_whitespace(char* s) {</signature>
      <summary><![CDATA[<p>Remove leading and trailing ASCII whitespace from a mutable string.</p><p>This is a reusable skeleton for whitespace trimming without allocating.</p>]]></summary>
      <notes>
        <note id="note.id-0207.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/110/check-if-string-is-blank">https://programming-idioms.org/idiom/110/check-if-string-is-blank</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0207.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <ctype.h>
#include <string.h>

char* trim_whitespace(char* s) {
    while (isspace((unsigned char) * s)) {
        ++s;
    }

    char* end = s + strlen(s);
    while (end > s && isspace((unsigned char) * (end - 1))) {
        --end;
    }
    *end = '\0';
    return s;
}
]]></code>
        </example>
        <example id="ex.id-0207.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
char* p = s;
while (*p == ' ' || *p == '\t') ++p;

char* e = p + strlen(p);
while (e > p && (e[-1] == ' ' || e[-1] == '\t' || e[-1] == '\n')) --e;
*e = '\0';

if (p != s) memmove(s, p, (size_t)(e - p) + 1);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0208" name="idiom: Truncate floating point number to integer" kind="idiom">
      <signature>int truncate_to_int(double value) {</signature>
      <summary><![CDATA[<p>Convert a floating point value to an integer by truncating toward zero.</p>]]></summary>
      <notes>
        <note id="note.id-0208.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/80/truncate-floating-point-number-to-integer">https://programming-idioms.org/idiom/80/truncate-floating-point-number-to-integer</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0208.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int truncate_to_int(double value) {
    return (int)value;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0209" name="idiom: Turn a character into a string" kind="idiom">
      <signature>void char_to_string(char c, char* buffer) {</signature>
      <summary><![CDATA[<p>Create a null-terminated string containing a single character.</p>]]></summary>
      <notes>
        <note id="note.id-0209.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/152/turn-a-character-into-a-string">https://programming-idioms.org/idiom/152/turn-a-character-into-a-string</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0209.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void char_to_string(char c, char* buffer) {
    buffer[0] = c;
    buffer[1] = '\0';
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0210" name="idiom: Use `__FILE__` and `__LINE__` for trace points" kind="idiom">
      <signature>fprintf(stderr, &quot;%s:%d: failed\n&quot;, __FILE__, __LINE__);</signature>
      <summary><![CDATA[<p>This is a low-tech, high-value breadcrumb.</p>]]></summary>
      <examples>
        <example id="ex.id-0210.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
fprintf(stderr, "%s:%d: failed\n", __FILE__, __LINE__);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0211" name="idiom: Use `const` to document and enforce read-only inputs" kind="idiom">
      <signature>int hash(const void* data, size_t n, uint32_t* out);</signature>
      <summary><![CDATA[<p>This eliminates entire classes of accidental mutation bugs.</p>]]></summary>
      <examples>
        <example id="ex.id-0211.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int hash(const void* data, size_t n, uint32_t* out);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0212" name="idiom: Use `restrict` (C99) when you can prove non-aliasing" kind="idiom">
      <signature>void saxpy(float* restrict y, const float* restrict x, size_t n, float a);</signature>
      <summary><![CDATA[<p>It can unlock optimizations and documents a strong contract.</p>]]></summary>
      <examples>
        <example id="ex.id-0212.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
void saxpy(float* restrict y, const float* restrict x, size_t n, float a);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0213" name="idiom: Use `sizeof (type){0}` to get a type size without naming an object" kind="idiom">
      <signature>size_t n = sizeof (struct Header){0};</signature>
      <summary><![CDATA[<p>This is occasionally useful in macros and generic helpers where you do not want an actual variable.</p>]]></summary>
      <examples>
        <example id="ex.id-0213.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
size_t n = sizeof (struct Header){0};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0214" name="idiom: Use clock as random generator seed" kind="idiom">
      <signature>void seed_random_with_time(void) {</signature>
      <summary><![CDATA[<p>Seed the pseudo-random number generator using the current system time.</p>]]></summary>
      <notes>
        <note id="note.id-0214.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/70/use-clock-as-random-generator-seed">https://programming-idioms.org/idiom/70/use-clock-as-random-generator-seed</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0214.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdlib.h>
#include <time.h>

void seed_random_with_time(void) {
    srand((unsigned int)time(NULL));
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0215" name="idiom: Use scansets in `sscanf` when you really do want it (bounded)" kind="idiom">
      <signature>char key[32];</signature>
      <summary><![CDATA[<p>The width prevents buffer overflow; the scanset is a powerful but underused feature.</p>]]></summary>
      <examples>
        <example id="ex.id-0215.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
char key[32];
if (sscanf(line, "%31[^=]=%*s", key) == 1) { /* key before '=' */ }
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0216" name="idiom: Write to standard error stream" kind="idiom">
      <signature>void report_negative(int x) {</signature>
      <summary><![CDATA[<p>Print a formatted message to the standard error stream.</p>]]></summary>
      <notes>
        <note id="note.id-0216.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/59/write-to-standard-error-stream">https://programming-idioms.org/idiom/59/write-to-standard-error-stream</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0216.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdio.h>

void report_negative(int x) {
    fprintf(stderr, "%d is negative\n", x);
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0217" name="idiom: X-macro tables: one list, many derived artifacts" kind="idiom">
      <signature>X(RED) \</signature>
      <summary><![CDATA[<p>This avoids keeping enum, strings, and other metadata in sync by hand.</p>]]></summary>
      <examples>
        <example id="ex.id-0217.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
/* list */
#define COLORS(X) \
    X(RED)        \
    X(GREEN)      \
    X(BLUE)

/* enum */
#define X(name) name,
enum Color { COLORS(X) };
#undef X

/* to-string */
#define X(name) case name: return #name;
const char* color_name(enum Color c) {
    switch (c) { COLORS(X) default: return "?"; }
}
#undef X
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0218" name="idiom: Xor integers" kind="idiom">
      <signature>int xor_ints(int a, int b) {</signature>
      <summary><![CDATA[<p>Compute the bitwise exclusive OR of two integers.</p>]]></summary>
      <notes>
        <note id="note.id-0218.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/237/xor-integers">https://programming-idioms.org/idiom/237/xor-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0218.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int xor_ints(int a, int b) {
    return a ^ b;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0219" name="idiom: Zero-initialize heap allocation with calloc" kind="idiom">
      <signature>int* create_zeroed_ints(size_t count) {</signature>
      <summary><![CDATA[<p>Allocate an integer array initialized with zeros.</p><p>It communicates "I want zeroed memory" and can be optimized by the runtime.</p>]]></summary>
      <notes>
        <note id="note.id-0219.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://programming-idioms.org/idiom/284/create-a-zeroed-list-of-integers">https://programming-idioms.org/idiom/284/create-a-zeroed-list-of-integers</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0219.1" lang="c99">
          <title>Example 1</title>
          <code><![CDATA[
#include <stdlib.h>

int* create_zeroed_ints(size_t count) {
    return (int*)calloc(count, sizeof(int));
}
]]></code>
        </example>
        <example id="ex.id-0219.2" lang="c99">
          <title>Example 2</title>
          <code><![CDATA[
T *p = calloc(count, sizeof *p);
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0220" name="idiom: Zero-initialize scalars and aggregates with `{0}` (and know what it really does)" kind="idiom">
      <signature>int x = 0;</signature>
      <summary><![CDATA[<p>For objects with static storage duration, zero-init happens anyway; for locals, <code>{0}</code> forces a full zero fill by the rules for aggregate initialization. It is concise and hard to get wrong.</p>]]></summary>
      <examples>
        <example id="ex.id-0220.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
int x = 0;
int a[10] = {0};
struct S s = {0};
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0221" name="idiom: Generic tuple types using macros" kind="idiom">
      <signature>#define Tuple2(T1, T2)</signature>
      <summary><![CDATA[<p>Create lightweight tuple types for returning multiple values from functions without needing explicit semantic names. C23 standardizes that tagged types with the same name and contents are compatible. Note: Breaks with pointer types due to preprocessor token pasting limitations.</p>]]></summary>
      <notes>
        <note id="note.id-0221.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://www.unix.dog/~yosh/blog/c-habits-for-me.html">https://www.unix.dog/~yosh/blog/c-habits-for-me.html</a></p>]]></description>
        </note>
        <note id="note.id-0221.2" severity="warning" topic="limitation">
          <description><![CDATA[<p>Does not work with pointer types (e.g., <code>char*</code>) due to token pasting issues. Use typedef or explicit struct name as workaround.</p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0221.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#define Tuple2(T1, T2)           \
    struct Tuple2_##T1##_##T2 {  \
        T1 a;                    \
        T2 b;                    \
    }

/* Usage example */
Tuple2(int, int) find_min_max(const int* array, size_t count) {
    Tuple2(int, int) result = {array[0], array[0]};
    for (size_t i = 1; i < count; i++) {
        if (array[i] < result.a) result.a = array[i];
        if (array[i] > result.b) result.b = array[i];
    }
    return result;
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0222" name="idiom: Result/Maybe types for error handling" kind="idiom">
      <signature>typedef struct MaybeBuffer {</signature>
      <summary><![CDATA[<p>Simulate sum types using tagged unions for explicit error handling. The <code>ok</code> field acts as a discriminant, and callers must check it before accessing the value. This pattern encodes success/failure in the type system and pairs well with "parse, don't validate" approach.</p>]]></summary>
      <notes>
        <note id="note.id-0222.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://www.unix.dog/~yosh/blog/c-habits-for-me.html">https://www.unix.dog/~yosh/blog/c-habits-for-me.html</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0222.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <stddef.h>

typedef enum {
    ERR_NULL_INPUT,
    ERR_INVALID_SIZE,
    ERR_ALLOCATION_FAILED
} ErrorCode;

typedef struct {
    char *data;
    size_t size;
} SafeBuffer;

typedef struct {
    bool ok;
    union {
        SafeBuffer val;
        ErrorCode err;
    };
} MaybeBuffer;

/* Parsing function that returns result type */
MaybeBuffer parse_buffer(const char* input, size_t len) {
    MaybeBuffer result;

    if (!input) {
        result.ok = false;
        result.err = ERR_NULL_INPUT;
        return result;
    }

    if (len == 0) {
        result.ok = false;
        result.err = ERR_INVALID_SIZE;
        return result;
    }

    /* Parse and validate... */
    result.ok = true;
    result.val.data = (char*)input;
    result.val.size = len;
    return result;
}

/* Usage: caller must check ok */
void process_data(const char* input, size_t len) {
    MaybeBuffer buf = parse_buffer(input, len);
    if (!buf.ok) {
        /* Handle error: buf.err contains the error code */
        return;
    }

    /* Safe to use: buf.val contains validated data */
    SafeBuffer validated = buf.val;
    /* Work with validated.data knowing invariants hold */
}
]]></code>
        </example>
      </examples>
    </function>

    <function id="fn.idiom.id-0223" name="idiom: Safe wrapper types encoding invariants" kind="idiom">
      <signature>typedef struct SafeBuffer {</signature>
      <summary><![CDATA[<p>Create wrapper types that can only be constructed through validation functions, encoding invariants in the type system itself. Once created, these types guarantee that their data has been validated and specific properties hold. Implements "parse, don't validate" philosophy.</p>]]></summary>
      <notes>
        <note id="note.id-0223.1" severity="info" topic="source">
          <description><![CDATA[<p>Source: <a href="https://www.unix.dog/~yosh/blog/c-habits-for-me.html">https://www.unix.dog/~yosh/blog/c-habits-for-me.html</a></p>]]></description>
        </note>
      </notes>
      <examples>
        <example id="ex.id-0223.1" lang="c99">
          <title>Example</title>
          <code><![CDATA[
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

/* Safe wrapper type - can only be created through validated_buffer_create */
typedef struct {
    char *data;
    size_t len;
} ValidatedBuffer;

typedef struct {
    bool ok;
    union {
        ValidatedBuffer val;
        int err_code;
    };
} MaybeValidatedBuffer;

/* Constructor that enforces invariants */
MaybeValidatedBuffer validated_buffer_create(const char* input, size_t len) {
    MaybeValidatedBuffer result;

    /* Validation: non-NULL, non-empty, null-terminated */
    if (!input || len == 0 || input[len - 1] != '\0') {
        result.ok = false;
        result.err_code = -1;
        return result;
    }

    /* Additional validation: check for invalid characters, etc. */
    for (size_t i = 0; i < len - 1; i++) {
        if (input[i] < 32 && input[i] != '\t' && input[i] != '\n') {
            result.ok = false;
            result.err_code = -2;
            return result;
        }
    }

    result.ok = true;
    result.val.data = (char*)input;
    result.val.len = len;
    return result;
}

/* Functions accepting ValidatedBuffer know invariants hold */
void process_validated(ValidatedBuffer buf) {
    /* No need to re-check: we know buf.data is non-NULL,
     * null-terminated, and contains only valid characters */
    printf("Processing %zu bytes: %s\n", buf.len, buf.data);
}

void example_usage(void) {
    const char* input = "Hello, world!\0";
    MaybeValidatedBuffer maybe = validated_buffer_create(input, strlen(input) + 1);

    if (!maybe.ok) {
        printf("Validation failed: %d\n", maybe.err_code);
        return;
    }

    /* Type system guarantees this is safe */
    process_validated(maybe.val);
}
]]></code>
        </example>
      </examples>
    </function>
    </header>
  </category>
</document>
</script>
  </section>

  <script src="app.js"></script>
  <script src="lib-asvd-microlight-0.0.7/microlight.js"></script>
</body>

</html>