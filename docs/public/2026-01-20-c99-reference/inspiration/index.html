<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C99: modern C for systems that have to work</title>
  <link rel="canonical" href="https://c99.awwtools.com/">
  <link rel="stylesheet" href="styles.css">
  <script src="app.js" defer></script>
</head>
<body data-theme="auto">
  <header class="site-header" id="top">
    <div class="brand">
      <span class="logo">C99</span>
      <span class="tagline">Modern C for production systems</span>
    </div>
    <nav aria-label="Primary">
      <button class="nav-toggle" aria-expanded="false" aria-controls="nav-list">
        <span class="sr-only">Toggle navigation</span>
        <span></span>
        <span></span>
      </button>
      <ul id="nav-list" class="nav-list">
        <li><a href="#why-c99">Why</a></li>
        <li><a href="#features">Features</a></li>
        <li><a href="#code">Code</a></li>
        <li><a href="#proven">Proven</a></li>
        <li><a href="#use-cases">Use cases</a></li>
        <li><a href="#faq">FAQ</a></li>
      </ul>
    </nav>
    <button class="theme-toggle" aria-label="Toggle color mode">
      <span class="theme-icon" aria-hidden="true">◐</span>
      <span class="sr-only">Toggle dark or light theme</span>
    </button>
  </header>

  <main>
    <section class="hero" aria-labelledby="hero-title">
      <div class="hero-content">
        <p class="eyebrow">ISO/IEC 9899:1999</p>
        <h1 id="hero-title">C99: modern C for systems that have to work.</h1>
        <p class="lede">Ship software with predictable performance, tight control over memory, and a stable standard. C99 adds practical language improvements without turning C into something else.</p>
        <div class="cta-row">
          <a class="btn primary" href="#cta">Read the C99 quickstart</a>
          <a class="btn ghost" href="#code">See C99 code</a>
        </div>
        <p class="trust-line">C99 is ISO/IEC 9899:1999, a widely implemented revision of the C standard.</p>
      </div>
      <div class="hero-visual" aria-hidden="true">
        <img src="assets/grid.svg" alt="" loading="lazy">
        <div class="orbital">
          <span class="dot dot-a"></span>
          <span class="dot dot-b"></span>
          <span class="dot dot-c"></span>
        </div>
      </div>
    </section>

    <section id="why-c99" class="panel">
      <div class="section-header">
        <h2>Why C99 still wins</h2>
        <p>When latency budgets matter and memory is not negotiable, C remains the language you reach for. C99 keeps the core model intact while standardizing quality-of-life improvements that make real codebases cleaner.</p>
        <p>C99 is designed for portability and efficient execution across a wide variety of systems, from tiny embedded targets to high-throughput servers.</p>
      </div>
      <div class="card-grid">
        <article class="card">
          <h3>Predictable performance</h3>
          <p>Direct control over layout, allocation, and data representation. You decide what happens on the hot path, and the compiler stays honest.</p>
        </article>
        <article class="card">
          <h3>Portable, standardized power</h3>
          <p>C99 is a formal standard with a defined library surface area. Your code travels well across compilers and operating systems.</p>
        </article>
        <article class="card">
          <h3>Interoperability by default</h3>
          <p>C is the common ABI denominator. Calling into other languages, embedding runtimes, and building libraries stays straightforward.</p>
        </article>
      </div>
    </section>

    <section id="features" class="panel">
      <div class="section-header">
        <h2>C99 features you will actually use</h2>
        <p>C99 adds pragmatic language features and library headers that reduce boilerplate and improve clarity while staying close to the machine.</p>
      </div>
      <div class="feature-table" role="table" aria-label="C99 feature highlights">
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell">Designated initializers</div>
          <div class="feature-why" role="cell">Initialize structs and arrays by name or index for safer, clearer code.</div>
        </div>
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell">Compound literals</div>
          <div class="feature-why" role="cell">Create initialized temporary objects without extra declarations.</div>
        </div>
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell">Mix declarations with statements</div>
          <div class="feature-why" role="cell">Keep variables near usage, reduce scope, improve readability.</div>
        </div>
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell"><code>stdint.h</code> and <code>inttypes.h</code></div>
          <div class="feature-why" role="cell">Write portable fixed-width integer code and formatting.</div>
        </div>
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell"><code>inline</code>, <code>restrict</code>, and improved numeric support</div>
          <div class="feature-why" role="cell">Express intent to the compiler for performance and correctness-oriented optimization.</div>
        </div>
        <div class="feature-row" role="row">
          <div class="feature-name" role="cell">VLAs and flexible array members (use intentionally)</div>
          <div class="feature-why" role="cell">Model runtime-sized data when the target and toolchain support it.</div>
        </div>
      </div>
    </section>

    <section id="code" class="panel">
      <div class="section-header">
        <h2>Code that stays small, fast, and readable</h2>
        <p>These examples demonstrate common C99 patterns used in production code. They are short on purpose: the goal is clarity, not cleverness.</p>
      </div>
      <div class="code-grid">
        <figure class="code-card">
          <figcaption>Designated initializer for safer config objects</figcaption>
          <pre><code class="language-c">#include &lt;stdio.h&gt;

struct server_config {
    const char *host;
    int port;
    int max_clients;
};

int main(void) {
    struct server_config cfg = {
        .host = "127.0.0.1",
        .port = 8080,
        .max_clients = 128
    };

    printf("%s:%d (%d max)\\n", cfg.host, cfg.port, cfg.max_clients);
    return 0;
}</code></pre>
          <p class="code-caption">Why this matters: naming fields during initialization guards against ordering mistakes and keeps intent obvious.</p>
          <button class="copy-btn" type="button">Copy</button>
        </figure>
        <figure class="code-card">
          <figcaption>Compound literal to pass structured data without ceremony</figcaption>
          <pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct point { double x, y, z; };

double *store_point(const struct point *p) {
    double *buf = malloc(3 * sizeof(double));
    if (!buf) return NULL;
    memcpy(buf, p, 3 * sizeof(double));
    return buf;
}

int main(void) {
    double *packed = store_point(&(struct point){ .x = 1.0, .y = 0.5, .z = -0.25 });
    free(packed);
    return 0;
}</code></pre>
          <p class="code-caption">Why this matters: compound literals keep temporaries localized and reduce boilerplate in allocation-heavy paths.</p>
          <button class="copy-btn" type="button">Copy</button>
        </figure>
        <figure class="code-card">
          <figcaption>Portable integer types with <code>stdint.h</code></figcaption>
          <pre><code class="language-c">#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;

uint32_t checksum(const uint8_t *data, size_t len) {
    uint32_t sum = 0;
    for (size_t i = 0; i &lt; len; i++) {
        sum += data[i];
    }
    return sum;
}

int main(void) {
    uint8_t payload[] = { 0x01, 0x02, 0x03, 0xFF };
    printf("sum: %" PRIu32 "\\n", checksum(payload, sizeof payload));
    return 0;
}</code></pre>
          <p class="code-caption">Why this matters: fixed-width types and format macros make portable IO straightforward across compilers and targets.</p>
          <button class="copy-btn" type="button">Copy</button>
        </figure>
      </div>
      <div class="toast" role="status" aria-live="polite"></div>
    </section>

    <section id="proven" class="panel">
      <div class="section-header">
        <h2>Proven in widely used infrastructure</h2>
        <p class="disclaimer">Examples below are factual references to implementation languages or documented requirements, not endorsements.</p>
      </div>
      <div class="card-grid">
        <article class="card fact">
          <h3>SQLite</h3>
          <p>SQLite describes itself as a C-language library implementing an embedded SQL database engine, and states it is the most used database engine in the world.</p>
        </article>
        <article class="card fact">
          <h3>Redis</h3>
          <p>Redis states it is written in ANSI C and targets POSIX systems without external dependencies.</p>
        </article>
        <article class="card fact">
          <h3>Git</h3>
          <p>Git documentation notes that, as of Git v2.35.0, Git requires C99 (checked via <code>__STDC_VERSION__</code>).</p>
        </article>
        <article class="card fact">
          <h3>nginx</h3>
          <p>nginx is widely deployed as a web server and reverse proxy; public references list its primary implementation language as C.</p>
        </article>
      </div>
    </section>

    <section id="use-cases" class="panel">
      <div class="section-header">
        <h2>Where C99 shines</h2>
      </div>
      <div class="tiles">
        <article class="tile">
          <h3>Embedded and firmware</h3>
          <p>Tight memory budgets, deterministic execution, and direct register-level access.</p>
        </article>
        <article class="tile">
          <h3>Networking and servers</h3>
          <p>High throughput, low latency, and explicit control over allocation and data layout.</p>
        </article>
        <article class="tile">
          <h3>Databases and storage engines</h3>
          <p>Cache-aware data structures and predictable IO paths.</p>
        </article>
        <article class="tile">
          <h3>Language runtimes and tooling</h3>
          <p>Build fast parsers, interpreters, and extensions with a stable C interface.</p>
        </article>
      </div>
    </section>

    <section id="faq" class="panel">
      <div class="section-header">
        <h2>FAQ</h2>
      </div>
      <div class="faq-grid">
        <article class="faq-item">
          <h3>What exactly is C99?</h3>
          <p>C99 refers to ISO/IEC 9899:1999, a revision of the ISO C standard published in 1999. It extends the prior C90-era standard with language and library additions while remaining largely backward compatible.</p>
        </article>
        <article class="faq-item">
          <h3>Is C99 supported by modern compilers?</h3>
          <p>Most modern toolchains implement the majority of C99; some features have varying support levels depending on the compiler and target. If you need maximum portability, treat a few features (for example, VLAs) as optional and gate them behind build checks.</p>
        </article>
        <article class="faq-item">
          <h3>Will this lock me out of newer standards like C11 or C17?</h3>
          <p>No. Many codebases choose a baseline standard for portability, then selectively adopt newer features when toolchains and targets allow.</p>
        </article>
        <article class="faq-item">
          <h3>How do I detect C99 in code?</h3>
          <p>C99 introduced a standard macro <code>__STDC_VERSION__</code> value of at least <code>199901L</code> for C99 support, which some projects use in their build and coding guidelines.</p>
        </article>
      </div>
    </section>

    <section id="cta" class="panel final-cta">
      <div class="section-header">
        <h2>Adopt a standard that respects the hardware.</h2>
        <p>Use C99 as a clean baseline for portable systems code. Keep your dependencies lean, your binaries small, and your performance predictable.</p>
      </div>
      <div class="cta-row">
        <a class="btn primary" href="#why-c99">Open the quickstart</a>
        <a class="btn ghost" href="#code">Browse examples</a>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="footer-meta">
      <p>C99 (ISO/IEC 9899:1999) — content for informational purposes. Check compilers and targets for feature support before shipping.</p>
      <p>Made for engineers who care about predictable performance and portability.</p>
    </div>
    <div class="ledger">
      <h3>Fact-check ledger</h3>
      <ul>
        <li><strong>H00.2:</strong> dii.uchile.cl ISO/IEC 9899:1999(E); open-std.org n2310; cppreference.com — retrieved 2025-02-15.</li>
        <li><strong>H00.4:</strong> cppreference.com feature pages and compound literal reference — retrieved 2025-02-15.</li>
        <li><strong>H00.6:</strong> sqlite.org; redis.io; git-scm.com Coding Guidelines; nginx.org — retrieved 2025-02-15.</li>
        <li><strong>H00.8:</strong> cppreference.com compiler support; wikipedia.org/C99 — retrieved 2025-02-15.</li>
      </ul>
    </div>
  </footer>
</body>
</html>
