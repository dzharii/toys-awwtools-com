<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>C99 Library Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="topbar">
    <button id="sidebarToggle" type="button" aria-controls="sidebar">Contents</button>
    <div class="topbar-title">C99 Library Reference</div>
  </div>

  <div class="app">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>C99 Library Reference</h1>
        <p>Offline, single-page C99 standard library notes with copy-ready examples.</p>
      </div>
      <div class="search">
        <label for="searchInput">Search</label>
        <input id="searchInput" type="search" placeholder="Function, header, keyword, or parameter" autocomplete="off">
        <div class="search-hint" id="searchHint">Showing full table of contents.</div>
      </div>
      <nav class="toc" id="toc"></nav>
    </aside>

    <main class="content" aria-live="polite">
      <section id="errors" class="error-banner" hidden></section>
      <div id="content"></div>
      <section id="projectInfo" class="info-block">
        <h2>About this page</h2>
        <p>
          I built this C99 reference as a single-page, offline-first cheat sheet I can keep open while I code. The goal
          is fast lookup of signatures, parameter rules, return behavior, and safe usage patterns, without tab switching
          and without hiding content that breaks browser search.
        </p>
        <p>
          The content on this page started as structured XML documents generated with AI assistance. I iterated on the
          structure and wording until each entry had deterministic rules, clear constraints, and copy-pasteable examples.
          The XML is embedded directly into this HTML file, and a small vanilla JavaScript renderer parses it, builds a
          navigation index, and renders everything in a consistent layout.
        </p>
        <p>
          AI tools used: I used ChatGPT (GPT-5.2 Thinking) to design the XML structure and draft the documentation
          content. I used OpenAI Codex to implement the page itself (HTML, CSS, and vanilla JavaScript) and to integrate
          the embedded XML into the final single-page reference.
        </p>
        <p>
          Code blocks are highlighted with microlight.js (ASVD, microlight 0.0.7), a tiny client-side syntax highlighter
          used to improve code readability without external dependencies. The microlight library is bundled locally with
          this project so the page works fully offline.
        </p>
        <p class="info-created">Created: 2026-01-20.</p>
      </section>
    </main>
  </div>

  <div id="sidebarBackdrop" aria-hidden="true"></div>

  <section id="data" hidden>
    <!-- XML blocks are embedded verbatim for offline parsing. -->
    <!-- No XML block contains a </script> sequence, so no splitting is required. -->
<script id="library-xml-2026-01-20T16-11-47-9fed4cbe-6012-4482-8d7d-c497a86a6364" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="text.classification.case_mapping" name="Text classification and case mapping">
    <summary><![CDATA[
<p>
Character classification and case mapping for bytes and wide characters. These APIs are the standard, portable way
to test whether a character is a digit/letter/space/punctuation and to convert case.
</p>
<p>
Use these functions to write parsers, tokenizers, input validators, and normalization steps (for example, case-folding
a command or identifier). For safety and portability, always respect the required input domains (for example,
cast byte input to <code>unsigned char</code> before calling <code>ctype.h</code> functions), and remember that results
may depend on the active locale (typically <code>LC_CTYPE</code>).
</p>
]]></summary>

    <keywords>
      <kw>ctype</kw>
      <kw>wctype</kw>
      <kw>classification</kw>
      <kw>case mapping</kw>
      <kw>locale</kw>
      <kw>LC_CTYPE</kw>
      <kw>unsigned char</kw>
      <kw>EOF</kw>
      <kw>wint_t</kw>
      <kw>WEOF</kw>
      <kw>Unicode</kw>
      <kw>parsing</kw>
      <kw>tokenizer</kw>
    </keywords>

    <header id="hdr.ctype" name="ctype.h">
      <summary><![CDATA[
<p>
Byte-oriented character classification and case mapping. The classification predicates return non-zero for true and 0 for false.
These functions often exist as macros for performance; treat them as pure, side-effect-free predicates.
</p>
<p>
Input safety rule: the argument must be <code>EOF</code> or representable as <code>unsigned char</code>. Passing a negative
<code>char</code> value directly is undefined behavior on platforms where <code>char</code> is signed.
</p>
]]></summary>

      <function id="fn.isalnum" name="isalnum" kind="function_or_macro">
        <signature>int isalnum(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is alphanumeric (a letter or a decimal digit) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isalnum.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or a value representable as <code>unsigned char</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.ctype.domain" severity="important">
                <description><![CDATA[
<p>Passing any value other than <code>EOF</code> or an <code>unsigned char</code> value is undefined behavior.</p>
]]></description>
              </constraint>
              <constraint id="c.ctype.locale" severity="info">
                <description><![CDATA[
<p>Classification depends on the active locale. In the "C" locale, behavior matches basic ASCII classes.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphanumeric, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isalnum.identifier_scan" lang="c99">
            <title>Scan a token of [A-Za-z0-9] in a locale-aware way</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t scan_alnum_token(const char *s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isalnum((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isalpha" name="isalpha" kind="function_or_macro">
        <signature>int isalpha(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is an alphabetic character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isalpha.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isalpha.domain" severity="important">
                <description><![CDATA[
<p>Cast byte data to <code>unsigned char</code> before passing to <code>isalpha</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.isalpha.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. Use explicit ASCII checks if you require ASCII-only behavior.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphabetic, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isalpha.word_start" lang="c99">
            <title>Find the first alphabetic character</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t find_first_alpha(const char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isalpha((int)uc)) {
            return i;
        }
    }
    return (size_t)-1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isdigit" name="isdigit" kind="function_or_macro">
        <signature>int isdigit(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a decimal digit ('0'..'9'). In C99, this classification is not locale-variant for ASCII digits.</p>
]]></summary>
        <parameters>
          <param id="p.isdigit.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isdigit.domain" severity="important">
                <description><![CDATA[
<p>Do not pass a negative <code>char</code> value. Cast to <code>unsigned char</code> first.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a decimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isdigit.count_digits" lang="c99">
            <title>Count digits in a string safely</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t count_digits(const char *s) {
    size_t n = 0;
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isdigit((int)uc)) {
            ++n;
        }
    }
    return n;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isspace" name="isspace" kind="function_or_macro">
        <signature>int isspace(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is whitespace (for example space, tab, newline) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isspace.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isspace.domain" severity="important">
                <description><![CDATA[
<p>Cast byte input to <code>unsigned char</code> before calling.</p>
]]></description>
              </constraint>
              <constraint id="c.isspace.locale" severity="info">
                <description><![CDATA[
<p>Whitespace set can vary by locale beyond the basic ASCII set.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if whitespace, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isspace.trim_left" lang="c99">
            <title>Trim leading whitespace</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t trim_left_index(const char *s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isspace((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.islower" name="islower" kind="function_or_macro">
        <signature>int islower(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a lowercase letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.islower.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.islower.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior if <code>c</code> is neither <code>EOF</code> nor an <code>unsigned char</code> value.</p>
]]></description>
              </constraint>
              <constraint id="c.islower.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. For ASCII-only rules, use explicit range checks ('a'..'z').</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if lowercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.islower.any_lower" lang="c99">
            <title>Detect whether a string contains any lowercase letters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int contains_lowercase(const char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (islower((int)uc)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isupper" name="isupper" kind="function_or_macro">
        <signature>int isupper(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is an uppercase letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isupper.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isupper.domain" severity="important">
                <description><![CDATA[
<p>Cast to <code>unsigned char</code> when passing a <code>char</code> value.</p>
]]></description>
              </constraint>
              <constraint id="c.isupper.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. For ASCII-only behavior, use explicit range checks ('A'..'Z').</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if uppercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isupper.all_upper" lang="c99">
            <title>Check whether all letters in a token are uppercase</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int token_is_all_upper(const char *s) {
    int saw_letter = 0;
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (isalpha((int)uc)) {
            saw_letter = 1;
            if (!isupper((int)uc)) {
                return 0;
            }
        }
    }
    return saw_letter ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ispunct" name="ispunct" kind="function_or_macro">
        <signature>int ispunct(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a punctuation character (neither alphanumeric nor whitespace) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.ispunct.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.ispunct.domain" severity="important">
                <description><![CDATA[
<p>Pass only <code>EOF</code> or values representable as <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.ispunct.locale" severity="info">
                <description><![CDATA[
<p>Punctuation set is locale-dependent. If you need a fixed ASCII punctuation set, define it explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if punctuation, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.ispunct.strip_punct" lang="c99">
            <title>Copy only non-punctuation characters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t copy_without_punct(char *dst, size_t cap, const char *src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != '\0' && j + 1 < cap; ++i) {
        unsigned char uc = (unsigned char)src[i];
        if (!ispunct((int)uc)) {
            dst[j++] = (char)uc;
        }
    }
    dst[j] = '\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isprint" name="isprint" kind="function_or_macro">
        <signature>int isprint(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is printable (including space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isprint.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isprint.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior if given a negative <code>char</code> value that is not <code>EOF</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.isprint.locale" severity="info">
                <description><![CDATA[
<p>What counts as printable may vary by locale and encoding.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if printable, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isprint.sanitize" lang="c99">
            <title>Sanitize bytes: replace non-printables with '.'</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void sanitize_printable(char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (!isprint((int)uc)) {
            s[i] = '.';
        }
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iscntrl" name="iscntrl" kind="function_or_macro">
        <signature>int iscntrl(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a control character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iscntrl.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.iscntrl.domain" severity="important">
                <description><![CDATA[
<p>Cast to <code>unsigned char</code> when testing a <code>char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.iscntrl.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent. In the "C" locale, ASCII control characters typically satisfy this predicate.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if control character, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iscntrl.reject_controls" lang="c99">
            <title>Reject strings containing control characters</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

int has_control_chars(const char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        if (iscntrl((int)uc)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.isxdigit" name="isxdigit" kind="function_or_macro">
        <signature>int isxdigit(int c);</signature>
        <summary><![CDATA[
<p>Tests whether <code>c</code> is a hexadecimal digit ('0'..'9', 'a'..'f', 'A'..'F') according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.isxdigit.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to test, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.isxdigit.domain" severity="important">
                <description><![CDATA[
<p>Only pass <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a hexadecimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.isxdigit.scan_hex" lang="c99">
            <title>Scan a run of hex digits</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

size_t scan_hex_digits(const char *s) {
    size_t i = 0;
    while (s[i] != '\0') {
        unsigned char uc = (unsigned char)s[i];
        if (!isxdigit((int)uc)) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.tolower" name="tolower" kind="function_or_macro">
        <signature>int tolower(int c);</signature>
        <summary><![CDATA[
<p>Converts <code>c</code> to lowercase if it has a lowercase mapping in the current locale; otherwise returns <code>c</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.tolower.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to convert, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.tolower.domain" severity="important">
                <description><![CDATA[
<p>Passing a negative <code>char</code> value (other than <code>EOF</code>) is undefined behavior. Cast to <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.tolower.locale" severity="info">
                <description><![CDATA[
<p>Mapping is locale-dependent. For ASCII-only behavior, map 'A'..'Z' explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Lowercased character value if applicable; otherwise the original value. If input is <code>EOF</code>, returns <code>EOF</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.tolower.safe_cast" severity="important" topic="input-domain">
            <description><![CDATA[
<p>
When converting a byte stored in a <code>char</code>, use <code>tolower((unsigned char)ch)</code>.
This avoids undefined behavior on platforms where <code>char</code> is signed.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.tolower.ascii_fold_command" lang="c99">
            <title>Lowercase a command token safely (byte string)</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void lowercase_in_place(char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        int lc = tolower((int)uc);
        s[i] = (char)lc;
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.toupper" name="toupper" kind="function_or_macro">
        <signature>int toupper(int c);</signature>
        <summary><![CDATA[
<p>Converts <code>c</code> to uppercase if it has an uppercase mapping in the current locale; otherwise returns <code>c</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.toupper.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character value to convert, as <code>EOF</code> or an <code>unsigned char</code> value.</p>
]]></description>
            <constraints>
              <constraint id="c.toupper.domain" severity="important">
                <description><![CDATA[
<p>Undefined behavior unless <code>c</code> is <code>EOF</code> or representable as <code>unsigned char</code>.</p>
]]></description>
              </constraint>
              <constraint id="c.toupper.locale" severity="info">
                <description><![CDATA[
<p>Mapping is locale-dependent. For ASCII-only behavior, map 'a'..'z' explicitly.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Uppercased character value if applicable; otherwise the original value. If input is <code>EOF</code>, returns <code>EOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.toupper.headerize" lang="c99">
            <title>Uppercase a token safely (byte string)</title>
            <code><![CDATA[
#include <ctype.h>
#include <stddef.h>

void uppercase_in_place(char *s) {
    for (size_t i = 0; s[i] != '\0'; ++i) {
        unsigned char uc = (unsigned char)s[i];
        int uc2 = toupper((int)uc);
        s[i] = (char)uc2;
    }
}
]]></code>
          </example>
        </examples>
      </function>

    </header>

    <header id="hdr.wctype" name="wctype.h">
      <summary><![CDATA[
<p>
Wide-character classification and case mapping. Use these functions when working with <code>wchar_t</code> and <code>wint_t</code>
values (for example, when processing wide strings or locale-dependent wide character input).
</p>
<p>
Input safety rule: arguments must be <code>WEOF</code> or representable as <code>wint_t</code> values corresponding to valid wide characters.
Like <code>ctype.h</code>, behavior depends on the active locale (typically <code>LC_CTYPE</code>).
</p>
]]></summary>

      <function id="fn.iswalnum" name="iswalnum" kind="function_or_macro">
        <signature>int iswalnum(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is alphanumeric according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswalnum.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character representable as <code>wint_t</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.wctype.domain" severity="important">
                <description><![CDATA[
<p>Passing values that are neither <code>WEOF</code> nor valid wide characters yields unspecified or undefined behavior depending on implementation.</p>
]]></description>
              </constraint>
              <constraint id="c.wctype.locale" severity="info">
                <description><![CDATA[
<p>Classification is locale-dependent.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphanumeric, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswalnum.scan" lang="c99">
            <title>Scan an alphanumeric prefix in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t scan_walnum_prefix(const wchar_t *s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswalnum((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswalpha" name="iswalpha" kind="function_or_macro">
        <signature>int iswalpha(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is alphabetic according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswalpha.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswalpha.locale" severity="info">
                <description><![CDATA[
<p>Locale-dependent; do not assume ASCII-only semantics.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if alphabetic, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswalpha.find" lang="c99">
            <title>Find first alphabetic wide character</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t find_first_walpha(const wchar_t *s) {
    for (size_t i = 0; s[i] != L'\0'; ++i) {
        if (iswalpha((wint_t)s[i])) {
            return i;
        }
    }
    return (size_t)-1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswblank" name="iswblank" kind="function_or_macro">
        <signature>int iswblank(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a blank character (typically space or horizontal tab) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswblank.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswblank.locale" severity="info">
                <description><![CDATA[
<p>Exact set of "blank" characters can be locale-dependent.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if blank, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswblank.skip" lang="c99">
            <title>Skip leading blanks in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t skip_wblanks(const wchar_t *s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswblank((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswcntrl" name="iswcntrl" kind="function_or_macro">
        <signature>int iswcntrl(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a control character according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswcntrl.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a control character, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswcntrl.reject" lang="c99">
            <title>Detect control characters in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_has_controls(const wchar_t *s) {
    for (; *s != L'\0'; ++s) {
        if (iswcntrl((wint_t)*s)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswdigit" name="iswdigit" kind="function_or_macro">
        <signature>int iswdigit(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a decimal digit according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswdigit.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.iswdigit.locale" severity="info">
                <description><![CDATA[
<p>Unlike byte <code>isdigit</code>, wide digit classification may include locale-specific digits depending on implementation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswdigit.count" lang="c99">
            <title>Count digit characters in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t count_wdigits(const wchar_t *s) {
    size_t n = 0;
    for (size_t i = 0; s[i] != L'\0'; ++i) {
        if (iswdigit((wint_t)s[i])) {
            ++n;
        }
    }
    return n;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswgraph" name="iswgraph" kind="function_or_macro">
        <signature>int iswgraph(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a graphical character (printable excluding space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswgraph.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if graphical, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswgraph.filter" lang="c99">
            <title>Filter out non-graphical characters</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t copy_wgraph(wchar_t *dst, size_t cap, const wchar_t *src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != L'\0' && j + 1 < cap; ++i) {
        if (iswgraph((wint_t)src[i])) {
            dst[j++] = src[i];
        }
    }
    dst[j] = L'\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswlower" name="iswlower" kind="function_or_macro">
        <signature>int iswlower(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a lowercase wide letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswlower.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if lowercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswlower.any" lang="c99">
            <title>Detect lowercase in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_contains_lower(const wchar_t *s) {
    for (; *s != L'\0'; ++s) {
        if (iswlower((wint_t)*s)) {
            return 1;
        }
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswprint" name="iswprint" kind="function_or_macro">
        <signature>int iswprint(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is printable (including space) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswprint.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if printable, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswprint.sanitize" lang="c99">
            <title>Replace non-printable wide characters with '?'</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void sanitize_wprintable(wchar_t *s) {
    for (; *s != L'\0'; ++s) {
        if (!iswprint((wint_t)*s)) {
            *s = L'?';
        }
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswpunct" name="iswpunct" kind="function_or_macro">
        <signature>int iswpunct(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is punctuation (neither alphanumeric nor whitespace) according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswpunct.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if punctuation, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswpunct.strip" lang="c99">
            <title>Remove punctuation from a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t copy_without_wpunct(wchar_t *dst, size_t cap, const wchar_t *src) {
    size_t j = 0;
    for (size_t i = 0; src[i] != L'\0' && j + 1 < cap; ++i) {
        if (!iswpunct((wint_t)src[i])) {
            dst[j++] = src[i];
        }
    }
    dst[j] = L'\0';
    return j;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswspace" name="iswspace" kind="function_or_macro">
        <signature>int iswspace(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is whitespace according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswspace.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if whitespace, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswspace.trim" lang="c99">
            <title>Trim leading whitespace in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t trim_left_wspace(const wchar_t *s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswspace((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswupper" name="iswupper" kind="function_or_macro">
        <signature>int iswupper(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is an uppercase wide letter according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswupper.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if uppercase, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswupper.all" lang="c99">
            <title>Check if all letters in a wide string are uppercase</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

int wide_letters_all_upper(const wchar_t *s) {
    int saw_letter = 0;
    for (; *s != L'\0'; ++s) {
        wint_t wc = (wint_t)*s;
        if (iswalpha(wc)) {
            saw_letter = 1;
            if (!iswupper(wc)) {
                return 0;
            }
        }
    }
    return saw_letter ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.iswxdigit" name="iswxdigit" kind="function_or_macro">
        <signature>int iswxdigit(wint_t wc);</signature>
        <summary><![CDATA[
<p>Tests whether <code>wc</code> is a hexadecimal digit according to the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.iswxdigit.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to test.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-zero if a hexadecimal digit, otherwise 0.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.iswxdigit.scan" lang="c99">
            <title>Scan hex digits in a wide string</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>
#include <stddef.h>

size_t scan_whex(const wchar_t *s) {
    size_t i = 0;
    while (s[i] != L'\0') {
        if (!iswxdigit((wint_t)s[i])) {
            break;
        }
        ++i;
    }
    return i;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towlower" name="towlower" kind="function_or_macro">
        <signature>wint_t towlower(wint_t wc);</signature>
        <summary><![CDATA[
<p>Converts <code>wc</code> to lowercase if it has a lowercase mapping in the current locale; otherwise returns <code>wc</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.towlower.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to convert, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
            <constraints>
              <constraint id="c.towlower.locale" severity="info">
                <description><![CDATA[
<p>Mapping depends on locale. Case conversion for wide characters can be more complex than ASCII.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Lowercased wide character if applicable; otherwise original. If input is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towlower.fold" lang="c99">
            <title>Lowercase a wide string in place</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_lowercase_in_place(wchar_t *s) {
    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towlower((wint_t)*s);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towupper" name="towupper" kind="function_or_macro">
        <signature>wint_t towupper(wint_t wc);</signature>
        <summary><![CDATA[
<p>Converts <code>wc</code> to uppercase if it has an uppercase mapping in the current locale; otherwise returns <code>wc</code> unchanged.</p>
]]></summary>
        <parameters>
          <param id="p.towupper.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to convert, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Uppercased wide character if applicable; otherwise original. If input is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towupper.fold" lang="c99">
            <title>Uppercase a wide string in place</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_uppercase_in_place(wchar_t *s) {
    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towupper((wint_t)*s);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wctype" name="wctype" kind="function">
        <signature>wctype_t wctype(const char *property);</signature>
        <summary><![CDATA[
<p>
Maps a property name to a <code>wctype_t</code> classification descriptor that can be used with <code>iswctype</code>
(if you choose to include it) or for caching a classification category by name.
</p>
<p>
Standard property names correspond to the <code>isw*</code> classes, such as "alpha", "digit", "space", "upper", "lower",
"xdigit", and related names. If the property is not recognized, returns 0.
</p>
]]></summary>
        <parameters>
          <param id="p.wctype.property" name="property" direction="in" type="const char *">
            <description><![CDATA[
<p>Nul-terminated property name string. Examples include "alpha", "digit", "space", "upper", "lower", "xdigit".</p>
]]></description>
            <constraints>
              <constraint id="c.wctype.property_null" severity="important">
                <description><![CDATA[
<p><code>property</code> must not be NULL.</p>
]]></description>
              </constraint>
              <constraint id="c.wctype.property_locale" severity="info">
                <description><![CDATA[
<p>Property interpretation depends on the current locale.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wctype_t">
            <description><![CDATA[
<p>Classification descriptor for the named property, or 0 if the name is not recognized.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.wctype.cache" severity="important" topic="performance">
            <description><![CDATA[
<p>
If you need dynamic selection by name, call <code>wctype</code> once and cache the returned descriptor instead of
repeating string lookups.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.wctype.lookup" lang="c99">
            <title>Lookup and validate a classification property name</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

wctype_t get_class_or_zero(const char *name) {
    /* name must be non-NULL and NUL-terminated */
    wctype_t t = wctype(name);
    return t; /* 0 means "unknown property" */
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wctrans" name="wctrans" kind="function">
        <signature>wctrans_t wctrans(const char *property);</signature>
        <summary><![CDATA[
<p>
Maps a transformation property name to a <code>wctrans_t</code> descriptor used by <code>towctrans</code>.
Standard transformation property names include "tolower" and "toupper".
</p>
<p>If the property is not recognized, returns 0.</p>
]]></summary>
        <parameters>
          <param id="p.wctrans.property" name="property" direction="in" type="const char *">
            <description><![CDATA[
<p>Nul-terminated transformation name string, typically "tolower" or "toupper".</p>
]]></description>
            <constraints>
              <constraint id="c.wctrans.property_null" severity="important">
                <description><![CDATA[
<p><code>property</code> must not be NULL.</p>
]]></description>
              </constraint>
              <constraint id="c.wctrans.locale" severity="info">
                <description><![CDATA[
<p>Transformation behavior depends on the current locale.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wctrans_t">
            <description><![CDATA[
<p>Transformation descriptor, or 0 if the name is not recognized.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.wctrans.lookup" lang="c99">
            <title>Lookup a case transformation descriptor by name</title>
            <code><![CDATA[
#include <wctype.h>

wctrans_t get_transformation(const char *name) {
    /* name must be non-NULL */
    return wctrans(name); /* 0 means "unknown transformation" */
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.towctrans" name="towctrans" kind="function">
        <signature>wint_t towctrans(wint_t wc, wctrans_t desc);</signature>
        <summary><![CDATA[
<p>Applies the transformation described by <code>desc</code> to <code>wc</code> and returns the transformed wide character.</p>
]]></summary>
        <parameters>
          <param id="p.towctrans.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character value to transform, as <code>WEOF</code> or a valid wide character.</p>
]]></description>
          </param>
          <param id="p.towctrans.desc" name="desc" direction="in" type="wctrans_t">
            <description><![CDATA[
<p>Transformation descriptor returned by <code>wctrans</code>. A value of 0 indicates an invalid or unknown descriptor.</p>
]]></description>
            <constraints>
              <constraint id="c.towctrans.desc_valid" severity="important">
                <description><![CDATA[
<p>Do not pass 0 as <code>desc</code>. Validate the result of <code>wctrans</code> before calling.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Transformed wide character. If <code>wc</code> is <code>WEOF</code>, returns <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.towctrans.dynamic_case" lang="c99">
            <title>Apply case conversion selected by name</title>
            <code><![CDATA[
#include <wctype.h>
#include <wchar.h>

void wide_apply_case(wchar_t *s, const char *which) {
    wctrans_t tr = wctrans(which);
    if (tr == 0) {
        /* Unknown transformation name */
        return;
    }

    for (; *s != L'\0'; ++s) {
        *s = (wchar_t)towctrans((wint_t)*s, tr);
    }
}
]]></code>
          </example>
        </examples>
      </function>

    </header>

  </category>

</document>


</script>

<script id="library-xml-2026-01-20T16-12-30-bd774ff8-f2e4-4840-8484-d0941f5605ab" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="strings.raw_memory" name="Strings and raw memory (byte and wide)">
    <summary><![CDATA[
<p>
Primitives for working with raw memory buffers, NUL-terminated byte strings, and NUL-terminated wide strings.
These APIs are the standard toolkit for copying, comparing, searching, tokenizing, and transforming data in-place.
</p>
<p>
Use the raw-memory functions when you are working with counted buffers (not NUL-terminated), and use the string
functions when you are working with NUL-terminated sequences. For safety and portability, always size your
destinations correctly, know whether overlap is permitted, and treat locale-sensitive operations (for example
collation/transform) as distinct from byte-wise comparisons.
</p>
]]></summary>

    <keywords>
      <kw>string.h</kw>
      <kw>wchar.h</kw>
      <kw>memcpy</kw>
      <kw>memmove</kw>
      <kw>buffer overlap</kw>
      <kw>NUL terminator</kw>
      <kw>strlen</kw>
      <kw>strcmp</kw>
      <kw>strncpy</kw>
      <kw>strtok</kw>
      <kw>strerror</kw>
      <kw>wide string</kw>
      <kw>multibyte</kw>
      <kw>mbstate_t</kw>
      <kw>swprintf</kw>
    </keywords>

    <header id="hdr.string" name="string.h">
      <summary><![CDATA[
<p>
Byte-level raw memory and NUL-terminated byte string operations. The memory functions operate on counted buffers.
The string functions generally require NUL-terminated inputs and often require sufficient space in the destination
for the copied data plus the terminating NUL.
</p>
]]></summary>

      <notes>
        <note id="n.string.shared.overlap" severity="important" topic="overlap">
          <description><![CDATA[
<p>
Overlapping copy: use <code>memmove</code> (or <code>wmemmove</code> for wide). Using <code>memcpy</code> (or <code>wmemcpy</code>) with overlap is undefined behavior.
</p>
]]></description>
        </note>
        <note id="n.string.shared.termination" severity="important" topic="nul-termination">
          <description><![CDATA[
<p>
Functions like <code>strcpy</code>, <code>strcat</code>, and friends require that inputs are NUL-terminated.
If you have counted data that may contain NULs, use the <code>mem*</code> family instead.
</p>
]]></description>
        </note>
        <note id="n.string.shared.strncpy" severity="warning" topic="common-pitfall">
          <description><![CDATA[
<p>
<code>strncpy</code> does not guarantee NUL-termination if the source length is at least <code>n</code>. Many bugs come from assuming it always terminates.
If you need a guaranteed terminator, you must add it yourself.
</p>
]]></description>
        </note>
        <note id="n.string.shared.strtok" severity="warning" topic="reentrancy">
          <description><![CDATA[
<p>
<code>strtok</code> modifies the input buffer and uses internal state. It is not suitable for nested parsing or concurrent use.
Use <code>wcstok</code> for wide strings; for byte strings, consider a manual scan if you need explicit state.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.memcpy" name="memcpy" kind="function">
        <signature>void *memcpy(void *dest, const void *src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> bytes from <code>src</code> to <code>dest</code>. The memory regions must not overlap.</p>
]]></summary>
        <parameters>
          <param id="p.memcpy.dest" name="dest" direction="out" type="void *">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes available.</p>
]]></description>
          </param>
          <param id="p.memcpy.src" name="src" direction="in" type="const void *">
            <description><![CDATA[
<p>Source buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to copy.</p>
]]></description>
            <constraints>
              <constraint id="c.memcpy.no_overlap" severity="important">
                <description><![CDATA[
<p><code>dest</code> and <code>src</code> must not overlap. If they can overlap, use <code>memmove</code>.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memcpy.copy_struct" lang="c99">
            <title>Copy fixed-size bytes into a struct field</title>
            <code><![CDATA[
#include <string.h>
#include <stdint.h>

struct Header {
    uint8_t magic[4];
};

void set_magic(struct Header *h, const uint8_t src[4]) {
    /* Regions do not overlap; memcpy is correct. */
    memcpy(h->magic, src, 4u);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memmove" name="memmove" kind="function">
        <signature>void *memmove(void *dest, const void *src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> bytes from <code>src</code> to <code>dest</code>. The regions may overlap.</p>
]]></summary>
        <parameters>
          <param id="p.memmove.dest" name="dest" direction="out" type="void *">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes available.</p>
]]></description>
          </param>
          <param id="p.memmove.src" name="src" direction="in" type="const void *">
            <description><![CDATA[
<p>Source buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memmove.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to move.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memmove.delete_range" lang="c99">
            <title>Delete a slice from a byte buffer in place (overlap-safe)</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

/* Delete [pos, pos+len) from buf of length *n, shifting tail left. */
void delete_range(unsigned char *buf, size_t *n, size_t pos, size_t len) {
    if (pos > *n) return;
    if (len > *n - pos) len = *n - pos;

    /* Regions overlap: must use memmove. */
    memmove(buf + pos, buf + pos + len, (*n - pos - len));
    *n -= len;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memset" name="memset" kind="function">
        <signature>void *memset(void *s, int c, size_t n);</signature>
        <summary><![CDATA[
<p>Sets the first <code>n</code> bytes of the object pointed to by <code>s</code> to the byte value <code>(unsigned char)c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.memset.s" name="s" direction="inout" type="void *">
            <description><![CDATA[
<p>Buffer to fill, must have at least <code>n</code> bytes writable.</p>
]]></description>
          </param>
          <param id="p.memset.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Fill byte value; only the low 8 bits are used.</p>
]]></description>
          </param>
          <param id="p.memset.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to set.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Returns <code>s</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.memset.zero_init" lang="c99">
            <title>Zero-initialize a buffer</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

void clear_bytes(void *p, size_t n) {
    memset(p, 0, n);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.memcmp" name="memcmp" kind="function">
        <signature>int memcmp(const void *s1, const void *s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares the first <code>n</code> bytes of two buffers lexicographically as unsigned bytes.</p>
]]></summary>
        <parameters>
          <param id="p.memcmp.s1" name="s1" direction="in" type="const void *">
            <description><![CDATA[
<p>First buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcmp.s2" name="s2" direction="in" type="const void *">
            <description><![CDATA[
<p>Second buffer, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memcmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0 if s1 &lt; s2, 0 if equal, greater than 0 if s1 &gt; s2 (based on the first differing byte).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.memcmp.not_string" severity="important" topic="semantics">
            <description><![CDATA[
<p><code>memcmp</code> is for counted buffers. It does not stop at NUL and is not a locale-aware string compare.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.memchr" name="memchr" kind="function">
        <signature>void *memchr(const void *s, int c, size_t n);</signature>
        <summary><![CDATA[
<p>Searches the first <code>n</code> bytes of <code>s</code> for the first occurrence of the byte <code>(unsigned char)c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.memchr.s" name="s" direction="in" type="const void *">
            <description><![CDATA[
<p>Buffer to search, must have at least <code>n</code> bytes readable.</p>
]]></description>
          </param>
          <param id="p.memchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Target byte; only the low 8 bits are used.</p>
]]></description>
          </param>
          <param id="p.memchr.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to scan.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Pointer to the matching byte within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strlen" name="strlen" kind="function">
        <signature>size_t strlen(const char *s);</signature>
        <summary><![CDATA[
<p>Returns the length of the NUL-terminated byte string <code>s</code>, not including the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strlen.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string. Must contain a terminating NUL within accessible memory.</p>
]]></description>
            <constraints>
              <constraint id="c.strlen.must_terminate" severity="important">
                <description><![CDATA[
<p>If <code>s</code> is not properly terminated, <code>strlen</code> will read past bounds (undefined behavior).</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes before the first NUL.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strlen.performance" severity="info" topic="performance">
            <description><![CDATA[
<p>Repeated <code>strlen</code> calls on the same string are O(n) each. Cache the result if needed.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strcmp" name="strcmp" kind="function">
        <signature>int strcmp(const char *s1, const char *s2);</signature>
        <summary><![CDATA[
<p>Compares two NUL-terminated byte strings lexicographically using unsigned char ordering.</p>
]]></summary>
        <parameters>
          <param id="p.strcmp.s1" name="s1" direction="in" type="const char *">
            <description><![CDATA[
<p>First NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strcmp.s2" name="s2" direction="in" type="const char *">
            <description><![CDATA[
<p>Second NUL-terminated string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0 if s1 &lt; s2, 0 if equal, greater than 0 if s1 &gt; s2 (based on the first differing byte).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcmp.locale" severity="important" topic="collation">
            <description><![CDATA[
<p><code>strcmp</code> is byte-wise, not locale collation. For locale-aware ordering, use <code>strcoll</code> (not in this category list).</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncmp" name="strncmp" kind="function">
        <signature>int strncmp(const char *s1, const char *s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares up to <code>n</code> bytes of two NUL-terminated strings, stopping early if a NUL is reached.</p>
]]></summary>
        <parameters>
          <param id="p.strncmp.s1" name="s1" direction="in" type="const char *">
            <description><![CDATA[
<p>First NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncmp.s2" name="s2" direction="in" type="const char *">
            <description><![CDATA[
<p>Second NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 as with <code>strcmp</code>, but limited to at most <code>n</code> bytes.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strncmp.prefix" severity="info" topic="prefix-check">
            <description><![CDATA[
<p>
For prefix checks, ensure lengths match your intent. Example: <code>strncmp(s, "ab", 2) == 0</code> matches "ab" and "abc".
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strcpy" name="strcpy" kind="function">
        <signature>char *strcpy(char *dest, const char *src);</signature>
        <summary><![CDATA[
<p>Copies the NUL-terminated string <code>src</code> (including terminator) into <code>dest</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strcpy.dest" name="dest" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer, must be large enough for all of <code>src</code> plus the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.strcpy.src" name="src" direction="in" type="const char *">
            <description><![CDATA[
<p>Source NUL-terminated string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcpy.safety" severity="warning" topic="buffer-size">
            <description><![CDATA[
<p><code>strcpy</code> has no bounds parameter. Use only when you have a proven bound for <code>dest</code>.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncpy" name="strncpy" kind="function">
        <signature>char *strncpy(char *dest, const char *src, size_t n);</signature>
        <summary><![CDATA[
<p>
Copies up to <code>n</code> bytes from <code>src</code> into <code>dest</code>. If <code>src</code> is shorter than <code>n</code>,
pads <code>dest</code> with NUL bytes. If <code>src</code> is at least <code>n</code> bytes, no terminator is written.
</p>
]]></summary>
        <parameters>
          <param id="p.strncpy.dest" name="dest" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer, must have at least <code>n</code> bytes writable.</p>
]]></description>
          </param>
          <param id="p.strncpy.src" name="src" direction="in" type="const char *">
            <description><![CDATA[
<p>Source NUL-terminated string (read stops at NUL or after <code>n</code> bytes, whichever comes first).</p>
]]></description>
          </param>
          <param id="p.strncpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to write to <code>dest</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.strncpy.no_termination" severity="important">
                <description><![CDATA[
<p>If <code>src</code> length is at least <code>n</code>, <code>dest</code> will not be NUL-terminated. Add a terminator yourself if required.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strncpy.safe_terminate" lang="c99">
            <title>Copy with explicit terminator</title>
            <code><![CDATA[
#include <string.h>
#include <stddef.h>

void copy_token(char *dst, size_t cap, const char *src) {
    if (cap == 0) return;

    /* Copy at most cap-1 bytes and always terminate. */
    strncpy(dst, src, cap - 1u);
    dst[cap - 1u] = '\0';
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strcat" name="strcat" kind="function">
        <signature>char *strcat(char *dest, const char *src);</signature>
        <summary><![CDATA[
<p>Appends the NUL-terminated string <code>src</code> to the end of <code>dest</code>, overwriting <code>dest</code>'s terminator and writing a new one.</p>
]]></summary>
        <parameters>
          <param id="p.strcat.dest" name="dest" direction="inout" type="char *">
            <description><![CDATA[
<p>Destination NUL-terminated string with enough free space to hold the result.</p>
]]></description>
          </param>
          <param id="p.strcat.src" name="src" direction="in" type="const char *">
            <description><![CDATA[
<p>Source NUL-terminated string to append.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strcat.safety" severity="warning" topic="buffer-size">
            <description><![CDATA[
<p><code>strcat</code> has no bounds parameter. Use only with proven remaining capacity, or prefer a bounded approach using <code>strncat</code> plus explicit accounting.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strncat" name="strncat" kind="function">
        <signature>char *strncat(char *dest, const char *src, size_t n);</signature>
        <summary><![CDATA[
<p>
Appends up to <code>n</code> bytes from <code>src</code> to <code>dest</code>, and then writes a terminating NUL.
Stops early if a NUL is encountered in <code>src</code>.
</p>
]]></summary>
        <parameters>
          <param id="p.strncat.dest" name="dest" direction="inout" type="char *">
            <description><![CDATA[
<p>Destination NUL-terminated string with space for the additional bytes plus one NUL terminator.</p>
]]></description>
          </param>
          <param id="p.strncat.src" name="src" direction="in" type="const char *">
            <description><![CDATA[
<p>Source NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.strncat.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to append from <code>src</code> (excluding the final NUL which is always written).</p>
]]></description>
            <constraints>
              <constraint id="c.strncat.capacity" severity="important">
                <description><![CDATA[
<p>
You must still ensure destination capacity: <code>strlen(dest) + min(strlen(src), n) + 1</code> bytes total.
</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strchr" name="strchr" kind="function">
        <signature>char *strchr(const char *s, int c);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of character <code>(char)c</code> in <code>s</code>, including possibly the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strchr.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character to find, converted to <code>char</code>. Use 0 to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the first match within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strrchr" name="strrchr" kind="function">
        <signature>char *strrchr(const char *s, int c);</signature>
        <summary><![CDATA[
<p>Finds the last occurrence of character <code>(char)c</code> in <code>s</code>, including possibly the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.strrchr.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strrchr.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Character to find, converted to <code>char</code>. Use 0 to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the last match within <code>s</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strstr" name="strstr" kind="function">
        <signature>char *strstr(const char *haystack, const char *needle);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of substring <code>needle</code> within <code>haystack</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strstr.haystack" name="haystack" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strstr.needle" name="needle" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated substring to find. If empty, the result is <code>haystack</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the start of the first match within <code>haystack</code>, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strstr.find_extension" lang="c99">
            <title>Find a file extension separator</title>
            <code><![CDATA[
#include <string.h>

const char *find_dot(const char *path) {
    /* Use strrchr for last '.', but strstr shown as substring search pattern. */
    return strrchr(path, '.');
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtok" name="strtok" kind="function">
        <signature>char *strtok(char *s, const char *delim);</signature>
        <summary><![CDATA[
<p>Tokenizes <code>s</code> by replacing delimiter characters with NUL and returning successive tokens across calls.</p>
]]></summary>
        <parameters>
          <param id="p.strtok.s" name="s" direction="inout" type="char *">
            <description><![CDATA[
<p>
String to tokenize on the first call, then NULL on subsequent calls to continue tokenizing the same string.
The buffer is modified in place.
</p>
]]></description>
          </param>
          <param id="p.strtok.delim" name="delim" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated set of delimiter characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the next token, or NULL when no tokens remain.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtok.modifies" severity="important" topic="input-mutated">
            <description><![CDATA[
<p><code>strtok</code> overwrites delimiters with NUL. If you need the original string, work on a copy.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strtok.split_csv_simple" lang="c99">
            <title>Split a simple comma-separated line in place</title>
            <code><![CDATA[
#include <string.h>
#include <stdio.h>

void print_fields(char *line) {
    /* line is modified in-place. */
    const char *delim = ",";

    char *tok = strtok(line, delim);
    while (tok != NULL) {
        puts(tok);
        tok = strtok(NULL, delim);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strspn" name="strspn" kind="function">
        <signature>size_t strspn(const char *s, const char *accept);</signature>
        <summary><![CDATA[
<p>Returns the length of the initial segment of <code>s</code> consisting only of bytes from <code>accept</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strspn.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to scan.</p>
]]></description>
          </param>
          <param id="p.strspn.accept" name="accept" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated set of accepted characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes in the initial accepted prefix.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strcspn" name="strcspn" kind="function">
        <signature>size_t strcspn(const char *s, const char *reject);</signature>
        <summary><![CDATA[
<p>Returns the length of the initial segment of <code>s</code> consisting of bytes not in <code>reject</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strcspn.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to scan.</p>
]]></description>
          </param>
          <param id="p.strcspn.reject" name="reject" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated set of rejected characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes in the initial segment containing no rejected characters.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strpbrk" name="strpbrk" kind="function">
        <signature>char *strpbrk(const char *s, const char *accept);</signature>
        <summary><![CDATA[
<p>Finds the first character in <code>s</code> that matches any character from <code>accept</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strpbrk.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to search.</p>
]]></description>
          </param>
          <param id="p.strpbrk.accept" name="accept" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated set of accepted characters.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the first matching character in <code>s</code>, or NULL if none found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strerror" name="strerror" kind="function">
        <signature>char *strerror(int errnum);</signature>
        <summary><![CDATA[
<p>Returns a pointer to a human-readable message describing error number <code>errnum</code> (commonly values from <code>errno</code>).</p>
]]></summary>
        <parameters>
          <param id="p.strerror.errnum" name="errnum" direction="in" type="int">
            <description><![CDATA[
<p>Error code to describe (often <code>errno</code>).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to a NUL-terminated message string. The storage may be reused by subsequent calls.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strerror.storage" severity="important" topic="lifetime">
            <description><![CDATA[
<p>The returned pointer may refer to static storage that is overwritten by later calls. Copy it if you need to keep it.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strerror.format_errno" lang="c99">
            <title>Format errno for logging</title>
            <code><![CDATA[
#include <string.h>
#include <errno.h>
#include <stdio.h>

void log_errno(const char *where) {
    int e = errno;
    /* Copy if you need to keep the message beyond this point. */
    printf("%s: errno=%d (%s)\n", where, e, strerror(e));
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.warnings.missing_entries" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category list intentionally includes only the functions you specified from <code>string.h</code>.
Other standard functions also exist in <code>string.h</code> (for example <code>strcoll</code>, <code>strxfrm</code>), but they are not included here.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.wchar" name="wchar.h">
      <summary><![CDATA[
<p>
Wide character and wide string operations, plus multibyte to wide conversion utilities and wide formatted output helpers.
Use these when your program processes wide strings (<code>wchar_t</code>) and when you need locale-aware multibyte decoding.
</p>
<p>
Conversion functions use an explicit <code>mbstate_t</code> state object to support stateful encodings.
When in doubt, initialize a state to zero and reuse it consistently for a stream.
</p>
]]></summary>

      <notes>
        <note id="n.wchar.shared.termination" severity="important" topic="nul-termination">
          <description><![CDATA[
<p>
The <code>wcs*</code> string functions expect NUL-terminated wide strings.
The <code>wmem*</code> functions operate on counted wide buffers and do not require a terminator.
</p>
]]></description>
        </note>
        <note id="n.wchar.shared.overlap" severity="important" topic="overlap">
          <description><![CDATA[
<p>
Overlapping copy: use <code>wmemmove</code>. Using <code>wmemcpy</code> with overlap is undefined behavior.
</p>
]]></description>
        </note>
        <note id="n.wchar.shared.mbstate" severity="important" topic="mbstate_t">
          <description><![CDATA[
<p>
For multibyte conversions, pass a valid <code>mbstate_t *</code>. A zero-initialized state represents the initial shift state.
Using a consistent state object is critical for stateful encodings.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.wcslen" name="wcslen" kind="function">
        <signature>size_t wcslen(const wchar_t *s);</signature>
        <summary><![CDATA[
<p>Returns the length of NUL-terminated wide string <code>s</code>, not including the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcslen.s" name="s" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated wide string. Must contain a terminator within accessible memory.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of wide characters before the first wide NUL.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscmp" name="wcscmp" kind="function">
        <signature>int wcscmp(const wchar_t *s1, const wchar_t *s2);</signature>
        <summary><![CDATA[
<p>Compares two NUL-terminated wide strings lexicographically (code unit order, not locale collation).</p>
]]></summary>
        <parameters>
          <param id="p.wcscmp.s1" name="s1" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcscmp.s2" name="s2" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 based on the first differing wide character.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncmp" name="wcsncmp" kind="function">
        <signature>int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares up to <code>n</code> wide characters of two wide strings, stopping early at a wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcsncmp.s1" name="s1" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncmp.s2" name="s2" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0, limited to at most <code>n</code> wide characters.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscpy" name="wcscpy" kind="function">
        <signature>wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);</signature>
        <summary><![CDATA[
<p>Copies the wide string <code>src</code> (including terminator) into <code>dest</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcscpy.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer, must have enough space for all of <code>src</code> plus the terminating wide NUL.</p>
]]></description>
          </param>
          <param id="p.wcscpy.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncpy" name="wcsncpy" kind="function">
        <signature>wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);</signature>
        <summary><![CDATA[
<p>
Copies up to <code>n</code> wide characters from <code>src</code> into <code>dest</code>. Pads with wide NULs if <code>src</code> is shorter.
If <code>src</code> length is at least <code>n</code>, no terminator is written.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsncpy.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> writable wide characters.</p>
]]></description>
          </param>
          <param id="p.wcsncpy.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to write.</p>
]]></description>
            <constraints>
              <constraint id="c.wcsncpy.no_termination" severity="important">
                <description><![CDATA[
<p>If <code>src</code> is at least <code>n</code> wide characters long, <code>dest</code> is not terminated. Add a terminator if required.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscat" name="wcscat" kind="function">
        <signature>wchar_t *wcscat(wchar_t *dest, const wchar_t *src);</signature>
        <summary><![CDATA[
<p>Appends wide string <code>src</code> to <code>dest</code>, writing a new terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcscat.dest" name="dest" direction="inout" type="wchar_t *">
            <description><![CDATA[
<p>Destination NUL-terminated wide string with enough free capacity.</p>
]]></description>
          </param>
          <param id="p.wcscat.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source NUL-terminated wide string to append.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsncat" name="wcsncat" kind="function">
        <signature>wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);</signature>
        <summary><![CDATA[
<p>
Appends up to <code>n</code> wide characters from <code>src</code> to <code>dest</code>, then terminates with a wide NUL.
Stops early if a wide NUL occurs in <code>src</code>.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsncat.dest" name="dest" direction="inout" type="wchar_t *">
            <description><![CDATA[
<p>Destination NUL-terminated wide string with enough capacity for appended data plus terminator.</p>
]]></description>
          </param>
          <param id="p.wcsncat.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcsncat.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to append (excluding the final terminator).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcschr" name="wcschr" kind="function">
        <signature>wchar_t *wcschr(const wchar_t *s, wchar_t c);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of wide character <code>c</code> in <code>s</code>, including possibly the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcschr.s" name="s" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcschr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to find. Use L'\0' to locate the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Pointer to first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsrchr" name="wcsrchr" kind="function">
        <signature>wchar_t *wcsrchr(const wchar_t *s, wchar_t c);</signature>
        <summary><![CDATA[
<p>Finds the last occurrence of wide character <code>c</code> in <code>s</code>, including possibly the terminating wide NUL.</p>
]]></summary>
        <parameters>
          <param id="p.wcsrchr.s" name="s" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcsrchr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to find.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Pointer to last match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsstr" name="wcsstr" kind="function">
        <signature>wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle);</signature>
        <summary><![CDATA[
<p>Finds the first occurrence of substring <code>needle</code> within <code>haystack</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcsstr.haystack" name="haystack" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated wide string to search.</p>
]]></description>
          </param>
          <param id="p.wcsstr.needle" name="needle" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated wide substring to find. If empty, the result is <code>haystack</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Pointer to first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcstok" name="wcstok" kind="function">
        <signature>wchar_t *wcstok(wchar_t *s, const wchar_t *delim, wchar_t **ptr);</signature>
        <summary><![CDATA[
<p>
Tokenizes a wide string in place. Unlike <code>strtok</code>, <code>wcstok</code> uses an explicit state pointer <code>ptr</code>,
making the state caller-managed.
</p>
]]></summary>
        <parameters>
          <param id="p.wcstok.s" name="s" direction="inout" type="wchar_t *">
            <description><![CDATA[
<p>String to tokenize on first call, then NULL to continue.</p>
]]></description>
          </param>
          <param id="p.wcstok.delim" name="delim" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>NUL-terminated set of delimiter wide characters.</p>
]]></description>
          </param>
          <param id="p.wcstok.ptr" name="ptr" direction="inout" type="wchar_t **">
            <description><![CDATA[
<p>Caller-managed tokenizer state. Must point to a <code>wchar_t *</code> variable that persists across calls.</p>
]]></description>
            <constraints>
              <constraint id="c.wcstok.ptr_required" severity="important">
                <description><![CDATA[
<p><code>ptr</code> must not be NULL. It carries the scan position between calls.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Pointer to next token, or NULL when no tokens remain.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.wcstok.split" lang="c99">
            <title>Split a wide string with explicit state</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdio.h>

void print_wfields(wchar_t *line) {
    wchar_t *state = NULL;
    const wchar_t *delim = L",";

    wchar_t *tok = wcstok(line, delim, &state);
    while (tok != NULL) {
        /* Print using wide I/O if desired; here just show call shape. */
        /* wprintf(L"%ls\n", tok); */
        tok = wcstok(NULL, delim, &state);
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wcsxfrm" name="wcsxfrm" kind="function">
        <signature>size_t wcsxfrm(wchar_t *dest, const wchar_t *src, size_t n);</signature>
        <summary><![CDATA[
<p>
Transforms <code>src</code> into a form suitable for locale-aware comparison using <code>wcscoll</code>-like ordering.
The transformed sequence is placed into <code>dest</code> if <code>n</code> permits.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsxfrm.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer for the transformed form. May be NULL if <code>n</code> is 0 to query required length.</p>
]]></description>
          </param>
          <param id="p.wcsxfrm.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source NUL-terminated wide string to transform.</p>
]]></description>
          </param>
          <param id="p.wcsxfrm.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to write to <code>dest</code>, including the terminator.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns the length of the transformed string (not including terminator). If return value is at least <code>n</code>,
the output was truncated and you should allocate a larger buffer.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcscoll" name="wcscoll" kind="function">
        <signature>int wcscoll(const wchar_t *s1, const wchar_t *s2);</signature>
        <summary><![CDATA[
<p>Compares two wide strings using the current locale collation order (unlike <code>wcscmp</code> which is code unit order).</p>
]]></summary>
        <parameters>
          <param id="p.wcscoll.s1" name="s1" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>First NUL-terminated wide string.</p>
]]></description>
          </param>
          <param id="p.wcscoll.s2" name="s2" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Second NUL-terminated wide string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 depending on locale collation order.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.wcscoll.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Collation depends on the active locale (typically <code>LC_COLLATE</code>).</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wmemcpy" name="wmemcpy" kind="function">
        <signature>wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> wide characters from <code>src</code> to <code>dest</code>. Regions must not overlap.</p>
]]></summary>
        <parameters>
          <param id="p.wmemcpy.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> wide characters writable.</p>
]]></description>
          </param>
          <param id="p.wmemcpy.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source buffer with at least <code>n</code> wide characters readable.</p>
]]></description>
          </param>
          <param id="p.wmemcpy.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to copy.</p>
]]></description>
            <constraints>
              <constraint id="c.wmemcpy.no_overlap" severity="important">
                <description><![CDATA[
<p>Buffers must not overlap. Use <code>wmemmove</code> if overlap is possible.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemmove" name="wmemmove" kind="function">
        <signature>wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);</signature>
        <summary><![CDATA[
<p>Copies <code>n</code> wide characters from <code>src</code> to <code>dest</code>. Regions may overlap.</p>
]]></summary>
        <parameters>
          <param id="p.wmemmove.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer with at least <code>n</code> wide characters writable.</p>
]]></description>
          </param>
          <param id="p.wmemmove.src" name="src" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Source buffer with at least <code>n</code> wide characters readable.</p>
]]></description>
          </param>
          <param id="p.wmemmove.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to move.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>dest</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemset" name="wmemset" kind="function">
        <signature>wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n);</signature>
        <summary><![CDATA[
<p>Sets the first <code>n</code> wide characters of <code>s</code> to <code>c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wmemset.s" name="s" direction="inout" type="wchar_t *">
            <description><![CDATA[
<p>Buffer to fill, must be writable for <code>n</code> wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemset.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Fill wide character value.</p>
]]></description>
          </param>
          <param id="p.wmemset.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to set.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>s</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemcmp" name="wmemcmp" kind="function">
        <signature>int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);</signature>
        <summary><![CDATA[
<p>Compares the first <code>n</code> wide characters of two buffers.</p>
]]></summary>
        <parameters>
          <param id="p.wmemcmp.s1" name="s1" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>First buffer with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemcmp.s2" name="s2" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Second buffer with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemcmp.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of wide characters to compare.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Less than 0, 0, or greater than 0 based on the first differing wide character.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wmemchr" name="wmemchr" kind="function">
        <signature>wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);</signature>
        <summary><![CDATA[
<p>Searches the first <code>n</code> wide characters of <code>s</code> for the first occurrence of <code>c</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wmemchr.s" name="s" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Buffer to search, with at least <code>n</code> readable wide characters.</p>
]]></description>
          </param>
          <param id="p.wmemchr.c" name="c" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Target wide character.</p>
]]></description>
          </param>
          <param id="p.wmemchr.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to scan.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Pointer to the first match, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.btowc" name="btowc" kind="function">
        <signature>wint_t btowc(int c);</signature>
        <summary><![CDATA[
<p>Converts a single byte <code>c</code> to a wide character if possible in the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.btowc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to convert, typically <code>EOF</code> or an unsigned byte value (0..UCHAR_MAX).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Converted wide character, or <code>WEOF</code> if <code>c</code> is <code>EOF</code> or not convertible as a single byte.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wctob" name="wctob" kind="function">
        <signature>int wctob(wint_t c);</signature>
        <summary><![CDATA[
<p>Converts a wide character <code>c</code> to a single byte if representable as a single-byte character in the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.wctob.c" name="c" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character to convert, or <code>WEOF</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Converted unsigned byte value (as an <code>unsigned char</code> promoted to int), or <code>EOF</code> if not representable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbrlen" name="mbrlen" kind="function">
        <signature>size_t mbrlen(const char *s, size_t n, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Determines the number of bytes that make up the next multibyte character in <code>s</code>, using conversion state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.mbrlen.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>Pointer to bytes to examine, or NULL to reset/query the shift state (implementation-defined behavior but widely used as reset).</p>
]]></description>
          </param>
          <param id="p.mbrlen.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes available at <code>s</code>.</p>
]]></description>
          </param>
          <param id="p.mbrlen.ps" name="ps" direction="inout" type="mbstate_t *">
            <description><![CDATA[
<p>Pointer to conversion state object. If NULL, an internal static state may be used.</p>
]]></description>
            <constraints>
              <constraint id="c.mbrlen.state" severity="important">
                <description><![CDATA[
<p>Prefer a caller-owned <code>mbstate_t</code> to avoid hidden shared state and to support stream decoding safely.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns number of bytes for the next character; 0 if the next character is the terminating NUL; (size_t)-1 on encoding error;
(size_t)-2 if the next character is incomplete with the given <code>n</code>.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbrtowc" name="mbrtowc" kind="function">
        <signature>size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Converts the next multibyte character from <code>s</code> to a wide character stored in <code>*pwc</code>, using state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.mbrtowc.pwc" name="pwc" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Output location for the converted wide character. May be NULL if you only want to advance state/validate.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>Pointer to bytes to convert, or NULL to reset the shift state.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes available at <code>s</code>.</p>
]]></description>
          </param>
          <param id="p.mbrtowc.ps" name="ps" direction="inout" type="mbstate_t *">
            <description><![CDATA[
<p>Pointer to conversion state. If NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Returns number of bytes consumed; 0 if converted character is wide NUL; (size_t)-1 on encoding error; (size_t)-2 if incomplete.
</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.mbrtowc.stream_decode" lang="c99">
            <title>Decode a multibyte buffer into wide characters with explicit state</title>
            <code><![CDATA[
#include <wchar.h>
#include <stddef.h>

size_t decode_some(const char *in, size_t in_len, wchar_t *out, size_t out_cap) {
    mbstate_t st;
    /* Zero-initialize conversion state. */
    st = (mbstate_t){0};

    size_t i = 0;
    size_t o = 0;

    while (i < in_len && o < out_cap) {
        wchar_t wc = 0;
        size_t r = mbrtowc(&wc, in + i, in_len - i, &st);

        if (r == (size_t)-1) {
            /* Encoding error. */
            break;
        }
        if (r == (size_t)-2) {
            /* Incomplete character at end of buffer. */
            break;
        }
        if (r == 0) {
            /* Reached terminating NUL. */
            out[o++] = L'\0';
            break;
        }

        out[o++] = wc;
        i += r;
    }

    return o;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wcrtomb" name="wcrtomb" kind="function">
        <signature>size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>Converts wide character <code>wc</code> to its multibyte sequence, writing into <code>s</code>, using state <code>ps</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcrtomb.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer for the multibyte sequence. Must have enough space for at least <code>MB_CUR_MAX</code> bytes. If NULL, resets state.</p>
]]></description>
          </param>
          <param id="p.wcrtomb.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to convert.</p>
]]></description>
          </param>
          <param id="p.wcrtomb.ps" name="ps" direction="inout" type="mbstate_t *">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes written; (size_t)-1 on encoding error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.mbsrtowcs" name="mbsrtowcs" kind="function">
        <signature>size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>
Converts a multibyte string starting at <code>*src</code> into wide characters. Updates <code>*src</code> as input is consumed.
Stops after converting a terminating NUL or after producing <code>len</code> wide characters.
</p>
]]></summary>
        <parameters>
          <param id="p.mbsrtowcs.dest" name="dest" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination buffer for wide characters. May be NULL to query required length.</p>
]]></description>
          </param>
          <param id="p.mbsrtowcs.src" name="src" direction="inout" type="const char **">
            <description><![CDATA[
<p>
Pointer to the input pointer. On success, updated to point after the last converted byte, or set to NULL if the terminator was converted.
</p>
]]></description>
            <constraints>
              <constraint id="c.mbsrtowcs.src_nonnull" severity="important">
                <description><![CDATA[
<p><code>src</code> must not be NULL, and <code>*src</code> must point to a valid NUL-terminated multibyte string.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.mbsrtowcs.len" name="len" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of wide characters to store in <code>dest</code>.</p>
]]></description>
          </param>
          <param id="p.mbsrtowcs.ps" name="ps" direction="inout" type="mbstate_t *">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Number of wide characters written (excluding the terminating wide NUL). Returns (size_t)-1 on encoding error.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcsrtombs" name="wcsrtombs" kind="function">
        <signature>size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps);</signature>
        <summary><![CDATA[
<p>
Converts a wide string starting at <code>*src</code> into multibyte characters. Updates <code>*src</code> as input is consumed.
Stops after converting the terminating wide NUL or after producing <code>len</code> bytes.
</p>
]]></summary>
        <parameters>
          <param id="p.wcsrtombs.dest" name="dest" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer for multibyte bytes. May be NULL to query required length.</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.src" name="src" direction="inout" type="const wchar_t **">
            <description><![CDATA[
<p>
Pointer to the wide input pointer. On success, updated similarly to <code>mbsrtowcs</code>, potentially set to NULL when terminator is converted.
</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.len" name="len" direction="in" type="size_t">
            <description><![CDATA[
<p>Maximum number of bytes to store in <code>dest</code>.</p>
]]></description>
          </param>
          <param id="p.wcsrtombs.ps" name="ps" direction="inout" type="mbstate_t *">
            <description><![CDATA[
<p>Pointer to conversion state; if NULL, an internal static state may be used.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>
Number of bytes written (excluding the terminating NUL). Returns (size_t)-1 on encoding error.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.swprintf" name="swprintf" kind="function">
        <signature>int swprintf(wchar_t *s, size_t n, const wchar_t *format, ...);</signature>
        <summary><![CDATA[
<p>Formats wide output according to <code>format</code> and writes into <code>s</code>, writing at most <code>n</code> wide characters including terminator.</p>
]]></summary>
        <parameters>
          <param id="p.swprintf.s" name="s" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination wide buffer.</p>
]]></description>
          </param>
          <param id="p.swprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in wide characters, including space for the terminating wide NUL.</p>
]]></description>
            <constraints>
              <constraint id="c.swprintf.capacity" severity="important">
                <description><![CDATA[
<p>Always pass the true buffer capacity. Do not guess. This is your primary safety guarantee.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.swprintf.format" name="format" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Wide format string (printf-style). Must be NUL-terminated.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of wide characters written (excluding terminator), or a negative value on encoding/formatting error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.swprintf.format_path" lang="c99">
            <title>Build a wide string with bounded formatting</title>
            <code><![CDATA[
#include <wchar.h>

int build_message(wchar_t *buf, size_t cap, int code) {
    /* cap is in wide characters, not bytes. */
    return swprintf(buf, cap, L"status=%d", code);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.vswprintf" name="vswprintf" kind="function">
        <signature>int vswprintf(wchar_t *s, size_t n, const wchar_t *format, va_list arg);</signature>
        <summary><![CDATA[
<p>Variadic-list form of <code>swprintf</code>, writing formatted wide output into <code>s</code> with capacity <code>n</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vswprintf.s" name="s" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination wide buffer.</p>
]]></description>
          </param>
          <param id="p.vswprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in wide characters, including terminator.</p>
]]></description>
          </param>
          <param id="p.vswprintf.format" name="format" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Wide format string.</p>
]]></description>
          </param>
          <param id="p.vswprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list created with <code>va_start</code> by the caller.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of wide characters written (excluding terminator), or a negative value on error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.vswprintf.wrap" lang="c99">
            <title>Wrapper that formats from a va_list</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdarg.h>

int wfmt(wchar_t *buf, size_t cap, const wchar_t *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    int r = vswprintf(buf, cap, fmt, ap);
    va_end(ap);
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.wchar.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category list intentionally includes only the wide-string and conversion functions you specified from <code>wchar.h</code>.
Wide I/O functions (for example <code>fgetwc</code>, <code>fputwc</code>) are part of a separate I/O category.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

<script id="library-xml-2026-01-20T16-13-11-b1c0987c-1854-4b44-bf88-047f60a8b43e" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="io.file.console" name="File and console input-output (byte and wide)">
    <summary><![CDATA[
<p>
Standard I/O for files and streams: opening/closing, buffered reads and writes, seeking, temporary files, buffering control,
formatted I/O, and basic console helpers. The wide I/O subset provides the analogous operations for wide characters and wide strings.
</p>
<p>
Use these APIs for portable file and console I/O. Prefer bounded operations where available (for example <code>snprintf</code>,
explicit buffer sizes, and checked return values). Treat all I/O as fallible: check for NULL pointers, EOF, short reads/writes,
and error returns. Be explicit about text vs binary modes when portability matters (for example, use "rb"/"wb" on platforms where
they differ).
</p>
]]></summary>

    <keywords>
      <kw>stdio</kw>
      <kw>FILE</kw>
      <kw>stream</kw>
      <kw>buffering</kw>
      <kw>fopen</kw>
      <kw>fread</kw>
      <kw>fwrite</kw>
      <kw>fgets</kw>
      <kw>printf</kw>
      <kw>snprintf</kw>
      <kw>tmpfile</kw>
      <kw>seek</kw>
      <kw>wide</kw>
      <kw>wchar</kw>
    </keywords>

    <notes>
      <note id="n.io.text_vs_binary" severity="important" topic="portability">
        <description><![CDATA[
<p>
On some platforms, text and binary modes differ (for example newline translation). Use "rb"/"wb" if you need byte-exact behavior.
</p>
]]></description>
      </note>
      <note id="n.io.buffering" severity="important" topic="buffering">
        <description><![CDATA[
<p>
Most streams are buffered. Output may not appear until a flush, newline, buffer fill, or close. Use <code>fflush</code> to force output.
</p>
]]></description>
      </note>
      <note id="n.io.errors" severity="important" topic="error_handling">
        <description><![CDATA[
<p>
Many functions signal failure via NULL, EOF, or a negative value. Always check return values. For diagnosing errors, the
<code>errno</code> value is commonly set and <code>perror</code> can print a message based on it.
</p>
]]></description>
      </note>
      <note id="n.io.partial_io" severity="important" topic="short_reads_writes">
        <description><![CDATA[
<p>
Short reads and short writes are normal for many streams. <code>fread</code> and <code>fwrite</code> return counts and may be less than requested.
You must loop if you require "all bytes" semantics.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.stdio" name="stdio.h">
      <summary><![CDATA[
<p>
Byte-oriented stream I/O based on <code>FILE *</code> streams. Includes file operations, buffering control, formatted output,
and basic character and line I/O.
</p>
]]></summary>

      <function id="fn.fopen" name="fopen" kind="function">
        <signature>FILE *fopen(const char *filename, const char *mode);</signature>
        <summary><![CDATA[
<p>Opens a file and returns a stream handle, or NULL on failure.</p>
]]></summary>
        <parameters>
          <param id="p.fopen.filename" name="filename" direction="in" type="const char *">
            <description><![CDATA[
<p>Path to the file to open. Must be a NUL-terminated string.</p>
]]></description>
          </param>
          <param id="p.fopen.mode" name="mode" direction="in" type="const char *">
            <description><![CDATA[
<p>
Open mode string, such as "r", "w", "a", optionally with "+" and optionally with "b" (for example "rb", "w+b").
Mode details are defined by the C standard with some implementation-defined extensions.
</p>
]]></description>
            <constraints>
              <constraint id="c.fopen.mode_valid" severity="important">
                <description><![CDATA[
<p>Pass a valid mode string. If you need byte-exact I/O portability, include "b" where supported.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="FILE *">
            <description><![CDATA[
<p>Stream pointer on success, NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fopen.read_all_bytes" lang="c99">
            <title>Open in binary mode and read entire file into memory</title>
            <code><![CDATA[
#include <stdio.h>
#include <stdlib.h>

unsigned char *read_entire_file(const char *path, size_t *out_size) {
    *out_size = 0;

    FILE *f = fopen(path, "rb");
    if (!f) return NULL;

    if (fseek(f, 0, SEEK_END) != 0) {
        fclose(f);
        return NULL;
    }

    long end = ftell(f);
    if (end < 0) {
        fclose(f);
        return NULL;
    }
    if (fseek(f, 0, SEEK_SET) != 0) {
        fclose(f);
        return NULL;
    }

    size_t n = (size_t)end;
    unsigned char *buf = (unsigned char *)malloc(n ? n : 1u);
    if (!buf) {
        fclose(f);
        return NULL;
    }

    size_t got = fread(buf, 1u, n, f);
    if (got != n) {
        free(buf);
        fclose(f);
        return NULL;
    }

    fclose(f);
    *out_size = n;
    return buf;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fclose" name="fclose" kind="function">
        <signature>int fclose(FILE *stream);</signature>
        <summary><![CDATA[
<p>Flushes and closes a stream. After this call, <code>stream</code> must not be used.</p>
]]></summary>
        <parameters>
          <param id="p.fclose.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Open stream pointer. Passing NULL is invalid.</p>
]]></description>
            <constraints>
              <constraint id="c.fclose.nonnull" severity="important">
                <description><![CDATA[
<p><code>stream</code> must be a valid open stream pointer.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, EOF on failure (for example if a flush fails).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fclose.failure" severity="important" topic="write_errors">
            <description><![CDATA[
<p>On output streams, check <code>fclose</code> return value because buffered data may fail to flush at close time.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fflush" name="fflush" kind="function">
        <signature>int fflush(FILE *stream);</signature>
        <summary><![CDATA[
<p>Flushes buffered output for <code>stream</code>. If <code>stream</code> is NULL, flushes all open output streams.</p>
]]></summary>
        <parameters>
          <param id="p.fflush.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream to flush, or NULL to flush all output streams.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, EOF on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fflush.input" severity="info" topic="input_streams">
            <description><![CDATA[
<p>Flushing input streams has implementation-defined behavior. Use <code>fflush</code> primarily for output streams.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fread" name="fread" kind="function">
        <signature>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</signature>
        <summary><![CDATA[
<p>Reads up to <code>nmemb</code> items of size <code>size</code> into <code>ptr</code> from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fread.ptr" name="ptr" direction="out" type="void *">
            <description><![CDATA[
<p>Destination buffer with room for <code>size * nmemb</code> bytes.</p>
]]></description>
          </param>
          <param id="p.fread.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Item size in bytes. If 0, no bytes are read and 0 is returned.</p>
]]></description>
          </param>
          <param id="p.fread.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of items to read. If 0, no bytes are read and 0 is returned.</p>
]]></description>
            <constraints>
              <constraint id="c.fread.overflow" severity="important">
                <description><![CDATA[
<p>Ensure <code>size * nmemb</code> does not overflow and matches the destination capacity.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fread.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of items successfully read (not bytes). If less than <code>nmemb</code>, either EOF occurred or an error occurred.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fread.loop_exact" lang="c99">
            <title>Read exactly N bytes by looping</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int read_exact(FILE *f, void *buf, size_t n) {
    unsigned char *p = (unsigned char *)buf;
    size_t off = 0;

    while (off < n) {
        size_t got = fread(p + off, 1u, n - off, f);
        if (got == 0) {
            /* EOF or error; caller can consult errno or other diagnostics if desired. */
            return 0;
        }
        off += got;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fwrite" name="fwrite" kind="function">
        <signature>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</signature>
        <summary><![CDATA[
<p>Writes up to <code>nmemb</code> items of size <code>size</code> from <code>ptr</code> to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fwrite.ptr" name="ptr" direction="in" type="const void *">
            <description><![CDATA[
<p>Source buffer containing <code>size * nmemb</code> bytes.</p>
]]></description>
          </param>
          <param id="p.fwrite.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Item size in bytes. If 0, no bytes are written and 0 is returned.</p>
]]></description>
          </param>
          <param id="p.fwrite.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of items to write. If 0, no bytes are written and 0 is returned.</p>
]]></description>
            <constraints>
              <constraint id="c.fwrite.overflow" severity="important">
                <description><![CDATA[
<p>Ensure <code>size * nmemb</code> does not overflow and reflects the actual buffer size.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fwrite.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of items successfully written. If less than <code>nmemb</code>, an error occurred.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fwrite.loop_exact" lang="c99">
            <title>Write exactly N bytes by looping and flushing at the end</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int write_exact(FILE *f, const void *buf, size_t n) {
    const unsigned char *p = (const unsigned char *)buf;
    size_t off = 0;

    while (off < n) {
        size_t put = fwrite(p + off, 1u, n - off, f);
        if (put == 0) {
            return 0;
        }
        off += put;
    }

    /* Optional: force output now rather than later. */
    if (fflush(f) == EOF) {
        return 0;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fseek" name="fseek" kind="function">
        <signature>int fseek(FILE *stream, long offset, int whence);</signature>
        <summary><![CDATA[
<p>Moves the file position indicator for <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fseek.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream to seek.</p>
]]></description>
          </param>
          <param id="p.fseek.offset" name="offset" direction="in" type="long">
            <description><![CDATA[
<p>Offset in bytes relative to <code>whence</code>.</p>
]]></description>
          </param>
          <param id="p.fseek.whence" name="whence" direction="in" type="int">
            <description><![CDATA[
<p>One of <code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fseek.text_streams" severity="info" topic="text_streams">
            <description><![CDATA[
<p>
Seeking in text streams can have restrictions on some platforms. For portable random access, prefer binary mode where appropriate.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.ftell" name="ftell" kind="function">
        <signature>long ftell(FILE *stream);</signature>
        <summary><![CDATA[
<p>Returns the current file position indicator for <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ftell.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream to query.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Current position as a <code>long</code>, or -1L on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ftell.limit" severity="info" topic="large_files">
            <description><![CDATA[
<p>
Because the return type is <code>long</code>, very large file offsets may not be representable on some platforms.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.rewind" name="rewind" kind="function">
        <signature>void rewind(FILE *stream);</signature>
        <summary><![CDATA[
<p>Sets the file position to the beginning of the stream and clears error indicators.</p>
]]></summary>
        <parameters>
          <param id="p.rewind.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream to rewind.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value. If you need error reporting, use <code>fseek(stream, 0, SEEK_SET)</code> and check the result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.remove" name="remove" kind="function">
        <signature>int remove(const char *filename);</signature>
        <summary><![CDATA[
<p>Deletes the named file (or removes a directory where supported by the implementation).</p>
]]></summary>
        <parameters>
          <param id="p.remove.filename" name="filename" direction="in" type="const char *">
            <description><![CDATA[
<p>Path to remove.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rename" name="rename" kind="function">
        <signature>int rename(const char *oldname, const char *newname);</signature>
        <summary><![CDATA[
<p>Renames a file. Semantics around overwriting and cross-filesystem moves are implementation-defined.</p>
]]></summary>
        <parameters>
          <param id="p.rename.oldname" name="oldname" direction="in" type="const char *">
            <description><![CDATA[
<p>Existing path.</p>
]]></description>
          </param>
          <param id="p.rename.newname" name="newname" direction="in" type="const char *">
            <description><![CDATA[
<p>New path.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.rename.atomicity" severity="info" topic="atomicity">
            <description><![CDATA[
<p>
Atomicity is not guaranteed by the C standard. If you need atomic replace semantics, document platform expectations explicitly.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.tmpfile" name="tmpfile" kind="function">
        <signature>FILE *tmpfile(void);</signature>
        <summary><![CDATA[
<p>Creates a temporary binary file opened for update ("wb+"). The file is removed automatically when closed.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="FILE *">
            <description><![CDATA[
<p>Stream pointer on success, NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.tmpfile.spool" lang="c99">
            <title>Spool data to a temporary file and then read it back</title>
            <code><![CDATA[
#include <stdio.h>
#include <string.h>

int roundtrip_temp(void) {
    FILE *t = tmpfile();
    if (!t) return 0;

    const char msg[] = "hello\n";
    if (fwrite(msg, 1u, sizeof(msg) - 1u, t) != sizeof(msg) - 1u) {
        fclose(t);
        return 0;
    }

    rewind(t);

    char buf[16];
    if (!fgets(buf, (int)sizeof(buf), t)) {
        fclose(t);
        return 0;
    }

    fclose(t);
    return (strcmp(buf, "hello\n") == 0) ? 1 : 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.tmpnam" name="tmpnam" kind="function">
        <signature>char *tmpnam(char *s);</signature>
        <summary><![CDATA[
<p>Generates a name for a temporary file. The result is a string; the file is not created.</p>
]]></summary>
        <parameters>
          <param id="p.tmpnam.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Optional destination buffer (at least <code>L_tmpnam</code> bytes). If NULL, returns a pointer to internal static storage.</p>
]]></description>
            <constraints>
              <constraint id="c.tmpnam.race" severity="warning">
                <description><![CDATA[
<p>
Temporary name generation without creating the file is inherently vulnerable to race conditions. Prefer <code>tmpfile</code> when possible.
</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the generated name (either <code>s</code> or internal storage), or NULL on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.setvbuf" name="setvbuf" kind="function">
        <signature>int setvbuf(FILE *stream, char *buf, int mode, size_t size);</signature>
        <summary><![CDATA[
<p>Controls buffering for a stream. Must be called before I/O on the stream (other than possible initial open operations).</p>
]]></summary>
        <parameters>
          <param id="p.setvbuf.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream whose buffering behavior is to be configured.</p>
]]></description>
          </param>
          <param id="p.setvbuf.buf" name="buf" direction="in" type="char *">
            <description><![CDATA[
<p>
User-provided buffer, or NULL to have the implementation allocate one. If provided, it must remain valid until buffering is changed again or the stream is closed.
</p>
]]></description>
          </param>
          <param id="p.setvbuf.mode" name="mode" direction="in" type="int">
            <description><![CDATA[
<p>One of <code>_IOFBF</code> (full), <code>_IOLBF</code> (line), <code>_IONBF</code> (none).</p>
]]></description>
          </param>
          <param id="p.setvbuf.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Buffer size in bytes (meaningful for buffered modes).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.setvbuf.timing" severity="important" topic="when_to_call">
            <description><![CDATA[
<p>Call <code>setvbuf</code> immediately after opening a stream, before any reads or writes, to avoid implementation-defined behavior.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.setvbuf.line_buffer_stdout" lang="c99">
            <title>Force line buffering for stdout when writing to a console</title>
            <code><![CDATA[
#include <stdio.h>

void configure_stdout(void) {
    /* If this fails, program can still proceed with default buffering. */
    (void)setvbuf(stdout, NULL, _IOLBF, 0);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.setbuf" name="setbuf" kind="function">
        <signature>void setbuf(FILE *stream, char *buf);</signature>
        <summary><![CDATA[
<p>Legacy buffering helper: equivalent to <code>setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ)</code>.</p>
]]></summary>
        <parameters>
          <param id="p.setbuf.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Stream to configure.</p>
]]></description>
          </param>
          <param id="p.setbuf.buf" name="buf" direction="in" type="char *">
            <description><![CDATA[
<p>User buffer of at least <code>BUFSIZ</code> bytes, or NULL to disable buffering.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value. Use <code>setvbuf</code> if you need error reporting or precise control.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fprintf" name="fprintf" kind="function">
        <signature>int fprintf(FILE *stream, const char *format, ...);</signature>
        <summary><![CDATA[
<p>Writes formatted output to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fprintf.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
          <param id="p.fprintf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string. Must be NUL-terminated.</p>
]]></description>
            <constraints>
              <constraint id="c.printf.format_security" severity="important">
                <description><![CDATA[
<p>Never pass untrusted input as the format string. Use a fixed format and pass untrusted data as arguments.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of characters printed, or a negative value on output error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.printf" name="printf" kind="function">
        <signature>int printf(const char *format, ...);</signature>
        <summary><![CDATA[
<p>Writes formatted output to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.printf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Number of characters printed, or a negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.snprintf" name="snprintf" kind="function">
        <signature>int snprintf(char *s, size_t n, const char *format, ...);</signature>
        <summary><![CDATA[
<p>Formats into a byte buffer of capacity <code>n</code>, ensuring at most <code>n</code> bytes are written including the terminating NUL.</p>
]]></summary>
        <parameters>
          <param id="p.snprintf.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer. May be NULL if <code>n</code> is 0 to query required size.</p>
]]></description>
          </param>
          <param id="p.snprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in bytes, including space for the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.snprintf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>
Number of characters that would have been written excluding the terminating NUL. If the return value is at least <code>n</code>,
output was truncated. A negative value indicates an encoding or output error.
</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.snprintf.safe_build" lang="c99">
            <title>Build a message with truncation detection</title>
            <code><![CDATA[
#include <stdio.h>
#include <stddef.h>

int build_msg(char *buf, size_t cap, const char *name, int code) {
    int r = snprintf(buf, cap, "name=%s code=%d", name, code);
    if (r < 0) return 0;
    if ((size_t)r >= cap) {
        /* Truncated. Caller can allocate more if needed. */
        return 0;
    }
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.vfprintf" name="vfprintf" kind="function">
        <signature>int vfprintf(FILE *stream, const char *format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>fprintf</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vfprintf.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
          <param id="p.vfprintf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vfprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list from <code>va_start</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Characters printed, or negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.vprintf" name="vprintf" kind="function">
        <signature>int vprintf(const char *format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>printf</code>, writing to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vprintf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Characters printed, or negative value on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.vsnprintf" name="vsnprintf" kind="function">
        <signature>int vsnprintf(char *s, size_t n, const char *format, va_list arg);</signature>
        <summary><![CDATA[
<p>Varargs-list form of <code>snprintf</code>.</p>
]]></summary>
        <parameters>
          <param id="p.vsnprintf.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer (may be NULL if <code>n</code> is 0 to query size).</p>
]]></description>
          </param>
          <param id="p.vsnprintf.n" name="n" direction="in" type="size_t">
            <description><![CDATA[
<p>Buffer capacity in bytes.</p>
]]></description>
          </param>
          <param id="p.vsnprintf.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>Format string.</p>
]]></description>
          </param>
          <param id="p.vsnprintf.arg" name="arg" direction="in" type="va_list">
            <description><![CDATA[
<p>Argument list.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Would-have-written count excluding NUL, truncated if >= n, negative on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputs" name="fputs" kind="function">
        <signature>int fputs(const char *s, FILE *stream);</signature>
        <summary><![CDATA[
<p>Writes a NUL-terminated string to <code>stream</code> (does not automatically append a newline).</p>
]]></summary>
        <parameters>
          <param id="p.fputs.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to write (terminator is not written).</p>
]]></description>
          </param>
          <param id="p.fputs.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.puts" name="puts" kind="function">
        <signature>int puts(const char *s);</signature>
        <summary><![CDATA[
<p>Writes a string to <code>stdout</code> followed by a newline.</p>
]]></summary>
        <parameters>
          <param id="p.puts.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated string to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputc" name="fputc" kind="function">
        <signature>int fputc(int c, FILE *stream);</signature>
        <summary><![CDATA[
<p>Writes a byte (converted to unsigned char) to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fputc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write, passed as int.</p>
]]></description>
          </param>
          <param id="p.fputc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character (as unsigned char promoted to int) on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putc" name="putc" kind="function_or_macro">
        <signature>int putc(int c, FILE *stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fputc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.putc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write.</p>
]]></description>
          </param>
          <param id="p.putc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putchar" name="putchar" kind="function_or_macro">
        <signature>int putchar(int c);</signature>
        <summary><![CDATA[
<p>Writes a byte to <code>stdout</code>. Often implemented as a macro calling <code>putc(c, stdout)</code>.</p>
]]></summary>
        <parameters>
          <param id="p.putchar.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte value to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Written character on success, EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fgets" name="fgets" kind="function">
        <signature>char *fgets(char *s, int n, FILE *stream);</signature>
        <summary><![CDATA[
<p>
Reads at most <code>n - 1</code> bytes into <code>s</code> from <code>stream</code>, stopping after a newline or EOF, and NUL-terminates.
If a newline is read, it is included in the buffer.
</p>
]]></summary>
        <parameters>
          <param id="p.fgets.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer to receive the line, NUL-terminated on success.</p>
]]></description>
          </param>
          <param id="p.fgets.n" name="n" direction="in" type="int">
            <description><![CDATA[
<p>Buffer capacity in bytes. Must be greater than 0 for a useful read.</p>
]]></description>
            <constraints>
              <constraint id="c.fgets.n_positive" severity="important">
                <description><![CDATA[
<p>If <code>n</code> is 0 or negative, behavior is undefined or implementation-defined. Pass a positive size.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fgets.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Returns <code>s</code> on success. Returns NULL if no characters were read due to EOF or error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fgets.read_lines" lang="c99">
            <title>Read lines safely and detect truncation</title>
            <code><![CDATA[
#include <stdio.h>
#include <string.h>

void read_lines(FILE *in) {
    char buf[256];

    while (fgets(buf, (int)sizeof(buf), in)) {
        size_t len = strlen(buf);

        /* If no newline and buffer filled, the line may be longer than the buffer. */
        if (len > 0 && buf[len - 1u] != '\n' && len == sizeof(buf) - 1u) {
            /* Truncated line fragment. Handle continuation if needed. */
        }

        /* Process buf (includes newline if present). */
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fgetc" name="fgetc" kind="function">
        <signature>int fgetc(FILE *stream);</signature>
        <summary><![CDATA[
<p>Reads the next byte from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fgetc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Returns the byte as an unsigned char converted to int, or EOF on end-of-file or error.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fgetc.eof" severity="important" topic="eof_vs_byte">
            <description><![CDATA[
<p>
Because valid bytes are 0..UCHAR_MAX and EOF is negative, always store the result in an <code>int</code>, not a <code>char</code>.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.getc" name="getc" kind="function_or_macro">
        <signature>int getc(FILE *stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fgetc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.getc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Next byte as unsigned char promoted to int, or EOF.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getchar" name="getchar" kind="function_or_macro">
        <signature>int getchar(void);</signature>
        <summary><![CDATA[
<p>Reads the next byte from <code>stdin</code>. Often implemented as a macro calling <code>getc(stdin)</code>.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Next byte as unsigned char promoted to int, or EOF.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ungetc" name="ungetc" kind="function">
        <signature>int ungetc(int c, FILE *stream);</signature>
        <summary><![CDATA[
<p>
Pushes a byte back onto the input stream so it will be returned by the next read operation.
This is commonly used for one-character lookahead in parsers.
</p>
]]></summary>
        <parameters>
          <param id="p.ungetc.c" name="c" direction="in" type="int">
            <description><![CDATA[
<p>Byte to push back. If <code>c</code> is EOF, the operation fails and EOF is returned.</p>
]]></description>
          </param>
          <param id="p.ungetc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream to push back onto.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Returns the pushed-back character on success, EOF on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ungetc.guarantee" severity="info" topic="pushback_depth">
            <description><![CDATA[
<p>
The standard guarantees at least one character of pushback if <code>c</code> is not EOF. Additional pushbacks may work but are implementation-defined.
</p>
]]></description>
          </note>
          <note id="n.ungetc.buffering" severity="important" topic="stream_position">
            <description><![CDATA[
<p>After pushing back a character, the file position and buffering semantics can be subtle. Use it narrowly for lookahead.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.ungetc.peek_nonspace" lang="c99">
            <title>Skip whitespace then put back the first non-space byte</title>
            <code><![CDATA[
#include <stdio.h>
#include <ctype.h>

int skip_spaces_and_peek(FILE *in) {
    int ch;
    do {
        ch = fgetc(in);
        if (ch == EOF) return EOF;
    } while (isspace((unsigned char)ch));

    /* Put it back so caller can read it again. */
    if (ungetc(ch, in) == EOF) return EOF;
    return ch;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.perror" name="perror" kind="function">
        <signature>void perror(const char *s);</signature>
        <summary><![CDATA[
<p>Prints <code>s</code>, a colon and space (implementation-defined formatting), and a message corresponding to the current <code>errno</code>, then a newline.</p>
]]></summary>
        <parameters>
          <param id="p.perror.s" name="s" direction="in" type="const char *">
            <description><![CDATA[
<p>Prefix string. If NULL or empty, an implementation-defined behavior prints just the error message.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.perror.errno" severity="important" topic="diagnostics">
            <description><![CDATA[
<p>
Call <code>perror</code> soon after the failing operation, before another library call can change <code>errno</code>.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.perror.open_fail" lang="c99">
            <title>Diagnose a failed fopen</title>
            <code><![CDATA[
#include <stdio.h>

int try_open(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) {
        perror("fopen");
        return 0;
    }
    fclose(f);
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.stdio.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This category includes the stdio.h functions you specified. Other standard stdio facilities exist (for example <code>feof</code>, <code>ferror</code>,
<code>clearerr</code>, <code>fscanf</code>, <code>fgets</code> variants, and more) and can be added as separate entries if desired.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.wchar_wide_io" name="wchar.h (wide I/O subset)">
      <summary><![CDATA[
<p>
Wide-character I/O functions that mirror basic stdio operations for wide characters and wide strings. These functions operate on <code>FILE *</code>
streams but read and write <code>wchar_t</code> data (via <code>wint_t</code> return types where EOF must be representable).
</p>
]]></summary>

      <notes>
        <note id="n.wideio.weof" severity="important" topic="weof">
          <description><![CDATA[
<p>
Wide character input functions return <code>wint_t</code> and use <code>WEOF</code> to signal end-of-file or error. Store results in <code>wint_t</code>.
</p>
]]></description>
        </note>
        <note id="n.wideio.locale" severity="important" topic="locale">
          <description><![CDATA[
<p>
Wide I/O interpretation depends on the current locale and the stream orientation. Document your locale assumptions when portability matters.
</p>
]]></description>
        </note>
      </notes>

      <function id="fn.fgetwc" name="fgetwc" kind="function">
        <signature>wint_t fgetwc(FILE *stream);</signature>
        <summary><![CDATA[
<p>Reads the next wide character from <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fgetwc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character as <code>wint_t</code>, or <code>WEOF</code> on end-of-file or error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fputwc" name="fputwc" kind="function">
        <signature>wint_t fputwc(wchar_t wc, FILE *stream);</signature>
        <summary><![CDATA[
<p>Writes wide character <code>wc</code> to <code>stream</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fputwc.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
          <param id="p.fputwc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character (as <code>wint_t</code>) on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getwc" name="getwc" kind="function_or_macro">
        <signature>wint_t getwc(FILE *stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fgetwc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.getwc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character, or <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putwc" name="putwc" kind="function_or_macro">
        <signature>wint_t putwc(wchar_t wc, FILE *stream);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>fputwc</code> but may be implemented as a macro.</p>
]]></summary>
        <parameters>
          <param id="p.putwc.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
          <param id="p.putwc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.getwchar" name="getwchar" kind="function_or_macro">
        <signature>wint_t getwchar(void);</signature>
        <summary><![CDATA[
<p>Reads the next wide character from <code>stdin</code>.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Next wide character, or <code>WEOF</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.putwchar" name="putwchar" kind="function_or_macro">
        <signature>wint_t putwchar(wchar_t wc);</signature>
        <summary><![CDATA[
<p>Writes wide character <code>wc</code> to <code>stdout</code>.</p>
]]></summary>
        <parameters>
          <param id="p.putwchar.wc" name="wc" direction="in" type="wchar_t">
            <description><![CDATA[
<p>Wide character to write.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Written wide character on success, or <code>WEOF</code> on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fgetws" name="fgetws" kind="function">
        <signature>wchar_t *fgetws(wchar_t *s, int n, FILE *stream);</signature>
        <summary><![CDATA[
<p>
Reads at most <code>n - 1</code> wide characters into <code>s</code>, stopping after a newline or EOF, and NUL-terminates.
If a newline is read, it is included.
</p>
]]></summary>
        <parameters>
          <param id="p.fgetws.s" name="s" direction="out" type="wchar_t *">
            <description><![CDATA[
<p>Destination wide buffer to receive the line.</p>
]]></description>
          </param>
          <param id="p.fgetws.n" name="n" direction="in" type="int">
            <description><![CDATA[
<p>Capacity in wide characters. Must be positive.</p>
]]></description>
          </param>
          <param id="p.fgetws.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wchar_t *">
            <description><![CDATA[
<p>Returns <code>s</code> on success, NULL if no characters were read due to EOF or error.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fgetws.read_wlines" lang="c99">
            <title>Read wide lines safely</title>
            <code><![CDATA[
#include <wchar.h>
#include <stdio.h>

void read_wlines(FILE *in) {
    wchar_t buf[256];

    while (fgetws(buf, (int)(sizeof(buf) / sizeof(buf[0])), in)) {
        /* Process buf; it includes newline if present. */
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fputws" name="fputws" kind="function">
        <signature>int fputws(const wchar_t *s, FILE *stream);</signature>
        <summary><![CDATA[
<p>Writes a NUL-terminated wide string to <code>stream</code> (does not automatically append a newline).</p>
]]></summary>
        <parameters>
          <param id="p.fputws.s" name="s" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Wide string to write (terminator is not written).</p>
]]></description>
          </param>
          <param id="p.fputws.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Output stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Non-negative on success, or EOF on error.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ungetwc" name="ungetwc" kind="function">
        <signature>wint_t ungetwc(wint_t wc, FILE *stream);</signature>
        <summary><![CDATA[
<p>Pushes a wide character back onto the input stream so it will be returned by the next wide read.</p>
]]></summary>
        <parameters>
          <param id="p.ungetwc.wc" name="wc" direction="in" type="wint_t">
            <description><![CDATA[
<p>Wide character to push back. If <code>wc</code> is <code>WEOF</code>, the operation fails.</p>
]]></description>
          </param>
          <param id="p.ungetwc.stream" name="stream" direction="in" type="FILE *">
            <description><![CDATA[
<p>Input stream.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="wint_t">
            <description><![CDATA[
<p>Pushed-back character on success, or <code>WEOF</code> on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ungetwc.guarantee" severity="info" topic="pushback_depth">
            <description><![CDATA[
<p>As with <code>ungetc</code>, only limited pushback is guaranteed by the standard. Use narrowly for lookahead.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wideio.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes only the wide I/O functions you specified. The full <code>wchar.h</code> header also contains wide string and conversion
functions that belong in the strings/raw-memory category.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

<script id="library-xml-2026-01-20T16-15-03-9e1ddf04-13fc-4758-8da1-3e099d111f9b" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="numeric.parsing.formatting.utilities" name="Numeric parsing, integer formatting helpers, and general utilities">
    <summary><![CDATA[
<p>
Core runtime services and numeric conversion helpers: memory allocation and cleanup, program termination hooks,
environment queries, pseudo-random number generation, robust numeric parsing from strings, and generic searching/sorting.
This category also includes integer-width portable parsing helpers from <code>inttypes.h</code> for maximum-width integers.
</p>
<p>
Treat these APIs as low-level building blocks. Prefer explicit error checking for all conversions and allocations,
avoid undefined behavior from overflow, and be careful with process-wide side effects (environment variables, <code>system</code>,
global PRNG state, and exit handlers). For conversions, prefer the <code>strto*</code> family over <code>atoi</code>-style functions
because the <code>strto*</code> functions provide error detection and end-pointer reporting.
</p>
]]></summary>

    <keywords>
      <kw>stdlib</kw>
      <kw>inttypes</kw>
      <kw>malloc</kw>
      <kw>free</kw>
      <kw>realloc</kw>
      <kw>calloc</kw>
      <kw>exit</kw>
      <kw>atexit</kw>
      <kw>getenv</kw>
      <kw>system</kw>
      <kw>rand</kw>
      <kw>srand</kw>
      <kw>strtol</kw>
      <kw>strtoll</kw>
      <kw>strtoul</kw>
      <kw>strtoull</kw>
      <kw>strtod</kw>
      <kw>qsort</kw>
      <kw>bsearch</kw>
      <kw>strtoimax</kw>
      <kw>strtoumax</kw>
    </keywords>

    <notes>
      <note id="n.numeric.alloc_overflow" severity="important" topic="allocation_overflow">
        <description><![CDATA[
<p>
When computing allocation sizes, guard against overflow in <code>count * size</code>. Overflow can wrap to a small value,
leading to undersized allocations and out-of-bounds writes.
</p>
]]></description>
      </note>
      <note id="n.numeric.conversion_errno" severity="important" topic="strto_error_handling">
        <description><![CDATA[
<p>
For <code>strto*</code> conversions, set <code>errno = 0</code> before the call and then check:
(1) whether the end pointer advanced (at least one digit/char converted),
(2) whether <code>errno == ERANGE</code> to detect overflow/underflow,
(3) whether there is unexpected trailing text.
</p>
]]></description>
      </note>
      <note id="n.numeric.prng_quality" severity="warning" topic="rand_quality">
        <description><![CDATA[
<p>
<code>rand</code>/<code>srand</code> provide a simple pseudo-random generator with implementation-defined quality and period.
Do not use for security-sensitive randomness. For non-security uses, document your seeding and distribution approach.
</p>
]]></description>
      </note>
      <note id="n.numeric.qsort_cmp" severity="important" topic="qsort_comparator">
        <description><![CDATA[
<p>
The comparator for <code>qsort</code>/<code>bsearch</code> must define a strict weak ordering and must not overflow.
Prefer comparisons using relational operators rather than subtracting integers.
</p>
]]></description>
      </note>
      <note id="n.numeric.system_side_effects" severity="warning" topic="system">
        <description><![CDATA[
<p>
<code>system</code> invokes a command processor with environment-dependent semantics and security implications.
Avoid on untrusted input. Prefer dedicated APIs outside the C standard library for controlled process execution.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.stdlib" name="stdlib.h">
      <summary><![CDATA[
<p>
General utilities: dynamic memory management, program termination and cleanup hooks, environment queries, command execution,
pseudo-random numbers, numeric parsing, absolute value helpers, quotient/remainder helpers, and generic algorithms.
</p>
]]></summary>

      <function id="fn.malloc" name="malloc" kind="function">
        <signature>void *malloc(size_t size);</signature>
        <summary><![CDATA[
<p>Allocates <code>size</code> bytes of uninitialized storage.</p>
]]></summary>
        <parameters>
          <param id="p.malloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of bytes to allocate.</p>
]]></description>
            <constraints>
              <constraint id="c.malloc.zero" severity="info">
                <description><![CDATA[
<p>If <code>size</code> is 0, the return value may be NULL or a unique pointer that can be passed to <code>free</code>.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Pointer to allocated memory, or NULL if allocation fails.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.malloc.uninitialized" severity="important" topic="initialization">
            <description><![CDATA[
<p>The allocated bytes are uninitialized. Initialize before reading.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.malloc.allocate_array_checked" lang="c99">
            <title>Allocate an array with overflow check</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int *alloc_ints(size_t count) {
    if (count > (SIZE_MAX / sizeof(int))) {
        return NULL;
    }
    return (int *)malloc(count * sizeof(int));
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.calloc" name="calloc" kind="function">
        <signature>void *calloc(size_t nmemb, size_t size);</signature>
        <summary><![CDATA[
<p>Allocates space for <code>nmemb</code> objects of <code>size</code> bytes each and zero-initializes the result.</p>
]]></summary>
        <parameters>
          <param id="p.calloc.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements.</p>
]]></description>
          </param>
          <param id="p.calloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
            <constraints>
              <constraint id="c.calloc.overflow" severity="important">
                <description><![CDATA[
<p>Allocation size is <code>nmemb * size</code>. Guard against overflow before relying on the allocation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Pointer to zeroed storage, or NULL on failure.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.calloc.zeroed" severity="info" topic="zero_init">
            <description><![CDATA[
<p>The returned block is filled with zero bytes, which is suitable for zero-initializing many plain data types and pointers.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.realloc" name="realloc" kind="function">
        <signature>void *realloc(void *ptr, size_t size);</signature>
        <summary><![CDATA[
<p>Resizes the allocation pointed to by <code>ptr</code> to <code>size</code> bytes, possibly moving it.</p>
]]></summary>
        <parameters>
          <param id="p.realloc.ptr" name="ptr" direction="inout" type="void *">
            <description><![CDATA[
<p>Existing allocation from <code>malloc</code>/<code>calloc</code>/<code>realloc</code>, or NULL to behave like <code>malloc</code>.</p>
]]></description>
          </param>
          <param id="p.realloc.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>New size in bytes. If 0 and <code>ptr</code> is not NULL, behavior is implementation-defined (often frees and returns NULL).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Pointer to resized block (may differ from <code>ptr</code>), or NULL on failure (original block remains allocated and unchanged).</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.realloc.pattern" severity="important" topic="safe_usage">
            <description><![CDATA[
<p>Use a temporary pointer: assign the result to a new variable before updating the original pointer to avoid losing the original on failure.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.realloc.safe_grow" lang="c99">
            <title>Grow a buffer safely</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stddef.h>

int grow(void **p, size_t *cap, size_t new_cap) {
    void *tmp = realloc(*p, new_cap);
    if (!tmp && new_cap != 0) {
        return 0;
    }
    *p = tmp;
    *cap = new_cap;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.free" name="free" kind="function">
        <signature>void free(void *ptr);</signature>
        <summary><![CDATA[
<p>Frees memory allocated by <code>malloc</code>/<code>calloc</code>/<code>realloc</code>.</p>
]]></summary>
        <parameters>
          <param id="p.free.ptr" name="ptr" direction="in" type="void *">
            <description><![CDATA[
<p>Pointer to allocated memory, or NULL (a no-op).</p>
]]></description>
            <constraints>
              <constraint id="c.free.valid" severity="important">
                <description><![CDATA[
<p><code>ptr</code> must be NULL or a pointer previously returned by allocation functions and not already freed.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.free.use_after_free" severity="important" topic="lifetime">
            <description><![CDATA[
<p>After freeing, do not use the pointer value. A common defensive pattern is to set pointers to NULL after freeing.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.abort" name="abort" kind="function">
        <signature>void abort(void);</signature>
        <summary><![CDATA[
<p>Terminates the program abnormally, typically generating a diagnostic.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>Does not return.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.abort.flush" severity="info" topic="buffers">
            <description><![CDATA[
<p>Output buffers may or may not be flushed; do not rely on buffered output being written.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.exit" name="exit" kind="function">
        <signature>void exit(int status);</signature>
        <summary><![CDATA[
<p>Terminates the program normally, performing cleanup such as flushing streams and running exit handlers.</p>
]]></summary>
        <parameters>
          <param id="p.exit.status" name="status" direction="in" type="int">
            <description><![CDATA[
<p>Exit status, typically <code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>Does not return.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.exit.handlers" severity="important" topic="atexit">
            <description><![CDATA[
<p>Runs functions registered with <code>atexit</code> (in reverse registration order) and flushes/ closes standard I/O streams.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.atexit" name="atexit" kind="function">
        <signature>int atexit(void (*func)(void));</signature>
        <summary><![CDATA[
<p>Registers <code>func</code> to be called at normal program termination (via <code>exit</code> or returning from <code>main</code>).</p>
]]></summary>
        <parameters>
          <param id="p.atexit.func" name="func" direction="in" type="void (*)(void)">
            <description><![CDATA[
<p>Function pointer with signature <code>void func(void)</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.atexit.restrictions" severity="important">
                <description><![CDATA[
<p>Exit handlers should avoid complex I/O or reliance on other subsystems that may already be partially shut down.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero if registration fails (for example due to resource limits).</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.atexit.cleanup" lang="c99">
            <title>Register a simple cleanup hook</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

static void cleanup(void) {
    /* Keep cleanup small and robust. */
    fputs("cleanup\n", stderr);
}

int main(void) {
    if (atexit(cleanup) != 0) {
        fputs("atexit failed\n", stderr);
        return 1;
    }
    return 0;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.getenv" name="getenv" kind="function">
        <signature>char *getenv(const char *name);</signature>
        <summary><![CDATA[
<p>Returns the value of the environment variable <code>name</code>, or NULL if it is not set.</p>
]]></summary>
        <parameters>
          <param id="p.getenv.name" name="name" direction="in" type="const char *">
            <description><![CDATA[
<p>NUL-terminated environment variable name.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to the value string owned by the environment, or NULL if not found. The pointer may be invalidated by environment changes.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.getenv.copy" severity="important" topic="lifetime">
            <description><![CDATA[
<p>Copy the returned value if you need to keep it. Avoid modifying the returned string.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.getenv_optional" lang="c99">
            <title>Read an optional environment variable</title>
            <code><![CDATA[
#include <stdlib.h>
#include <stdio.h>

const char *get_log_level(void) {
    const char *v = getenv("LOG_LEVEL");
    return v ? v : "info";
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.system" name="system" kind="function">
        <signature>int system(const char *string);</signature>
        <summary><![CDATA[
<p>Passes <code>string</code> to the host environment command processor. If <code>string</code> is NULL, tests for command processor availability.</p>
]]></summary>
        <parameters>
          <param id="p.system.string" name="string" direction="in" type="const char *">
            <description><![CDATA[
<p>Command string to execute, or NULL to query availability.</p>
]]></description>
            <constraints>
              <constraint id="c.system.untrusted" severity="warning">
                <description><![CDATA[
<p>Do not execute untrusted or partially trusted command strings. Avoid interpolating user input into commands.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>
If <code>string</code> is NULL, returns non-zero if a command processor is available, 0 otherwise.
If executed, returns an implementation-defined status code; -1 typically indicates a failure to invoke the processor.
</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rand" name="rand" kind="function">
        <signature>int rand(void);</signature>
        <summary><![CDATA[
<p>Returns a pseudo-random integer in the range 0 to <code>RAND_MAX</code> (inclusive).</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Pseudo-random value in [0, RAND_MAX].</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.rand.uniform" severity="warning" topic="distribution">
            <description><![CDATA[
<p>
Using <code>rand() % n</code> can introduce modulo bias unless <code>n</code> divides <code>RAND_MAX + 1</code>.
If you care about uniformity, use rejection sampling.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.srand" name="srand" kind="function">
        <signature>void srand(unsigned int seed);</signature>
        <summary><![CDATA[
<p>Seeds the pseudo-random generator used by <code>rand</code>.</p>
]]></summary>
        <parameters>
          <param id="p.srand.seed" name="seed" direction="in" type="unsigned int">
            <description><![CDATA[
<p>Seed value. The mapping from seed to sequence is implementation-defined.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.rand.uniform_range" lang="c99">
            <title>Uniform random in [0, n) using rejection sampling</title>
            <code><![CDATA[
#include <stdlib.h>
#include <limits.h>

int rand_below(int n) {
    if (n <= 0) return 0;

    /* Use unsigned arithmetic to avoid overflow. */
    unsigned int bound = (unsigned int)n;
    unsigned int rmax = (unsigned int)RAND_MAX;

    /* Largest multiple of bound within [0, RAND_MAX]. */
    unsigned int limit = (rmax / bound) * bound;

    unsigned int r;
    do {
        r = (unsigned int)rand();
    } while (r >= limit);

    return (int)(r % bound);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtol" name="strtol" kind="function">
        <signature>long strtol(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed long integer from <code>nptr</code> using the given <code>base</code>, with error detection and end-pointer reporting.</p>
]]></summary>
        <parameters>
          <param id="p.strtol.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped; an optional sign is accepted.</p>
]]></description>
          </param>
          <param id="p.strtol.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>
If non-NULL, <code>*endptr</code> is set to the first character after the parsed number.
If no conversion occurs, <code>*endptr</code> is set to <code>nptr</code>.
</p>
]]></description>
          </param>
          <param id="p.strtol.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>
Base for conversion: 0, or a value from 2 to 36. If 0, base is inferred from prefixes: "0x"/"0X" for hex, leading "0" for octal, otherwise decimal.
</p>
]]></description>
            <constraints>
              <constraint id="c.strtol.base_range" severity="important">
                <description><![CDATA[
<p><code>base</code> must be 0 or in [2, 36].</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Converted value on success. On overflow/underflow, returns <code>LONG_MAX</code>/<code>LONG_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strtol.parse_checked" lang="c99">
            <title>Parse an int with full validation</title>
            <code><![CDATA[
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

int parse_int_strict(const char *s, int *out) {
    errno = 0;
    char *end = NULL;

    long v = strtol(s, &end, 10);

    if (end == s) return 0;               /* no digits */
    if (*end != '\0') return 0;           /* trailing junk */
    if (errno == ERANGE) return 0;        /* overflow/underflow */
    if (v < INT_MIN || v > INT_MAX) return 0;

    *out = (int)v;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtoll" name="strtoll" kind="function">
        <signature>long long strtoll(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed long long integer from <code>nptr</code> with the same semantics as <code>strtol</code>, but with a wider result type.</p>
]]></summary>
        <parameters>
          <param id="p.strtoll.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoll.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoll.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long long">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>LLONG_MAX</code>/<code>LLONG_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtoul" name="strtoul" kind="function">
        <signature>unsigned long strtoul(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned long integer from <code>nptr</code>, with error detection and end-pointer reporting.</p>
]]></summary>
        <parameters>
          <param id="p.strtoul.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped; an optional sign may be present (a leading '-' yields an implementation-defined converted value modulo the type).</p>
]]></description>
          </param>
          <param id="p.strtoul.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoul.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="unsigned long">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>ULONG_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtoul.negative" severity="warning" topic="sign">
            <description><![CDATA[
<p>
If you require strict non-negative input, reject a leading '-' explicitly before calling, and verify <code>endptr</code> and trailing text.
</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strtoull" name="strtoull" kind="function">
        <signature>unsigned long long strtoull(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned long long integer from <code>nptr</code>, with the same semantics as <code>strtoul</code> but a wider result type.</p>
]]></summary>
        <parameters>
          <param id="p.strtoull.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoull.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoull.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="unsigned long long">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>ULLONG_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtod" name="strtod" kind="function">
        <signature>double strtod(const char *nptr, char **endptr);</signature>
        <summary><![CDATA[
<p>Parses a double-precision floating-point value from <code>nptr</code>, with end-pointer reporting and range error signaling.</p>
]]></summary>
        <parameters>
          <param id="p.strtod.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string. Leading whitespace is skipped. Locale may affect decimal point interpretation.</p>
]]></description>
          </param>
          <param id="p.strtod.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>
Converted value. On overflow sets <code>errno</code> to <code>ERANGE</code> and returns +/-HUGE_VAL.
On underflow may set <code>errno</code> and return 0.0.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtod.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Decimal point may be locale-dependent. If you need locale-independent parsing, document assumptions or manage locale explicitly.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.strtof" name="strtof" kind="function">
        <signature>float strtof(const char *nptr, char **endptr);</signature>
        <summary><![CDATA[
<p>Parses a single-precision float from <code>nptr</code>, analogous to <code>strtod</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtof.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtof.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="float">
            <description><![CDATA[
<p>Converted value; sets <code>errno</code> to <code>ERANGE</code> on overflow/underflow as applicable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.strtold" name="strtold" kind="function">
        <signature>long double strtold(const char *nptr, char **endptr);</signature>
        <summary><![CDATA[
<p>Parses a long double from <code>nptr</code>, analogous to <code>strtod</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtold.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtold.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long double">
            <description><![CDATA[
<p>Converted value; sets <code>errno</code> to <code>ERANGE</code> on overflow/underflow as applicable.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.abs" name="abs" kind="function">
        <signature>int abs(int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of <code>j</code>.</p>
]]></summary>
        <parameters>
          <param id="p.abs.j" name="j" direction="in" type="int">
            <description><![CDATA[
<p>Input integer.</p>
]]></description>
            <constraints>
              <constraint id="c.abs.intmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>INT_MIN</code>, the absolute value may not be representable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Absolute value of <code>j</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.labs" name="labs" kind="function">
        <signature>long int labs(long int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of a long integer.</p>
]]></summary>
        <parameters>
          <param id="p.labs.j" name="j" direction="in" type="long int">
            <description><![CDATA[
<p>Input long integer.</p>
]]></description>
            <constraints>
              <constraint id="c.labs.longmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>LONG_MIN</code>, the absolute value may be unrepresentable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long int">
            <description><![CDATA[
<p>Absolute value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.llabs" name="llabs" kind="function">
        <signature>long long int llabs(long long int j);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of a long long integer.</p>
]]></summary>
        <parameters>
          <param id="p.llabs.j" name="j" direction="in" type="long long int">
            <description><![CDATA[
<p>Input long long integer.</p>
]]></description>
            <constraints>
              <constraint id="c.llabs.llongmin" severity="important">
                <description><![CDATA[
<p>If <code>j</code> is <code>LLONG_MIN</code>, the absolute value may be unrepresentable; behavior is undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long long int">
            <description><![CDATA[
<p>Absolute value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.div" name="div" kind="function">
        <signature>div_t div(int numer, int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder of integer division.</p>
]]></summary>
        <parameters>
          <param id="p.div.numer" name="numer" direction="in" type="int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.div.denom" name="denom" direction="in" type="int">
            <description><![CDATA[
<p>Denominator.</p>
]]></description>
            <constraints>
              <constraint id="c.div.zero" severity="important">
                <description><![CDATA[
<p><code>denom</code> must not be 0.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="div_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.div.signs" severity="info" topic="semantics">
            <description><![CDATA[
<p>The sign of the remainder follows the sign rules for C integer division. Use these helpers for clarity and consistency.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.div.qr" lang="c99">
            <title>Compute quotient and remainder explicitly</title>
            <code><![CDATA[
#include <stdlib.h>

int mod_positive(int x, int m) {
    div_t d = div(x, m);
    /* Example normalization to a non-negative remainder. */
    if (d.rem < 0) d.rem += (m > 0 ? m : -m);
    return d.rem;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ldiv" name="ldiv" kind="function">
        <signature>ldiv_t ldiv(long int numer, long int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder for long integer division.</p>
]]></summary>
        <parameters>
          <param id="p.ldiv.numer" name="numer" direction="in" type="long int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.ldiv.denom" name="denom" direction="in" type="long int">
            <description><![CDATA[
<p>Denominator (must not be 0).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="ldiv_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.lldiv" name="lldiv" kind="function">
        <signature>lldiv_t lldiv(long long int numer, long long int denom);</signature>
        <summary><![CDATA[
<p>Computes quotient and remainder for long long integer division.</p>
]]></summary>
        <parameters>
          <param id="p.lldiv.numer" name="numer" direction="in" type="long long int">
            <description><![CDATA[
<p>Numerator.</p>
]]></description>
          </param>
          <param id="p.lldiv.denom" name="denom" direction="in" type="long long int">
            <description><![CDATA[
<p>Denominator (must not be 0).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="lldiv_t">
            <description><![CDATA[
<p>Structure with fields <code>quot</code> and <code>rem</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.qsort" name="qsort" kind="function">
        <signature>void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</signature>
        <summary><![CDATA[
<p>Sorts an array of <code>nmemb</code> elements of size <code>size</code> using the provided comparator.</p>
]]></summary>
        <parameters>
          <param id="p.qsort.base" name="base" direction="inout" type="void *">
            <description><![CDATA[
<p>Pointer to the first element of the array to sort.</p>
]]></description>
          </param>
          <param id="p.qsort.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements in the array.</p>
]]></description>
          </param>
          <param id="p.qsort.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
          </param>
          <param id="p.qsort.compar" name="compar" direction="in" type="int (*)(const void *, const void *)">
            <description><![CDATA[
<p>
Comparator: returns &lt;0 if first element is "less", 0 if equal, &gt;0 if "greater".
Must be consistent and must impose a strict weak ordering.
</p>
]]></description>
            <constraints>
              <constraint id="c.qsort.compar_safe" severity="important">
                <description><![CDATA[
<p>Avoid subtraction-based comparisons that can overflow. Compare with relational operators.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void">
            <description><![CDATA[
<p>No return value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.qsort.int_safe_cmp" lang="c99">
            <title>Sort integers with a safe comparator</title>
            <code><![CDATA[
#include <stdlib.h>

static int cmp_int(const void *a, const void *b) {
    int x = *(const int *)a;
    int y = *(const int *)b;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

void sort_ints(int *arr, size_t n) {
    qsort(arr, n, sizeof(arr[0]), cmp_int);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.bsearch" name="bsearch" kind="function">
        <signature>void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</signature>
        <summary><![CDATA[
<p>Searches a sorted array for <code>key</code> using binary search and the provided comparator.</p>
]]></summary>
        <parameters>
          <param id="p.bsearch.key" name="key" direction="in" type="const void *">
            <description><![CDATA[
<p>Pointer to the key to search for (as interpreted by the comparator).</p>
]]></description>
          </param>
          <param id="p.bsearch.base" name="base" direction="in" type="const void *">
            <description><![CDATA[
<p>Pointer to the first element of the sorted array.</p>
]]></description>
          </param>
          <param id="p.bsearch.nmemb" name="nmemb" direction="in" type="size_t">
            <description><![CDATA[
<p>Number of elements in the array.</p>
]]></description>
          </param>
          <param id="p.bsearch.size" name="size" direction="in" type="size_t">
            <description><![CDATA[
<p>Size of each element in bytes.</p>
]]></description>
          </param>
          <param id="p.bsearch.compar" name="compar" direction="in" type="int (*)(const void *, const void *)">
            <description><![CDATA[
<p>Comparator with the same ordering as used for sorting.</p>
]]></description>
            <constraints>
              <constraint id="c.bsearch.sorted" severity="important">
                <description><![CDATA[
<p>The array must already be sorted according to <code>compar</code>. Otherwise, results are undefined.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="void *">
            <description><![CDATA[
<p>Pointer to a matching element, or NULL if not found.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.bsearch.find_int" lang="c99">
            <title>Binary search in a sorted int array</title>
            <code><![CDATA[
#include <stdlib.h>

static int cmp_int_key(const void *key, const void *elem) {
    int x = *(const int *)key;
    int y = *(const int *)elem;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

int contains_int(const int *arr, size_t n, int value) {
    return bsearch(&value, arr, n, sizeof(arr[0]), cmp_int_key) != NULL;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.stdlib.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes only the stdlib.h functions you listed: allocation, termination hooks, environment/system, rand/srand,
numeric parsing (strto*), abs/labs/llabs, div/ldiv/lldiv, qsort/bsearch. Other stdlib.h functions exist but are out of scope here.
</p>
]]></summary>
      </function>

    </header>

    <header id="hdr.inttypes" name="inttypes.h">
      <summary><![CDATA[
<p>
Portable parsing helpers for maximum-width integers. These are useful when you want the widest standard integer types
(<code>intmax_t</code>, <code>uintmax_t</code>) without choosing a specific width.
Includes both byte string and wide string variants.
</p>
]]></summary>

      <function id="fn.strtoimax" name="strtoimax" kind="function">
        <signature>intmax_t strtoimax(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed maximum-width integer from a byte string, analogous to <code>strtoll</code> but returning <code>intmax_t</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtoimax.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoimax.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting as in <code>strtol</code>.</p>
]]></description>
          </param>
          <param id="p.strtoimax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="intmax_t">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>INTMAX_MAX</code>/<code>INTMAX_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.strtoimax.strict" lang="c99">
            <title>Strict parse to intmax_t with trailing text rejection</title>
            <code><![CDATA[
#include <inttypes.h>
#include <errno.h>

int parse_intmax_strict(const char *s, intmax_t *out) {
    errno = 0;
    char *end = NULL;

    intmax_t v = strtoimax(s, &end, 10);

    if (end == s) return 0;
    if (*end != '\0') return 0;
    if (errno == ERANGE) return 0;

    *out = v;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strtoumax" name="strtoumax" kind="function">
        <signature>uintmax_t strtoumax(const char *nptr, char **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned maximum-width integer from a byte string, analogous to <code>strtoull</code> but returning <code>uintmax_t</code>.</p>
]]></summary>
        <parameters>
          <param id="p.strtoumax.nptr" name="nptr" direction="in" type="const char *">
            <description><![CDATA[
<p>Input string.</p>
]]></description>
          </param>
          <param id="p.strtoumax.endptr" name="endptr" direction="out" type="char **">
            <description><![CDATA[
<p>End pointer reporting.</p>
]]></description>
          </param>
          <param id="p.strtoumax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="uintmax_t">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>UINTMAX_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strtoumax.negative" severity="warning" topic="sign">
            <description><![CDATA[
<p>If you require strictly unsigned syntax, reject a leading '-' before calling and enforce full-consumption via <code>endptr</code>.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.wcstoimax" name="wcstoimax" kind="function">
        <signature>intmax_t wcstoimax(const wchar_t *nptr, wchar_t **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses a signed maximum-width integer from a wide string, analogous to <code>strtoimax</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcstoimax.nptr" name="nptr" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Input wide string.</p>
]]></description>
          </param>
          <param id="p.wcstoimax.endptr" name="endptr" direction="out" type="wchar_t **">
            <description><![CDATA[
<p>End pointer reporting for wide strings.</p>
]]></description>
          </param>
          <param id="p.wcstoimax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="intmax_t">
            <description><![CDATA[
<p>Converted value; on overflow/underflow returns <code>INTMAX_MAX</code>/<code>INTMAX_MIN</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.wcstoumax" name="wcstoumax" kind="function">
        <signature>uintmax_t wcstoumax(const wchar_t *nptr, wchar_t **endptr, int base);</signature>
        <summary><![CDATA[
<p>Parses an unsigned maximum-width integer from a wide string, analogous to <code>strtoumax</code>.</p>
]]></summary>
        <parameters>
          <param id="p.wcstoumax.nptr" name="nptr" direction="in" type="const wchar_t *">
            <description><![CDATA[
<p>Input wide string.</p>
]]></description>
          </param>
          <param id="p.wcstoumax.endptr" name="endptr" direction="out" type="wchar_t **">
            <description><![CDATA[
<p>End pointer reporting for wide strings.</p>
]]></description>
          </param>
          <param id="p.wcstoumax.base" name="base" direction="in" type="int">
            <description><![CDATA[
<p>Base (0 or 2..36).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="uintmax_t">
            <description><![CDATA[
<p>Converted value; on overflow returns <code>UINTMAX_MAX</code> and sets <code>errno</code> to <code>ERANGE</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.inttypes.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the inttypes.h parsing functions you listed: <code>strtoimax</code>, <code>strtoumax</code>, <code>wcstoimax</code>, <code>wcstoumax</code>.
Other inttypes.h facilities (format macros and printf/scanf support for fixed-width types) are out of scope here.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

<script id="library-xml-2026-01-20T16-15-38-6d2699d7-e5d4-4404-b205-cde029a06fae" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="localization.time_date" name="Localization and time/date">
    <summary><![CDATA[
<p>
Process-wide localization controls and calendar/clock utilities. The locale APIs control how the C library interprets and formats
culture-sensitive data (notably numeric formatting and time formatting via <code>strftime</code>). The time/date APIs provide timestamps,
calendar conversions, CPU time measurement, and formatting helpers.
</p>
<p>
These facilities are portable but have important pitfalls: locales are process-global and can affect unrelated code; many time formatting
and conversion routines return pointers to static storage and are not thread-safe; and "calendar time" semantics depend on the host
time zone and daylight saving rules. Prefer defensive usage: copy returned strings promptly, validate conversion results, and keep
examples explicit about UTC vs local time.
</p>
]]></summary>

    <keywords>
      <kw>locale</kw>
      <kw>setlocale</kw>
      <kw>localeconv</kw>
      <kw>time</kw>
      <kw>difftime</kw>
      <kw>clock</kw>
      <kw>mktime</kw>
      <kw>strftime</kw>
      <kw>gmtime</kw>
      <kw>localtime</kw>
      <kw>asctime</kw>
      <kw>ctime</kw>
      <kw>timezone</kw>
      <kw>DST</kw>
    </keywords>

    <notes>
      <note id="n.locale.global" severity="important" topic="global_state">
        <description><![CDATA[
<p>
The active locale is process-global. Calling <code>setlocale</code> can change behavior of formatting/parsing across the entire program,
including libraries you did not write. If you must change locale, do so in a controlled place and document it.
</p>
]]></description>
      </note>
      <note id="n.time.static_storage" severity="important" topic="thread_safety">
        <description><![CDATA[
<p>
Some time functions (<code>asctime</code>, <code>ctime</code>, and typically <code>gmtime</code>/<code>localtime</code>) may return pointers to static storage
that can be overwritten by subsequent calls. Copy results immediately if you need to keep them, and avoid concurrent use across threads
unless your platform provides safer alternatives outside the C standard.
</p>
]]></description>
      </note>
      <note id="n.time.utc_vs_local" severity="important" topic="utc_local">
        <description><![CDATA[
<p>
UTC and local time are different conversions. <code>gmtime</code> converts to UTC broken-down time, <code>localtime</code> converts using the current
time zone and daylight saving rules. Make the choice explicit in your code and documentation.
</p>
]]></description>
      </note>
      <note id="n.time.dst_mktime" severity="warning" topic="dst">
        <description><![CDATA[
<p>
<code>mktime</code> interprets <code>struct tm</code> as local time. Around DST transitions, some local times are ambiguous or nonexistent.
To let the library determine DST, set <code>tm_isdst = -1</code> before calling <code>mktime</code>.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.locale" name="locale.h">
      <summary><![CDATA[
<p>
Locale selection and locale-specific formatting conventions. Primarily used to control cultural conventions such as decimal separator
and date/time formatting for <code>strftime</code>. In C99, locale selection is process-wide.
</p>
]]></summary>

      <function id="fn.setlocale" name="setlocale" kind="function">
        <signature>char *setlocale(int category, const char *locale);</signature>
        <summary><![CDATA[
<p>Sets or queries the program's current locale.</p>
]]></summary>
        <parameters>
          <param id="p.setlocale.category" name="category" direction="in" type="int">
            <description><![CDATA[
<p>
Locale category to set or query: <code>LC_ALL</code>, <code>LC_CTYPE</code>, <code>LC_NUMERIC</code>, <code>LC_TIME</code>, <code>LC_COLLATE</code>,
<code>LC_MONETARY</code>, or <code>LC_MESSAGES</code> (if provided by the implementation).
</p>
]]></description>
          </param>
          <param id="p.setlocale.locale" name="locale" direction="in" type="const char *">
            <description><![CDATA[
<p>
Locale name string. If NULL, <code>setlocale</code> does not change the locale and returns the current setting for <code>category</code>.
An empty string "" typically means "use the environment's default locale".
</p>
]]></description>
            <constraints>
              <constraint id="c.setlocale.names" severity="info">
                <description><![CDATA[
<p>Supported locale names are implementation-defined and depend on the host environment.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>
On success returns a pointer to a string identifying the current locale setting for <code>category</code>. On failure returns NULL and leaves the locale unchanged.
The returned pointer may refer to internal static storage and can be invalidated by later <code>setlocale</code> calls.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.setlocale.copy" severity="important" topic="lifetime">
            <description><![CDATA[
<p>Copy the returned string if you need to retain it across future locale changes.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.setlocale.use_user_default" lang="c99">
            <title>Adopt the user's default locale for time formatting</title>
            <code><![CDATA[
#include <locale.h>

int enable_user_locale_for_time(void) {
    /* Use environment's default locale for LC_TIME only. */
    return setlocale(LC_TIME, "") != NULL;
}
]]></code>
          </example>
          <example id="ex.setlocale.query_current" lang="c99">
            <title>Query current numeric locale without changing it</title>
            <code><![CDATA[
#include <locale.h>

const char *current_numeric_locale(void) {
    /* Returns an internal pointer; copy it if you need long-term storage. */
    return setlocale(LC_NUMERIC, NULL);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.localeconv" name="localeconv" kind="function">
        <signature>struct lconv *localeconv(void);</signature>
        <summary><![CDATA[
<p>Returns locale-specific formatting information (notably numeric and monetary conventions).</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="struct lconv *">
            <description><![CDATA[
<p>
Pointer to a <code>struct lconv</code> describing current locale conventions. The object and its strings may be in static storage and can be overwritten
by subsequent calls or locale changes.
</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.localeconv.decimal" severity="important" topic="numeric_format">
            <description><![CDATA[
<p>
<code>lconv-&gt;decimal_point</code> and <code>lconv-&gt;thousands_sep</code> describe numeric formatting conventions. Do not assume "." as the decimal separator
when formatting for humans under non-"C" locales.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.localeconv_decimal_point" lang="c99">
            <title>Read the current decimal separator</title>
            <code><![CDATA[
#include <locale.h>

const char *decimal_point_string(void) {
    struct lconv *lc = localeconv();
    return lc ? lc->decimal_point : ".";
}
]]></code>
          </example>
        </examples>
      </function>
    </header>

    <header id="hdr.time" name="time.h">
      <summary><![CDATA[
<p>
Time and date utilities: current calendar time, elapsed time computations, CPU time measurement, conversions between timestamps and
broken-down time, and formatting into strings. Many operations depend on the host time zone and locale.
</p>
]]></summary>

      <function id="fn.time" name="time" kind="function">
        <signature>time_t time(time_t *tloc);</signature>
        <summary><![CDATA[
<p>Returns the current calendar time as a <code>time_t</code> value (typically seconds since an epoch), or (time_t)-1 on failure.</p>
]]></summary>
        <parameters>
          <param id="p.time.tloc" name="tloc" direction="out" type="time_t *">
            <description><![CDATA[
<p>If non-NULL, stores the returned time value into <code>*tloc</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="time_t">
            <description><![CDATA[
<p>Current calendar time, or (time_t)-1 if the time is not available.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.time_now" lang="c99">
            <title>Get current timestamp and validate</title>
            <code><![CDATA[
#include <time.h>

int get_now(time_t *out) {
    time_t t = time(NULL);
    if (t == (time_t)-1) return 0;
    *out = t;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.difftime" name="difftime" kind="function">
        <signature>double difftime(time_t time1, time_t time0);</signature>
        <summary><![CDATA[
<p>Computes the difference <code>time1 - time0</code> in seconds, returned as a <code>double</code>.</p>
]]></summary>
        <parameters>
          <param id="p.difftime.time1" name="time1" direction="in" type="time_t">
            <description><![CDATA[
<p>Later (or first) time value.</p>
]]></description>
          </param>
          <param id="p.difftime.time0" name="time0" direction="in" type="time_t">
            <description><![CDATA[
<p>Earlier (or second) time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Difference in seconds as a double. Use this rather than subtracting time_t directly for portability.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.difftime_elapsed" lang="c99">
            <title>Measure elapsed wall time between two timestamps</title>
            <code><![CDATA[
#include <time.h>

double elapsed_seconds(time_t start, time_t end) {
    return difftime(end, start);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.clock" name="clock" kind="function">
        <signature>clock_t clock(void);</signature>
        <summary><![CDATA[
<p>Returns processor time consumed by the program since start, measured in <code>CLOCKS_PER_SEC</code> ticks per second.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="clock_t">
            <description><![CDATA[
<p>CPU time ticks, or (clock_t)-1 if the processor time is not available.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.clock.wall_vs_cpu" severity="important" topic="measurement">
            <description><![CDATA[
<p>
<code>clock</code> measures CPU time, not wall-clock time. It is useful for CPU-bound benchmarking, not for measuring real elapsed time.
Resolution and meaning are implementation-defined.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.clock_benchmark" lang="c99">
            <title>CPU-time benchmark for a function</title>
            <code><![CDATA[
#include <time.h>

double cpu_seconds_for(void (*fn)(void)) {
    clock_t a = clock();
    if (a == (clock_t)-1) return -1.0;

    fn();

    clock_t b = clock();
    if (b == (clock_t)-1) return -1.0;

    return (double)(b - a) / (double)CLOCKS_PER_SEC;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.mktime" name="mktime" kind="function">
        <signature>time_t mktime(struct tm *timeptr);</signature>
        <summary><![CDATA[
<p>Converts broken-down local time in <code>*timeptr</code> to calendar time (<code>time_t</code>), normalizing fields as needed.</p>
]]></summary>
        <parameters>
          <param id="p.mktime.timeptr" name="timeptr" direction="inout" type="struct tm *">
            <description><![CDATA[
<p>
Broken-down local time input. Fields may be normalized by the function (for example if <code>tm_mday</code> is out of range).
Set <code>tm_isdst</code> to -1 to let the library determine daylight saving time.
</p>
]]></description>
            <constraints>
              <constraint id="c.mktime.localtime" severity="important">
                <description><![CDATA[
<p><code>mktime</code> interprets the input as local time, not UTC.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="time_t">
            <description><![CDATA[
<p>Calendar time equivalent, or (time_t)-1 if the conversion is not representable.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.mktime_add_days" lang="c99">
            <title>Add N days in local time using normalization</title>
            <code><![CDATA[
#include <time.h>

int add_days_local(time_t t, int days, time_t *out) {
    struct tm *lt = localtime(&t);
    if (!lt) return 0;

    struct tm tmp = *lt;     /* Copy because localtime may use static storage. */
    tmp.tm_isdst = -1;       /* Let library recompute DST. */
    tmp.tm_mday += days;     /* mktime will normalize month/year overflow. */

    time_t r = mktime(&tmp);
    if (r == (time_t)-1) return 0;

    *out = r;
    return 1;
}
]]></code>
          </example>
          <example id="ex.mktime_build_local_datetime" lang="c99">
            <title>Build a local datetime (YYYY-MM-DD HH:MM:SS) and convert to time_t</title>
            <code><![CDATA[
#include <time.h>

int make_local_time(int y, int mon, int d, int hh, int mm, int ss, time_t *out) {
    struct tm t;
    t.tm_year = y - 1900;    /* years since 1900 */
    t.tm_mon  = mon - 1;     /* months since January: 0..11 */
    t.tm_mday = d;
    t.tm_hour = hh;
    t.tm_min  = mm;
    t.tm_sec  = ss;
    t.tm_isdst = -1;

    time_t r = mktime(&t);
    if (r == (time_t)-1) return 0;

    *out = r;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.strftime" name="strftime" kind="function">
        <signature>size_t strftime(char *s, size_t max, const char *format, const struct tm *timeptr);</signature>
        <summary><![CDATA[
<p>Formats broken-down time into a byte string according to <code>format</code> and the current locale.</p>
]]></summary>
        <parameters>
          <param id="p.strftime.s" name="s" direction="out" type="char *">
            <description><![CDATA[
<p>Destination buffer for the formatted string.</p>
]]></description>
          </param>
          <param id="p.strftime.max" name="max" direction="in" type="size_t">
            <description><![CDATA[
<p>Capacity of <code>s</code> in bytes, including the terminating NUL.</p>
]]></description>
          </param>
          <param id="p.strftime.format" name="format" direction="in" type="const char *">
            <description><![CDATA[
<p>
Format string. Interpretation is specified by the C standard for common specifiers; output language and some details depend on the current locale.
</p>
]]></description>
          </param>
          <param id="p.strftime.timeptr" name="timeptr" direction="in" type="const struct tm *">
            <description><![CDATA[
<p>Broken-down time to format.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="size_t">
            <description><![CDATA[
<p>Number of bytes written excluding the terminating NUL. Returns 0 if the result does not fit in the buffer.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.strftime.locale" severity="important" topic="locale">
            <description><![CDATA[
<p>Month and weekday names and some representations are locale-dependent. Set <code>LC_TIME</code> appropriately if you need localized output.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.strftime_iso_like_local" lang="c99">
            <title>Format local time into an ISO-like string</title>
            <code><![CDATA[
#include <time.h>

int format_local_iso(time_t t, char *buf, size_t cap) {
    struct tm *lt = localtime(&t);
    if (!lt) return 0;

    struct tm tmp = *lt;
    /* Example: 2026-01-20 14:03:05 */
    return strftime(buf, cap, "%Y-%m-%d %H:%M:%S", &tmp) != 0;
}
]]></code>
          </example>
          <example id="ex.strftime_rfcish_utc" lang="c99">
            <title>Format UTC time with an explicit UTC marker</title>
            <code><![CDATA[
#include <time.h>

int format_utc_rfcish(time_t t, char *buf, size_t cap) {
    struct tm *gt = gmtime(&t);
    if (!gt) return 0;

    struct tm tmp = *gt;
    /* Example: Tue, 20 Jan 2026 22:03:05 UTC */
    return strftime(buf, cap, "%a, %d %b %Y %H:%M:%S UTC", &tmp) != 0;
}
]]></code>
          </example>
          <example id="ex.strftime_buffer_growth" lang="c99">
            <title>Grow a buffer until strftime fits (malloc/realloc)</title>
            <code><![CDATA[
#include <time.h>
#include <stdlib.h>

char *format_time_alloc(const struct tm *t, const char *fmt) {
    size_t cap = 64;
    char *buf = (char *)malloc(cap);
    if (!buf) return NULL;

    for (;;) {
        size_t n = strftime(buf, cap, fmt, t);
        if (n != 0) {
            return buf;
        }
        if (cap > (SIZE_MAX / 2u)) {
            free(buf);
            return NULL;
        }
        cap *= 2u;
        char *tmp = (char *)realloc(buf, cap);
        if (!tmp) {
            free(buf);
            return NULL;
        }
        buf = tmp;
    }
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.gmtime" name="gmtime" kind="function">
        <signature>struct tm *gmtime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Converts calendar time <code>*timer</code> to broken-down UTC time.</p>
]]></summary>
        <parameters>
          <param id="p.gmtime.timer" name="timer" direction="in" type="const time_t *">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="struct tm *">
            <description><![CDATA[
<p>Pointer to a <code>struct tm</code> result, or NULL on failure. The result may be stored in static storage.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.gmtime_copy" lang="c99">
            <title>Convert to UTC and copy out immediately</title>
            <code><![CDATA[
#include <time.h>

int to_utc_tm(time_t t, struct tm *out) {
    struct tm *p = gmtime(&t);
    if (!p) return 0;
    *out = *p;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.localtime" name="localtime" kind="function">
        <signature>struct tm *localtime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Converts calendar time <code>*timer</code> to broken-down local time using the host time zone rules.</p>
]]></summary>
        <parameters>
          <param id="p.localtime.timer" name="timer" direction="in" type="const time_t *">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="struct tm *">
            <description><![CDATA[
<p>Pointer to a <code>struct tm</code> result, or NULL on failure. The result may be stored in static storage.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.localtime_copy" lang="c99">
            <title>Convert to local time and copy out immediately</title>
            <code><![CDATA[
#include <time.h>

int to_local_tm(time_t t, struct tm *out) {
    struct tm *p = localtime(&t);
    if (!p) return 0;
    *out = *p;
    return 1;
}
]]></code>
          </example>
          <example id="ex.localtime_fields" lang="c99">
            <title>Extract calendar fields safely</title>
            <code><![CDATA[
#include <time.h>

int local_ymd(time_t t, int *y, int *m, int *d) {
    struct tm tmp;
    if (!to_local_tm(t, &tmp)) return 0;

    *y = tmp.tm_year + 1900;
    *m = tmp.tm_mon + 1;
    *d = tmp.tm_mday;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.asctime" name="asctime" kind="function">
        <signature>char *asctime(const struct tm *timeptr);</signature>
        <summary><![CDATA[
<p>Formats broken-down time into a fixed, implementation-defined string representation and returns a pointer to it.</p>
]]></summary>
        <parameters>
          <param id="p.asctime.timeptr" name="timeptr" direction="in" type="const struct tm *">
            <description><![CDATA[
<p>Broken-down time to format.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to an internal static string. The contents may be overwritten by subsequent calls. Typically ends with a newline.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.asctime.recommendation" severity="important" topic="best_practice">
            <description><![CDATA[
<p>
Prefer <code>strftime</code> for controlled formatting and buffer management. Use <code>asctime</code> mainly for quick debugging,
and copy the result immediately.
</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.asctime_copy" lang="c99">
            <title>Use asctime for debugging and copy the result</title>
            <code><![CDATA[
#include <time.h>
#include <string.h>

int asctime_copy(const struct tm *t, char *buf, size_t cap) {
    const char *s = asctime(t);
    if (!s) return 0;
    /* Copy with truncation; for logs/debug only. */
    if (cap == 0) return 0;
    strncpy(buf, s, cap - 1u);
    buf[cap - 1u] = '\0';
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ctime" name="ctime" kind="function">
        <signature>char *ctime(const time_t *timer);</signature>
        <summary><![CDATA[
<p>Equivalent to <code>asctime(localtime(timer))</code> in typical implementations: converts calendar time to a human-readable string.</p>
]]></summary>
        <parameters>
          <param id="p.ctime.timer" name="timer" direction="in" type="const time_t *">
            <description><![CDATA[
<p>Pointer to calendar time value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="char *">
            <description><![CDATA[
<p>Pointer to an internal static string (often ending with a newline). The contents may be overwritten by subsequent time calls.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.ctime.recommendation" severity="important" topic="best_practice">
            <description><![CDATA[
<p>Prefer <code>strftime</code> for predictable output and explicit choice of UTC vs local time.</p>
]]></description>
          </note>
        </notes>
        <examples>
          <example id="ex.ctime_quick" lang="c99">
            <title>Quick human-readable timestamp (debug only)</title>
            <code><![CDATA[
#include <time.h>
#include <stdio.h>

void print_now_debug(void) {
    time_t now = time(NULL);
    if (now == (time_t)-1) return;

    const char *s = ctime(&now);
    if (!s) return;

    /* ctime string often ends with newline already. */
    fputs(s, stdout);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.time.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry covers the full time.h function list you provided: <code>time</code>, <code>difftime</code>, <code>clock</code>, <code>mktime</code>,
<code>strftime</code>, <code>gmtime</code>, <code>localtime</code>, <code>asctime</code>, <code>ctime</code>. The tricky parts are UTC vs local time,
DST ambiguity, locale-dependent formatting, and static-storage return values; the examples emphasize defensive patterns for those.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>

<script id="library-xml-2026-01-20T16-16-07-80d6c6aa-9e24-446e-bce5-8a5f149ef61f" type="application/xml">ï»¿<?xml version="1.0" encoding="UTF-8"?>
<document version="1.0" standard="C99" xml:lang="en">

  <textFormatting>
    <policy id="fmt.minimal.html" name="Minimal inline HTML in text nodes">
      <scope>
        <allowedIn>summary</allowedIn>
        <allowedIn>description</allowedIn>
        <allowedIn>notes</allowedIn>
        <allowedIn>constraints</allowedIn>
        <allowedIn>returns</allowedIn>
      </scope>
      <allowedTags>
        <tag name="p" kind="block"/>
        <tag name="strong" kind="inline"/>
        <tag name="em" kind="inline"/>
        <tag name="code" kind="inline"/>
        <tag name="a" kind="inline"/>
        <tag name="br" kind="inline"/>
      </allowedTags>
      <restrictions>
        <r>No tags beyond allowedTags.</r>
        <r>Prefer &lt;code&gt; blocks for code samples.</r>
      </restrictions>
    </policy>
  </textFormatting>

  <category id="math.real.complex.fenv" name="Math (real, complex, and floating environment)">
    <summary><![CDATA[
<p>
Numerical computing primitives for real and complex arithmetic and for controlling/inspecting the floating-point environment.
This category covers three closely related modules:
(1) real math from <code>math.h</code>, including rounding, decomposition, transcendental functions, and robust helpers such as <code>fmin</code>/<code>fmax</code>;
(2) complex arithmetic from <code>complex.h</code>, mirroring many real functions for complex numbers plus accessors;
(3) floating-point environment control from <code>fenv.h</code>, used to query and manage exceptions (invalid, overflow, etc.) and rounding modes.
</p>
<p>
Portability guidance: prefer functions designed to handle NaNs and signed zero predictably (<code>fmin</code>, <code>fmax</code>, <code>copysign</code>);
avoid assuming a particular floating-point format; do not rely on <code>errno</code> alone for detecting floating exceptions; and use <code>fenv.h</code>
only when you have a clear numerical need because behavior may depend on compiler flags and runtime environment.
</p>
]]></summary>

    <keywords>
      <kw>math</kw>
      <kw>complex</kw>
      <kw>fenv</kw>
      <kw>rounding</kw>
      <kw>exceptions</kw>
      <kw>NaN</kw>
      <kw>infinity</kw>
      <kw>fmin</kw>
      <kw>fmax</kw>
      <kw>copysign</kw>
      <kw>nextafter</kw>
      <kw>sqrt</kw>
      <kw>pow</kw>
      <kw>log</kw>
      <kw>exp</kw>
      <kw>sin</kw>
      <kw>cos</kw>
      <kw>tan</kw>
      <kw>cabs</kw>
      <kw>csqrt</kw>
      <kw>feclearexcept</kw>
      <kw>fetestexcept</kw>
      <kw>fesetround</kw>
    </keywords>

    <notes>
      <note id="n.math.domain_range" severity="important" topic="domain_range">
        <description><![CDATA[
<p>
Many functions have domain restrictions (for example <code>sqrt(x)</code> for x &lt; 0, <code>log(x)</code> for x &lt;= 0).
Results and error signaling use a mix of special values (NaN, +/-inf), floating exceptions, and possibly <code>errno</code>.
If you need robust detection, prefer checking with <code>fenv.h</code> exceptions (and/or <code>isnan</code>/<code>isfinite</code> where available).
</p>
]]></description>
      </note>
      <note id="n.math.errno" severity="info" topic="errno">
        <description><![CDATA[
<p>
C99 permits but does not require setting <code>errno</code> for math errors. Do not depend on <code>errno</code> alone for correctness.
If you use <code>errno</code>, set it to 0 before the call and check after, and also consider floating exceptions.
</p>
]]></description>
      </note>
      <note id="n.math.rounding" severity="important" topic="rounding_modes">
        <description><![CDATA[
<p>
Rounding-related functions differ:
<code>floor</code>/<code>ceil</code> return floating results;
<code>round</code> rounds half away from zero (returns floating);
<code>rint</code>/<code>nearbyint</code> round according to the current rounding mode (returns floating);
<code>lround</code>/<code>llround</code> return integers and raise range issues if unrepresentable.
</p>
]]></description>
      </note>
      <note id="n.math.fenv.compiler" severity="warning" topic="fenv_compiler_flags">
        <description><![CDATA[
<p>
Floating environment behavior can be affected by compiler optimizations (for example fast-math) that assume no NaNs/infinities
or ignore exception semantics. If you rely on <code>fenv.h</code>, ensure your build settings preserve required semantics.
</p>
]]></description>
      </note>
      <note id="n.math.complex" severity="important" topic="complex_numbers">
        <description><![CDATA[
<p>
Complex functions operate on <code>double complex</code> (and related types) and may produce NaNs or infinities for some inputs.
Use accessors like <code>creal</code>/<code>cimag</code> for decomposition and <code>cabs</code> for magnitude.
</p>
]]></description>
      </note>
    </notes>

    <header id="hdr.math" name="math.h">
      <summary><![CDATA[
<p>
Real-valued mathematical functions: classification helpers, decomposition, rounding, power/log/exp, trig and hyperbolic families,
and numeric utilities that handle NaNs and signed zero sensibly.
</p>
]]></summary>

      <function id="fn.fabs" name="fabs" kind="function">
        <signature>double fabs(double x);</signature>
        <summary><![CDATA[
<p>Returns the absolute value of <code>x</code> as a double.</p>
]]></summary>
        <parameters>
          <param id="p.fabs.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Absolute value; preserves NaN as NaN.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fmod" name="fmod" kind="function">
        <signature>double fmod(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes the floating-point remainder of <code>x / y</code> with the same sign as <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fmod.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Dividend.</p>
]]></description>
          </param>
          <param id="p.fmod.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Divisor.</p>
]]></description>
            <constraints>
              <constraint id="c.fmod.y_nonzero" severity="important">
                <description><![CDATA[
<p>If <code>y</code> is 0, the result is domain error (typically NaN) and may raise FE_INVALID.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Remainder <code>r</code> such that <code>x = q*y + r</code> with integer-like <code>q</code>, and <code>|r| &lt; |y|</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fmod.wrap_angle" lang="c99">
            <title>Wrap an angle into (-pi, pi]</title>
            <code><![CDATA[
#include <math.h>

double wrap_pi(double a) {
    const double two_pi = 2.0 * acos(-1.0);
    a = fmod(a, two_pi);
    if (a <= -acos(-1.0)) a += two_pi;
    if (a >  acos(-1.0))  a -= two_pi;
    return a;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.remainder" name="remainder" kind="function">
        <signature>double remainder(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes the IEEE-style remainder of <code>x / y</code>, where the quotient is rounded to the nearest integer (ties to even).</p>
]]></summary>
        <parameters>
          <param id="p.remainder.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Dividend.</p>
]]></description>
          </param>
          <param id="p.remainder.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Divisor.</p>
]]></description>
            <constraints>
              <constraint id="c.remainder.y_nonzero" severity="important">
                <description><![CDATA[
<p>If <code>y</code> is 0, domain error (often NaN) and may raise FE_INVALID.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Remainder with magnitude at most <code>|y|/2</code>, using tie-to-even rounding of the quotient.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.modf" name="modf" kind="function">
        <signature>double modf(double x, double *iptr);</signature>
        <summary><![CDATA[
<p>Splits <code>x</code> into fractional and integral parts.</p>
]]></summary>
        <parameters>
          <param id="p.modf.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
          <param id="p.modf.iptr" name="iptr" direction="out" type="double *">
            <description><![CDATA[
<p>Receives the integral part of <code>x</code> (as a double).</p>
]]></description>
            <constraints>
              <constraint id="c.modf.iptr_nonnull" severity="important">
                <description><![CDATA[
<p><code>iptr</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Fractional part of <code>x</code>, with the same sign as <code>x</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.modf.split" lang="c99">
            <title>Split into integer and fraction</title>
            <code><![CDATA[
#include <math.h>

void split(double x, double *i, double *f) {
    *f = modf(x, i);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.frexp" name="frexp" kind="function">
        <signature>double frexp(double x, int *exp);</signature>
        <summary><![CDATA[
<p>Decomposes <code>x</code> into mantissa and exponent: <code>x = m * 2^e</code> with <code>m</code> in [0.5, 1) (or 0).</p>
]]></summary>
        <parameters>
          <param id="p.frexp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
          <param id="p.frexp.exp" name="exp" direction="out" type="int *">
            <description><![CDATA[
<p>Receives exponent value <code>e</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.frexp.exp_nonnull" severity="important">
                <description><![CDATA[
<p><code>exp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Mantissa <code>m</code>. If <code>x</code> is 0, returns 0 and stores 0 in <code>*exp</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ldexp" name="ldexp" kind="function">
        <signature>double ldexp(double x, int exp);</signature>
        <summary><![CDATA[
<p>Computes <code>x * 2^exp</code>, typically the inverse of <code>frexp</code> (modulo rounding).</p>
]]></summary>
        <parameters>
          <param id="p.ldexp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Mantissa-like input.</p>
]]></description>
          </param>
          <param id="p.ldexp.exp" name="exp" direction="in" type="int">
            <description><![CDATA[
<p>Exponent power of two.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Scaled value; may overflow to infinity or underflow toward 0, possibly raising exceptions.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fmin" name="fmin" kind="function">
        <signature>double fmin(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the smaller of <code>x</code> and <code>y</code>, with defined NaN handling (if one is NaN, returns the other).</p>
]]></summary>
        <parameters>
          <param id="p.fmin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First value.</p>
]]></description>
          </param>
          <param id="p.fmin.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Minimum, preferring the numeric argument if the other is NaN. Preserves signed zero semantics per specification.</p>
]]></description>
          </return>
        </returns>
        <notes>
          <note id="n.fmin.vs_operator" severity="important" topic="nan_handling">
            <description><![CDATA[
<p>Prefer <code>fmin</code> over <code>(x &lt; y ? x : y)</code> when NaN behavior matters.</p>
]]></description>
          </note>
        </notes>
      </function>

      <function id="fn.fmax" name="fmax" kind="function">
        <signature>double fmax(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the larger of <code>x</code> and <code>y</code>, with defined NaN handling.</p>
]]></summary>
        <parameters>
          <param id="p.fmax.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First value.</p>
]]></description>
          </param>
          <param id="p.fmax.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Maximum, preferring the numeric argument if the other is NaN.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.copysign" name="copysign" kind="function">
        <signature>double copysign(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns a value with the magnitude of <code>x</code> and the sign of <code>y</code> (including signed zero).</p>
]]></summary>
        <parameters>
          <param id="p.copysign.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Magnitude source.</p>
]]></description>
          </param>
          <param id="p.copysign.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Sign source.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Magnitude from <code>x</code> with sign bit from <code>y</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.copysign.force_sign" lang="c99">
            <title>Force a value to be negative or positive without branching</title>
            <code><![CDATA[
#include <math.h>

double force_positive(double x) { return copysign(x, 1.0); }
double force_negative(double x) { return copysign(x, -1.0); }
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.nextafter" name="nextafter" kind="function">
        <signature>double nextafter(double x, double y);</signature>
        <summary><![CDATA[
<p>Returns the next representable double after <code>x</code> in the direction of <code>y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.nextafter.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Starting value.</p>
]]></description>
          </param>
          <param id="p.nextafter.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Direction target. If <code>y</code> is greater than <code>x</code>, moves upward; if less, downward; if equal, returns <code>x</code>.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Adjacent representable value, possibly raising overflow/underflow exceptions at the edges.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.nextafter_open_interval" lang="c99">
            <title>Create an open interval endpoint</title>
            <code><![CDATA[
#include <math.h>

/* Returns the largest representable value strictly less than x. */
double prev_double(double x) {
    return nextafter(x, -INFINITY);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.nexttoward" name="nexttoward" kind="function">
        <signature>double nexttoward(double x, long double y);</signature>
        <summary><![CDATA[
<p>Like <code>nextafter</code>, but the direction is specified as <code>long double</code> for better precision of the target.</p>
]]></summary>
        <parameters>
          <param id="p.nexttoward.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Starting value.</p>
]]></description>
          </param>
          <param id="p.nexttoward.y" name="y" direction="in" type="long double">
            <description><![CDATA[
<p>Direction target as long double.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Adjacent representable value after <code>x</code> toward <code>y</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.floor" name="floor" kind="function">
        <signature>double floor(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward negative infinity, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.floor.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Largest integral value not greater than <code>x</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ceil" name="ceil" kind="function">
        <signature>double ceil(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward positive infinity, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.ceil.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Smallest integral value not less than <code>x</code>.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.trunc" name="trunc" kind="function">
        <signature>double trunc(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> toward zero, returning an integral-valued double.</p>
]]></summary>
        <parameters>
          <param id="p.trunc.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral value by truncation toward zero.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.round" name="round" kind="function">
        <signature>double round(double x);</signature>
        <summary><![CDATA[
<p>Rounds <code>x</code> to the nearest integer value, with halfway cases rounded away from zero.</p>
]]></summary>
        <parameters>
          <param id="p.round.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Nearest integral-valued double.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.lround" name="lround" kind="function">
        <signature>long lround(double x);</signature>
        <summary><![CDATA[
<p>Rounds to the nearest integer, halfway away from zero, and returns as <code>long</code>.</p>
]]></summary>
        <parameters>
          <param id="p.lround.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
            <constraints>
              <constraint id="c.lround.range" severity="important">
                <description><![CDATA[
<p>If the rounded value is outside the range of <code>long</code>, the behavior is undefined or raises an invalid exception depending on implementation.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="long">
            <description><![CDATA[
<p>Rounded integer result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.llround" name="llround" kind="function">
        <signature>long long llround(double x);</signature>
        <summary><![CDATA[
<p>Rounds to the nearest integer, halfway away from zero, and returns as <code>long long</code>.</p>
]]></summary>
        <parameters>
          <param id="p.llround.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="long long">
            <description><![CDATA[
<p>Rounded integer result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.nearbyint" name="nearbyint" kind="function">
        <signature>double nearbyint(double x);</signature>
        <summary><![CDATA[
<p>Rounds according to the current rounding mode and returns an integral-valued double, typically without raising FE_INEXACT.</p>
]]></summary>
        <parameters>
          <param id="p.nearbyint.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral-valued double according to current rounding mode.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.rint" name="rint" kind="function">
        <signature>double rint(double x);</signature>
        <summary><![CDATA[
<p>Rounds according to the current rounding mode and returns an integral-valued double (may raise FE_INEXACT).</p>
]]></summary>
        <parameters>
          <param id="p.rint.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Integral-valued double according to current rounding mode.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.sqrt" name="sqrt" kind="function">
        <signature>double sqrt(double x);</signature>
        <summary><![CDATA[
<p>Computes the square root of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.sqrt.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain is x &gt;= 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Square root. For x &lt; 0, typically returns NaN and may raise FE_INVALID.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.sqrt_hypot" lang="c99">
            <title>Prefer hypot for sqrt(x*x + y*y)</title>
            <code><![CDATA[
#include <math.h>

double length2d(double x, double y) {
    return hypot(x, y);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.cbrt" name="cbrt" kind="function">
        <signature>double cbrt(double x);</signature>
        <summary><![CDATA[
<p>Computes the real cube root of <code>x</code>, preserving the sign for negative inputs.</p>
]]></summary>
        <parameters>
          <param id="p.cbrt.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Cube root.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.hypot" name="hypot" kind="function">
        <signature>double hypot(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes <code>sqrt(x*x + y*y)</code> with reduced overflow/underflow risk.</p>
]]></summary>
        <parameters>
          <param id="p.hypot.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>First component.</p>
]]></description>
          </param>
          <param id="p.hypot.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Second component.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hypotenuse length.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.pow" name="pow" kind="function">
        <signature>double pow(double x, double y);</signature>
        <summary><![CDATA[
<p>Computes <code>x</code> raised to the power <code>y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.pow.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Base.</p>
]]></description>
          </param>
          <param id="p.pow.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Power result; may overflow to infinity or underflow, and may return NaN for some domain combinations.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.pow_int_exp" lang="c99">
            <title>Integer exponent: consider a loop for exactness and speed</title>
            <code><![CDATA[
#include <math.h>

double powi(double x, int n) {
    double r = 1.0;
    int e = n;
    if (e < 0) { x = 1.0 / x; e = -e; }

    while (e) {
        if (e & 1) r *= x;
        x *= x;
        e >>= 1;
    }
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.exp" name="exp" kind="function">
        <signature>double exp(double x);</signature>
        <summary><![CDATA[
<p>Computes e raised to <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.exp.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Exponential result; may overflow to infinity for large x or underflow toward 0 for very negative x.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.expm1" name="expm1" kind="function">
        <signature>double expm1(double x);</signature>
        <summary><![CDATA[
<p>Computes <code>exp(x) - 1</code> accurately for small <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.expm1.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Accurate <code>exp(x) - 1</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.expm1_small" lang="c99">
            <title>Stable computation for small x</title>
            <code><![CDATA[
#include <math.h>

double relative_growth(double x) {
    /* Better than exp(x) - 1 when x is near 0. */
    return expm1(x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.log" name="log" kind="function">
        <signature>double log(double x);</signature>
        <summary><![CDATA[
<p>Computes the natural logarithm of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Natural log; for x &lt; 0 returns NaN; for x == 0 returns -infinity, typically raising FE_DIVBYZERO.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.log10" name="log10" kind="function">
        <signature>double log10(double x);</signature>
        <summary><![CDATA[
<p>Computes base-10 logarithm of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log10.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; 0 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Base-10 log.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.log1p" name="log1p" kind="function">
        <signature>double log1p(double x);</signature>
        <summary><![CDATA[
<p>Computes <code>log(1 + x)</code> accurately for small <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.log1p.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: x &gt; -1 for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Accurate <code>log(1 + x)</code>.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.log1p_small" lang="c99">
            <title>Stable log(1+x) for small x</title>
            <code><![CDATA[
#include <math.h>

double log_one_plus(double x) {
    return log1p(x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.sin" name="sin" kind="function">
        <signature>double sin(double x);</signature>
        <summary><![CDATA[
<p>Computes sine of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.sin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Sine value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cos" name="cos" kind="function">
        <signature>double cos(double x);</signature>
        <summary><![CDATA[
<p>Computes cosine of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.cos.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Cosine value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.tan" name="tan" kind="function">
        <signature>double tan(double x);</signature>
        <summary><![CDATA[
<p>Computes tangent of <code>x</code> (radians).</p>
]]></summary>
        <parameters>
          <param id="p.tan.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Angle in radians.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Tangent value; may overflow near odd multiples of pi/2.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.asin" name="asin" kind="function">
        <signature>double asin(double x);</signature>
        <summary><![CDATA[
<p>Computes arcsine of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.asin.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: [-1, 1] for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arcsine in radians; outside domain typically returns NaN and may raise FE_INVALID.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.acos" name="acos" kind="function">
        <signature>double acos(double x);</signature>
        <summary><![CDATA[
<p>Computes arccosine of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.acos.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value. Domain: [-1, 1] for real results.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arccosine in radians.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.atan" name="atan" kind="function">
        <signature>double atan(double x);</signature>
        <summary><![CDATA[
<p>Computes arctangent of <code>x</code> (returns radians).</p>
]]></summary>
        <parameters>
          <param id="p.atan.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Arctangent in radians.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.atan2" name="atan2" kind="function">
        <signature>double atan2(double y, double x);</signature>
        <summary><![CDATA[
<p>Computes arctangent of <code>y/x</code> using the signs of both to determine the correct quadrant.</p>
]]></summary>
        <parameters>
          <param id="p.atan2.y" name="y" direction="in" type="double">
            <description><![CDATA[
<p>Y coordinate.</p>
]]></description>
          </param>
          <param id="p.atan2.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>X coordinate.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Angle in radians, typically in [-pi, pi].</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.atan2_angle" lang="c99">
            <title>Compute polar angle from x,y</title>
            <code><![CDATA[
#include <math.h>

double angle(double x, double y) {
    return atan2(y, x);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.sinh" name="sinh" kind="function">
        <signature>double sinh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic sine of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.sinh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic sine; may overflow for large |x|.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cosh" name="cosh" kind="function">
        <signature>double cosh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic cosine of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cosh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic cosine; may overflow for large |x|.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.tanh" name="tanh" kind="function">
        <signature>double tanh(double x);</signature>
        <summary><![CDATA[
<p>Computes hyperbolic tangent of <code>x</code>.</p>
]]></summary>
        <parameters>
          <param id="p.tanh.x" name="x" direction="in" type="double">
            <description><![CDATA[
<p>Input value.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Hyperbolic tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.math.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the math.h functions you listed. Many of these have float/long double variants in the standard, but this
document focuses on the canonical double forms for cross-platform usage, mirroring the approach used in earlier categories.
</p>
]]></summary>
      </function>
    </header>

    <header id="hdr.complex" name="complex.h">
      <summary><![CDATA[
<p>
Complex arithmetic over <code>double complex</code>. Includes accessors (<code>creal</code>, <code>cimag</code>), magnitude/phase
(<code>cabs</code>, <code>carg</code>), and complex analogues of exp/log/pow/sqrt and trig/hyperbolic functions.
</p>
]]></summary>

      <function id="fn.creal" name="creal" kind="function">
        <signature>double creal(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the real part of complex number <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.creal.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Real component.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cimag" name="cimag" kind="function">
        <signature>double cimag(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the imaginary part of complex number <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cimag.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Imaginary component.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cabs" name="cabs" kind="function">
        <signature>double cabs(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the magnitude (modulus) of <code>z</code>, equivalent to <code>hypot(creal(z), cimag(z))</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cabs.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Magnitude.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.carg" name="carg" kind="function">
        <signature>double carg(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the phase angle (argument) of <code>z</code>, typically in radians.</p>
]]></summary>
        <parameters>
          <param id="p.carg.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double">
            <description><![CDATA[
<p>Argument angle.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.conj" name="conj" kind="function">
        <signature>double complex conj(double complex z);</signature>
        <summary><![CDATA[
<p>Returns the complex conjugate of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.conj.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Conjugate value.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.conj_inner_product" lang="c99">
            <title>Complex inner product term</title>
            <code><![CDATA[
#include <complex.h>

double complex inner_term(double complex a, double complex b) {
    return conj(a) * b;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.cproj" name="cproj" kind="function">
        <signature>double complex cproj(double complex z);</signature>
        <summary><![CDATA[
<p>Projects <code>z</code> onto the Riemann sphere (useful for handling infinities consistently).</p>
]]></summary>
        <parameters>
          <param id="p.cproj.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Projected complex value.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cexp" name="cexp" kind="function">
        <signature>double complex cexp(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex exponential of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cexp.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex exponential result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.clog" name="clog" kind="function">
        <signature>double complex clog(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex natural logarithm of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.clog.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex logarithm.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.cpow" name="cpow" kind="function">
        <signature>double complex cpow(double complex x, double complex y);</signature>
        <summary><![CDATA[
<p>Computes complex power <code>x^y</code>.</p>
]]></summary>
        <parameters>
          <param id="p.cpow.x" name="x" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex base.</p>
]]></description>
          </param>
          <param id="p.cpow.y" name="y" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex exponent.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex power result.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csqrt" name="csqrt" kind="function">
        <signature>double complex csqrt(double complex z);</signature>
        <summary><![CDATA[
<p>Computes the complex square root of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csqrt.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex square root.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.csqrt_negative_real" lang="c99">
            <title>Square root of a negative real without NaN</title>
            <code><![CDATA[
#include <complex.h>

double complex sqrt_neg(double x) {
    /* If x is negative real, csqrt produces an imaginary result. */
    return csqrt(x + 0.0 * I);
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.ccos" name="ccos" kind="function">
        <signature>double complex ccos(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex cosine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ccos.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex cosine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csin" name="csin" kind="function">
        <signature>double complex csin(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex sine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csin.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex sine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ctan" name="ctan" kind="function">
        <signature>double complex ctan(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex tangent of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ctan.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ccosh" name="ccosh" kind="function">
        <signature>double complex ccosh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic cosine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ccosh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic cosine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.csinh" name="csinh" kind="function">
        <signature>double complex csinh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic sine of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.csinh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic sine.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.ctanh" name="ctanh" kind="function">
        <signature>double complex ctanh(double complex z);</signature>
        <summary><![CDATA[
<p>Computes complex hyperbolic tangent of <code>z</code>.</p>
]]></summary>
        <parameters>
          <param id="p.ctanh.z" name="z" direction="in" type="double complex">
            <description><![CDATA[
<p>Complex input.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="double complex">
            <description><![CDATA[
<p>Complex hyperbolic tangent.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.complex.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the complex.h functions you listed, documented in their double-complex forms for portability and consistency.
</p>
]]></summary>
      </function>
    </header>

    <header id="hdr.fenv" name="fenv.h">
      <summary><![CDATA[
<p>
Floating-point environment control: clear, raise, test, and save/restore floating exceptions and control rounding modes.
This is used in numerically sensitive code (validation, reproducibility, and error detection) and requires careful attention to compiler settings.
</p>
]]></summary>

      <function id="fn.feclearexcept" name="feclearexcept" kind="function">
        <signature>int feclearexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Clears the floating-point exception flags specified by <code>excepts</code>.</p>
]]></summary>
        <parameters>
          <param id="p.feclearexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>
Bitmask of exceptions, typically combining <code>FE_INVALID</code>, <code>FE_DIVBYZERO</code>, <code>FE_OVERFLOW</code>, <code>FE_UNDERFLOW</code>, <code>FE_INEXACT</code>.
You may also use <code>FE_ALL_EXCEPT</code>.
</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero if the operation is not supported for the requested flags.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fegetexceptflag" name="fegetexceptflag" kind="function">
        <signature>int fegetexceptflag(fexcept_t *flagp, int excepts);</signature>
        <summary><![CDATA[
<p>Stores the state of specified exception flags into <code>*flagp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fegetexceptflag.flagp" name="flagp" direction="out" type="fexcept_t *">
            <description><![CDATA[
<p>Receives an opaque snapshot of the requested exception flags.</p>
]]></description>
            <constraints>
              <constraint id="c.fegetexceptflag.nonnull" severity="important">
                <description><![CDATA[
<p><code>flagp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fegetexceptflag.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask selecting which exception flags to snapshot.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feraiseexcept" name="feraiseexcept" kind="function">
        <signature>int feraiseexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Raises the floating-point exceptions specified by <code>excepts</code>.</p>
]]></summary>
        <parameters>
          <param id="p.feraiseexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask of exceptions to raise.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure or if unsupported.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fesetexceptflag" name="fesetexceptflag" kind="function">
        <signature>int fesetexceptflag(const fexcept_t *flagp, int excepts);</signature>
        <summary><![CDATA[
<p>Sets the exception flags specified by <code>excepts</code> to the state stored in <code>*flagp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fesetexceptflag.flagp" name="flagp" direction="in" type="const fexcept_t *">
            <description><![CDATA[
<p>Pointer to a previously captured exception-flag snapshot.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetexceptflag.nonnull" severity="important">
                <description><![CDATA[
<p><code>flagp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
          <param id="p.fesetexceptflag.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask selecting which exception flags to update.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fetestexcept" name="fetestexcept" kind="function">
        <signature>int fetestexcept(int excepts);</signature>
        <summary><![CDATA[
<p>Tests which of the specified floating-point exception flags are currently set.</p>
]]></summary>
        <parameters>
          <param id="p.fetestexcept.excepts" name="excepts" direction="in" type="int">
            <description><![CDATA[
<p>Bitmask of exceptions to test (or <code>FE_ALL_EXCEPT</code>).</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>Bitwise OR of the exceptions that are currently set among those requested.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fenv.detect_domain_error" lang="c99">
            <title>Detect invalid operation using fenv around a computation</title>
            <code><![CDATA[
#include <math.h>
#include <fenv.h>

int sqrt_checked(double x, double *out) {
    (void)feclearexcept(FE_ALL_EXCEPT);

    double r = sqrt(x);

    if (fetestexcept(FE_INVALID)) {
        return 0;
    }

    *out = r;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fegetround" name="fegetround" kind="function">
        <signature>int fegetround(void);</signature>
        <summary><![CDATA[
<p>Gets the current floating-point rounding mode.</p>
]]></summary>
        <parameters/>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>One of <code>FE_TONEAREST</code>, <code>FE_DOWNWARD</code>, <code>FE_UPWARD</code>, <code>FE_TOWARDZERO</code> (values are implementation-defined).</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fesetround" name="fesetround" kind="function">
        <signature>int fesetround(int round);</signature>
        <summary><![CDATA[
<p>Sets the floating-point rounding mode.</p>
]]></summary>
        <parameters>
          <param id="p.fesetround.round" name="round" direction="in" type="int">
            <description><![CDATA[
<p>Requested rounding mode, typically one of <code>FE_TONEAREST</code>, <code>FE_DOWNWARD</code>, <code>FE_UPWARD</code>, <code>FE_TOWARDZERO</code>.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetround.valid" severity="important">
                <description><![CDATA[
<p>Pass a supported rounding mode. If unsupported, the function returns non-zero and the rounding mode may remain unchanged.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.fesetround_scope" lang="c99">
            <title>Temporarily change rounding mode and restore it</title>
            <code><![CDATA[
#include <fenv.h>
#include <math.h>

double round_down_then_restore(double x) {
    fenv_t env;
    if (fegetenv(&env) != 0) {
        return floor(x);
    }

    if (fesetround(FE_DOWNWARD) != 0) {
        return floor(x);
    }

    double r = rint(x);

    (void)fesetenv(&env);
    return r;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fegetenv" name="fegetenv" kind="function">
        <signature>int fegetenv(fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Stores the current floating-point environment into <code>*envp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fegetenv.envp" name="envp" direction="out" type="fenv_t *">
            <description><![CDATA[
<p>Receives an opaque snapshot of the floating-point environment.</p>
]]></description>
            <constraints>
              <constraint id="c.fegetenv.nonnull" severity="important">
                <description><![CDATA[
<p><code>envp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feholdexcept" name="feholdexcept" kind="function">
        <signature>int feholdexcept(fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Saves the current environment to <code>*envp</code>, then clears exception flags and may install a non-stop mode.</p>
]]></summary>
        <parameters>
          <param id="p.feholdexcept.envp" name="envp" direction="out" type="fenv_t *">
            <description><![CDATA[
<p>Receives the saved environment.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
        <examples>
          <example id="ex.feholdexcept_isolate" lang="c99">
            <title>Isolate floating exceptions during a sensitive calculation</title>
            <code><![CDATA[
#include <math.h>
#include <fenv.h>

int compute_isolated(double x, double *out, int *excepts_out) {
    fenv_t env;
    if (feholdexcept(&env) != 0) return 0;

    double r = log(x);

    int ex = fetestexcept(FE_ALL_EXCEPT);

    (void)feupdateenv(&env); /* Restore and re-raise exceptions that occurred. */

    *out = r;
    *excepts_out = ex;
    return 1;
}
]]></code>
          </example>
        </examples>
      </function>

      <function id="fn.fesetenv" name="fesetenv" kind="function">
        <signature>int fesetenv(const fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Restores the floating-point environment from <code>*envp</code>.</p>
]]></summary>
        <parameters>
          <param id="p.fesetenv.envp" name="envp" direction="in" type="const fenv_t *">
            <description><![CDATA[
<p>Previously saved environment snapshot.</p>
]]></description>
            <constraints>
              <constraint id="c.fesetenv.nonnull" severity="important">
                <description><![CDATA[
<p><code>envp</code> must be non-NULL.</p>
]]></description>
              </constraint>
            </constraints>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.feupdateenv" name="feupdateenv" kind="function">
        <signature>int feupdateenv(const fenv_t *envp);</signature>
        <summary><![CDATA[
<p>Restores the environment from <code>*envp</code> and then raises any exceptions that were set when the function was called.</p>
]]></summary>
        <parameters>
          <param id="p.feupdateenv.envp" name="envp" direction="in" type="const fenv_t *">
            <description><![CDATA[
<p>Previously saved environment snapshot.</p>
]]></description>
          </param>
        </parameters>
        <returns>
          <return type="int">
            <description><![CDATA[
<p>0 on success, non-zero on failure.</p>
]]></description>
          </return>
        </returns>
      </function>

      <function id="fn.fenv.category_note" name="_category_note" kind="internal_note">
        <summary><![CDATA[
<p>
This header entry includes the fenv.h functions you listed. Exception and rounding behavior can be sensitive to compiler settings,
so document build constraints when these facilities are part of correctness.
</p>
]]></summary>
      </function>

    </header>

  </category>

</document>


</script>
  </section>

  <script src="app.js"></script>
  <script src="lib-asvd-microlight-0.0.7/microlight.js"></script>
</body>
</html>
